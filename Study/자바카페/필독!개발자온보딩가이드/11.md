# 11장

## 11장 소프트웨어 수명주기 관점의 진화하는 아키텍처 구현
- 요구사항의 변경에 대응하려면 진화하는 아키텍처를 구현해야 함. 진화하는 아키텍처란 진화에 방해가 되는 복잡성을 배제하기 위한 것

### 복잡도를 이해하자
- 소프트웨어 설계 철학에서 ‘복잡도란 시스템을 이해하고 수정하는 것을 어렵게 만드는 시스템의 구조와 관련된 모든 것’이라고 정의
- 복잡한 시스템은 높은 의존성과 높은 모호성이라는 두가지 특성을 갖고 우리는 여기에 세 번째 특성인 높은 관성을 추가하고자 함
- 의존성이 높은 소프트웨어는 다른 코드의 API나 동작에 의존하게 되는데 의존성은 분명히 불가피한 것으로 필요한 경우도 있지만 반드시 균형을 맞추어야 함
- 새로운 연결과 추정이 많아질 수록 코드를 변경하기는 어려워지고 의존성이 높은 시스템은 강한 결합과 변경의 영향도 확대로 인해 수정이 어려움
- 모호성이 높으면 프로그래머는 변경의 부작용, 코드의 동작, 변경이 필요한 지점 등을 예측하기가 어려워 짐. 모호한 코드는 학습에도 오랜 시간이 걸리며 개발자의 부주의로 문제가 일어날 확률 또한 높아짐
    - 너무 많은 작업을 담당하는 신 객체, 부작용을 유발하는 전역 상태, 코드를 이해하기 어렵게 만드는 과도한 간접성, 프로그램의 전혀 무관한 부분의 동작에 영향을 주는 원격 작용 등
- 이런 모호성을 줄이려면 명확한 계약과 표준 패턴을 적용해 API를 설계해야 함
- 관성은 소프트웨어를 계속 사용하려는 경향을 의미. 간단한 실험에 사용하고 난 뒤의 쉽게 없앨 수 있는 코드는 관성이 낮다고 볼 수 있으나 비즈니스에 요긴한 수십 가지 애플리케이션을 실행하는 서비스는 관성이 높다고 할 수 있음

<br>

### 진화하는 아키텍처를 위한 설계 원칙
-  미래에 발생할 요구사항을 알 수는 없으므로 엔지니어는 대체로 두가지 전략 중 하나를 선택하는 편인데 그러나 두 전략은 모두 복잡도를 증가시킬 뿐이므로 최대한 간단하게 구현해라
    - 나중에 어떤 필요가 발생할지 예측
    - 나중에 좀 더 쉽게 코드를 변경할 수 있는 추상화를 구현
- 코드를 간결하게 유지하면 나중에 필요성이 대두되고 변경이 불가피해질 때 복잡도를 추가할 수 있음. 코드를 간결하게 유지하는 가장 쉬운 방법은 모든 것을 한번에 작성하지 않는 것

<br>

### YAGNI 원칙 : 당장 필요하지 않다면 구현하지 말것
- YAGNI는 당장 필요하지 않다면 구현하지 말라는 매우 간단한 설계 원칙. 일반적으로 개발자가 코드에 대한 의욕이 넘치거나 집착하거나 우려가 있는 경우에 해당 원칙을 위반
- 미리 예측은 어렵고 잘못 예측하게 되면 노력이 허사가 되며 코드는 계속 수렁에 빠짐. 코드는 유지보수도 필요하고 개발자도 그 코드를 이해해야 하며 반드시 제대로 필드하고 테스트해야함
- 최소 기능 제품에 필요하지 않은 제품 기능, 불필요하게 유연한 추상화, 너무 이른 최적화 등을 피하면 됨
- 뇌무 이른 최적화는 코드의 필요성을 증명하기도 전에 성능 최적화를 수행하는 것을 말함. 코드가 배포되고 나서야 최적화가 필요치 않았던 사실을 발견할 수도 있음
- 개발자들은 플러그인 아키텍처, 래퍼 인터페이스, 키-값 쌍으로 표현하는 포괄적인 데이터 구조 같은 유연한 추상화에도 끌리는 경향이 있는데 추상화를 통해 새로운 요구사항을 쉽게 처리할 수 있을 것이라고 생각하지만 추상화에는 비용이 따름
- 코드의 유연성을 유지하는 가장 좋은 방법은 코드의 양을 최대한 줄이는 것으로 필요한게 무엇인지 스스로 물어보고 필요없는 것들은 과감히 버리자 (먼칭 기법)
- 물론 개발자는 경험이 쌓일 수록 언제 유연성과 최적화가 필요한지 더 잘 예측할 수 있으므로 그전 까지는 최적화가 필요할 것 같은 곳에 인터페이스 심을 추가하되 실제로 구현하지는 말자

<br>

### 최소 충격 원칙 : 사용자를 놀래키지 말것
- 최소 충격 원칙은 매우 명확한데 사용자를 놀라게 하지 말라는 것
- 우리가 구현하는 기능은 사용자가 처음 예상한 방식대로 동작해야 함. 학습 곡선이 높아 배우기 어렵거나 이상하게 동작하는 기능은 오히려 사용자를 불안하게 만듬
- 따라서 구체적인 코드를 작성하고 암묵적 요소를 제거하며 표준 라이브러리와 패턴을 사용해야 함
    - 암묵적 요소 : 개발자가 API를 사용하기 위해 알아야 하는 것으로서 명확하게 표현되지 않으면서 API에도 포함되지 않는 부분
    - 암묵적 요소를 포함하는 API는 개발자의 예상을 빗나가게 되며 버그를 유발할 뿐만 아니라 학습 곡선이 높아짐
    - 가장 보편적인 암묵적 요소는 호출 순서 요구사항이나 인수 상세 내용을 제공하지 않는 것
- 호출 순서 요구사항이란 어떤 작업을 순서대로 수행해야 하는 경우를 일컫음. 그 중에서도 메소드의 호출 순서가 갖아 빈번하게 문제가 됨
- 호출 순서를 문서화하는 것도 좋지만 호출 순서에 의존하지 않게 하는 편이 더 나으며 메소드가 서브 메서드를 호출하게 해 메소드 호출 순서 문제를 피할 수 있음
- 호출 순서 문제를 피하는 또다른 방법으로는 빌더 패턴을 이용해서 
- 감춰진 인수 요구사항은 메소드 시그니처가 실제로 필요한 것보다 더 넓은 범위의 입력값을 내포할 때 발생
- 마지막으로 표준 라이브러리와 개발 패턴을 사용하자. 개발 패턴 역시 마찬가지로 관용적인 코딩 스타일과 개발 패턴을 사용하자

<br>

### 도메인 지식은 캡슐화돼야 한다
- 소프트웨어는 비즈니스 요구사항에 따라 계속 변화하므로 회계, 청구, 배송 등 비즈니스 도메인을 기준으로 소프트웨어를 그룹화해서 도메인 지식을 캡슐화 해야 함
- 도메인의 캡슐화는 본질적으로 높은 응집도와 낮은 결합도를 지향
- 응집도가 높은 소프트웨어의 결합도가 낮아지게 되면 변경 사항의 ‘영향 반경’이 줄어드므로 좀 더 진화하는 코드를 작성할 수 있음
- 도메인 경계를 정의하고 도메인 관련 지식을 캡슐화하는 것은 좋으며 비즈니스 개념을 소프트웨어에 연결하기 위한 방대한 개념과 기법을 정의하는 도메인 주도 설계(DDD) 아키텍처 기법이 있고 해당 기법은 가장 복잡한 상황에서만 필요

<br>

### 진화하는 API를 위한 설계 원칙
- 요구사항이 변경되면 코드가 공유하는 인터페이스인 API를 변경해야 하는데 API 변경은 쉽지만 올바르게 변경하는 것은 쉽지 않음. 작고 합리적인 변경사항도 많이 만들다 보면 혼잡해질 수 있고 API 소소한 변경으로 인해 호환성이 완전히 무너지기도 함
- 크기를 작게 유지하고 명확하게 정의하며 버전을 도입하면 훨씬 더 쉽게 사용하고 진화시킬 수 있는 API를 구현할 수 있음

<br>

### API는 작게 유지해라
- API를 작게 만들면 이해하고 개선하기 쉬움
- API도 YAGNI 원칙을 적용하고 필드가 많은 API 메소드는 반드시 적절한 기본값을 가져야 함

<br>

### 잘 정의한 서비스 API를 노출하자
- 진화하는 시스템에는 버전은 물론 호환성 규약을 명시한 요청과 응답 스키마가 명확히 정의되어 있음
    - 스키마의 정의는 클라이언트와 서버 코드를 모두 자동으로 테스트할 수 있도록 공개되어야 함
- 서비스 API를 정의할 때는 표준 도구를 사용하여 스키마, 요청 및 응답 메소드, 예외에 대한 명세를 제공
- REST가 아닌 서비스는 인터페이스 정의 언어(IDL)를 주로 사용하며 서비스 API를 잘 정의해 두면 컴파일 타임 유효성 검사가 쉬워지며 클라이언트 ,서버, 문서의 일관성도 확보할 수 있음
- 인터페이스를 정의하는 도구는 주로 서비스 정의를 클라이언트와 서버 코드로 변환하는 코드 생성기를 제공하며 문서도 자동 생성이 가능하고 테스트 도구는 IDL을 이용해 스텁 및 모의 데이터를 생성
- 심지어 일부 도구에서는 서비스를 발견하고 누가 유지보수하는 지를 알아내서 서비스를 어떻게 사용하는지까지 보여주는 검색 용이성 기능도 제공
- 회사에서 이미 오픈 API를 사용한다면 최선의 선택. 오픈 API는 기존 REST 서비스에 적합하며 도입할 때도 대규모 마이그레이션이 필요하지 않기 때문

<br>

### API 변경에는 호환성을 유지하자
- API 변경에 호환성을 유지하면 클라이언트 버전과 서버 버전을 독립적으로 관리할 수 있음. 호환성은 상위 호환성과 하위 호환성으로 나뉨
- 변경사항이 상위 호환성을 가지면 클라이언트는 새로운 버전의 API를 이용해 이전 버전의 서비스도 호출할 수 있음
- 변경사항이 하위 호환성을 가지면 반대의 경우로 새로운 버전의 라이브러리나 서비스를 사용하기 위해 기존의 클라이언트 코드를 변경할 필요가 없음
- 변경사항이 기존 필드 변수가 변경되어 영향을 끼치는 것은 좋지 않음

<br>

### API 버전을 관리
- 시간이 지나면서 API가 진화하면 여러 버전의 호환성을 처리할 방법을 결정해야 함
- API가 상위 호환성과 하위 호환성을 완전히 제공한다면 기존 모든 버전은 물론 미래의 API 버전과도 상호 운용이 가능하지만 이후 코드의 유지보수가 어렵고 이제는 지원하지 않는 필드도 처리해야 하는 로직 같은 불편한 상황이 생김
- 결국 우리는 새로운 필수 필드를 추가하는 등 API를 기존 클라이언트와 호환되지 않는 방법으로 변경하길 원하게 되며 API 버전을 관리한다는 것은 변경이 만들어질 때마다 새로운 버전을 출시한다는 것을 의미
- 기존 클라이언트는 계속 기존 버전의 API를 사용할 수 있고 버전 추적이 가능하면 고객과의 소통에도 도움이 됨
    - API 버전 제어는 비용이 수반됨. 기존의 주 버전을 실행하는 서비스를 항시 유지보수해야 하며 버그 수정 역시 기존 버전으로 확대 적용해야 함. 개발자는 어떤 버전이 어떤 기능을 지원하는지도 추적해야 한다
    - 버전 제어도구가 없다면 버전 제어를 엔지니어가 직접 담당해야 할 수도 있음
- 버저닝 방법은 실용적이여야 하고 API는 물론 문서도 버전 제어를 해야 함

<br>

### 진화하는 데이터를 위한 설계 원칙
- API는 영구적인 데이터에 비하면 수명이 짧은 편. 클라이언트와 서버 API가 업그레이드 되면 업무는 종료되지만 데이터는 애플리케이션의 변화에 따라 반드시 진화해야 함
- 데이터 진화란 컬럼을 추가하거나 삭제하는 간단한 스키마 변경부터 새로운 스키마로 레코드를 새로 작성하는 작업, 손상된 데이터의 복구, 새로운 비즈니스 로직을 위한 재작성, 다른 데이터베이스로의 마이그레이션 등까지 모두를 포함함
- 데이터베이스를 격리하고 명시적인 스키마를 사용하면 데이터의 진화를 더 잘 관리할 수 있고 데이터베이스를 격리하면 우리가 관리하는 애플리케이션 변화에 따른 영향도만 살피면 됨
- 스키마는 잘못된 데이터를 읽고 쓰는 경우로부터 애플리케이션을 보호하며 스키마 마이그레이션을 자동화하면 더욱 예측 가능한 방법으로 스키마를 변경할 수 있음

<br>

### 데이터베이스를 격리하자
- 공유 데이터베이스는 진화가 어려우며 자율성을 잃는 결과를 야기할 수 있음
- 자율성이란 개발자나 팀이 독립적으로 시스템을 변경할 수 있는 능력을 말함
- 스키마가 너무 견고해진 비공식적 API가 되버리면 점차 아키텍처는 취약해지고 아키텍처적인 성장을 이룰 수 없음. 하지만 애플리케이션 데이터베이스를 분리하면 좀 더 쉽게 변경할 수 있다
    - 공유 데이터베이스는 둘 이상의 애플리케이션이 접근하는 반면 격리된 데이터베이스는 하나의 애플리케이션만 접근함
- 공유 데이터베이스는 여러 문제점이 있음
    - 서로 데이터베이스를 공유하는 애플리케이션들은 상대편 애플리케이션의 데이터에 직접 의존하는 형태가 될 수 있음
    - 애플리케이션 스키마 변경은 다른 애플리케이션에도 영향을 주고 성능도 격리되지 않아 한 애플리케이션이 데이터베이스에 부하를 걸면 다른 애플리케이션도 영향을 받음. 경우에 따라서는 보안 경계를 위반하기도 함
- 반면 데이터베이스를 격리하면 단 하나의 애플리케이션만 데이터를 읽고 쓴다. 그 외의 다른 트래픽은 모두 원격 프로시저 호출을 통해 이뤄짐
- 데이터 베이스를 격리하면 공유 데이터베이스가 제공하지 못하는 유연성을 갖출 수 있고 데이터베이스 스키마를 변경할 때도 관련된 애플리케이션만 신경쓰면 되며 데이터 베이스 성능도 애플리케이션이 데이터베이스를 사용하는 방법에 의해 좌우됨
- 그럼에도 공유 데이터베이스가 필요한 경우도 가끔있음
    - 모놀리스 애플리케이션을 분리할 때 새로운 전용 데이터베이스로 마이그레이션하기 전까지 공유 데이터베이스 유용하게 활용 가능
    - 여러 데이터베이스를 관리하는 데는 비용이 따르고 초기에는 하나의 머신에서 서비스하는 것도 좋지만 궁극적으로 공유 데이터베이스는 별개의 전용 데이터베이스로 나누거나 대체해야 함

<br>

### 스키마를 사용하자
- 컬럼과 타입이 엄격하게 정해져 있고 이를 개선하기 위한 프로세스는 어렵다는 사실로 인해 스키마 없는 데이터 관리라는 기법이 나타나 유행하게되었음
    - 최신 데이터스토어는 미리 정해둔 구조가 없어도 JSON이나 유사한 객체를 저장하는 기능을 제공하는데 여기서 스키마가 없다는 것은 스키마가 아예 존재하지 않는다 라는 것을 의미하는 것은 아니며 스키마 없는 데이터란 읽기 시점에 제공하거나 유추하는 암묵적인 스키마를 가지고 있다는 뜻임
- 현실적으로 스키마 없는 방식은 상당한 무결성 및 복잡도 문제를 지니고 있음이 드러났음
    - 강력한 타입을 사용하는 스키마 지향 방식은 모호성을 줄여서 애플리케이션의 복잡도를 낮춤
    - 단기간적으로 간결성을 확보할 수 있다고 해서 모호성이라는 트레이드오프를 감수하는 것은 좋은 방법이 아님
    - 코드와 마찬가지로 데이터 역시 한번 기록, 여러번 읽기로 설명할 수 있으며 스키마를 사용하면 읽기 작업은 더 수월해 짐
- 스키마가 없으면 변경을 만들기 쉽다고 생각할 수 있으나 오히려 어려움. 데이터를 개선하면서 어떤 부분에 문제가 생길지 알 수 없기 때문
- 데이터의 스키마를 명시적으로 지정하면 애플리케이션의 안정성과 데이터의 유용성을 유지하는데 도움이 됨
    - 명시적 스키마를 사용하면 데이터를 기록하는 시점에 그 무결성을 검사할 수 있음
    - 게다가 데이터의 파싱 역시 훨씬 빠르게 수행이 가능
    - 상위 및 하위 비호환성을 유발하는 변경사항도 감지할 수 있음
- 명시적 스키마의 엄격함에도 비용은 따르며 변경이 어렵지만 설계상 어쩔 수 없음. 

<br>

### 스키마 마이그레이션을 자동화하자
- 데이터베이스의 스키마를 변경하는 것은 위험
- 약간의 수정도 전체 데이터베이스나 애플리케이션을 다운시킬 수 있기 때문
- 데이터베이스 서술 언어(DDL) 명령어를 이용해 데이터베이스를 변경하면 실수하기도 쉬움
- 데이터베이스 스키마는 환경마다 조금씩 다를 수 있고 데이터베이스 상태도 불확실 하며 누가 무엇을 언제 바꿨는지도 알수 없으며 성능에 대한 영향도 불분명함
- 데이터베이스 스키마 관리 도구를 이용하면 데이터베이스를 더 안전하게 변경이 가능
    - 스키마의 전체 히스토리를 추적할 수 있는 기능 제공
    - 스키마를 한 버전에서 다른 버전으로 마이그레이션하는 기능 제공
    - 리퀴베이스, 플라이웨이, 알럼빅 같은 도구도 있음
    - 객체리소스 매퍼(ORM)도 스키마 마이그레이션 관리자를 제공함
- 조금 더 정교한 데이터베이스 운영 도구로는 다음과 같음
    - 깃허브의 gs-ost
    - 퍼코나의 pt-online-schema-change
    - 스키마와 스퀘어의 시프트 같은 도구
- 대부분의 마이그레이션 도구는 마이그레이션의 변경사항을 되돌리는 롤백을 지원
- 스키마 변경은 영구적이며 규모가 크기 때문에 조직은 일반적으로 이런 변경을 올바르게 수행하기 위해 DBA, 운영 또는 SRE, 도구에 익숙해야하고 성능의 영향과 애플리케이션을 이해하는 시니어 엔지니어 등으로 별도의 팀을 구성한다

<br>

### 스키마 호환성을 유지하자
- 디스크에 기록된 데이터에는 API와 동일한 호환성 문제가 있음. API와 마찬가지로 데이터를 읽고 쓰는 쪽이 독립적으로 변경될 수 있기 때문
- 또한 API 처럼 데이터 또한 필드 이름과 타입 등 스키마를 가짐. 스키마 호환성 검사를 이용해 변경의 호환성을 확인하고 데이터 제품을 이용해 내부 및 외부 스키마를 분리
- 개발자는 데이터베이스를 다른 시스템으로부터 숨겨야할 구현 상세라고 생각하고 완전히 캡슐화하는 것이 이상적이지만 현실로는 거의 없고 데이터는 데이터 웨어하우스로 보내지는 경우도 많음
- 데이터 웨어하우스는 분석과 보고서를 목적으로 사용하는 데이터베이스로 조직은 데이터베이스로부터 데이터를 추출하고 변형해서 데이터 웨어하우스로 추출, 변형, 적재 데이터 파이프라인을 셋업하기도 함
- 다른 시스템도 우리의 데이터베이스 스키마에 의존하고 있을지 모름. 변경 데이터 수집(CDC)란 삽입, 갱신, 삭제 작업을 다운스트림 컨슈머를 위한 메시지로 변환하는 이벤트 기반 아키텍처임
- 데이터 웨어하우스 파이프라인과 다운스트림 사용자는 비호환적인 스키마 변경으로부터 반드시 보호돼어야 한다. 스키마 변경을 프로덕션 환경에서 실행하기 전에 안전한지 여부를 먼저 검증하자
- 내부 스키마는 다운스트림 사용자로부터 내부 스키마를 명확히 분리하는 데이터제품을 내보내는 방법으로 보호할 수 있음
- 데이터베이스 뷰 등을 이용해 데이터 제품을 분리하면 팀이 데이터 컨슈머와의 호환성을 유지하면서도 내부 데이터베이스 스키마를 계속 변경할 수 있음

<br>

### 느낀점
- 변경에 막히지 않도록 추상화를 하는 것으로 알고 있었는데 지나친 추상화는 좋지 않고 적절함을 유지하는 것이 중요
    - 처음 요구사항에 맞게 작게작게 불필요한 것을 없애고 다른 사람들이 이해하기 쉽게 해라
    - 버저닝은 저번이랑 동일한 느낌
- 스키마가 없는 데이터는 애플리케이션에서 유효확인을 하면 되니 충분히 좋은 방법이라고 생각했는데 역시 모두 좋을 수는 없다고 생각
- 데이터베이스 격리가 쓰기 역할을 하는 데이터베이스를 하나만 둔다는 의미인가..?
    - 모놀리스 방식만 사용해서 잘 모르겠음..
- DDD 말고 다른 외 아키텍처 기법은 사용해본적없어 모르겠음
- 스키마 마이그레이션이 뭐지..? 해당 부분은 거의 모르겠으나 데이터베이스 담당 팀이 담당해서 다른 분들도 잘 모르는 것 같음
- 다른 팀이 있을 때 데이터베이스를 적용하는 방법에 대해 궁금하고 아직 감이 잘 안잡힘

<br>

### 회의를 통해
- 뻔히 보이면 미리 구현하게 되는데 실질적으로 사용되지 않은 경우도 많고 소스가 복잡해지는 경우가 생김
- 데이터베이스 스키마의 경우 주로 데이터베이스 관리팀이 모두 맡아 건드릴 상황이 나오지 않음
- 레스트독스를 통해 명세서를 제공하는 것을 추천
- 트랜잭션 등에 대해 아직도 RDMS가 좋고 JSON은 확장성이 좋고 상황에 따라 다르다고 생각
- 추상화가 지나치게 사용하면 소스를 찾기 어려움. (모호성이 커짐) 파악하기 쉬운 적절한 수준이 중요하다고 생각