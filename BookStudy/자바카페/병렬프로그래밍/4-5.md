# 2 Week (4 ~ 5 챕터)

## 4. 객체 구성
### 1. 스레드 안전한 클래스 설계
- public static 변수에 저장해도 스레드 동기화 프로그램을 작성할 수 있으나 구조적인 캡슐화 없이 만들어낸 결과물은 여러 스레드에서 사용해도 안전한지 확인하기 어렵고 이후 변경에 있어 동기화 문제를 지속적으로 신경써야함
- 객체가 가지고 있는 여러 가지 정보를 해당 객체 내부에 숨겨두면 전체 프로그램을 뒤져볼필요 없이 객체 단위로 스레드 안전성이 확보되어 있는지 확인할 수 있음

```
스레드 안전한 클래스를 설계할 때 3가지 고려요소
- 객체의 상태를 보관하는 변수가 어떤 것인가?
- 객체의 상태를 보관하는 변수가 가질 수 있는 값이 어떤 종류, 어떤 범위에 해당하는가?
- 객체 내부의 값을 동시에 사용하고자 할 때, 그 과정을 관리할 수 있는 정책
```

<br>

- 객체의 상태는 항상 객체 내부의 변수를 기반으로 함
- 객체 내부의 다른 객체를 가르키는 객체가 있을 경우 해당 객체도 상태 범위에 포함시켜야 함
- 객체 내부의 여러 변수가 갖고 있는 현재 상태를 사용하고자 할 때 값이 계속해서 변하는 상황에서도 값을 안전하게 사용할 수 있도록 조절하는 방법을 동기화 정책이라고 함
    - 동기화 정책에는 객체의 불변성, 스레드 한정, 락 등을 어떻게 적절하게 활용해 스레드 안전성을 확보하며 어떻게 활용하는지 명시
    - 클래스를 유지보수하기 좋게 관리하려면 해당 객체에 대한 동기화 정책을 항상 문서로 작성해두어야 함

- [자바 동기화 synchronzied 정리](https://github.com/InJun2/TIL/blob/main/Stack/Java/Synchronized.md)

<br>

#### 동기화 요구사항 정리
- 객체와 변수를 놓고 봤을 때 객체와 변수가 가질 수 있는 가능한 값의 범위를 생각할 수 있는데 이런 값의 범위를 상태 범위(state space)라고 함
- 클래스 내부의 상태나 상태 변화에 있어 여러가지 제약 조건이 있을 수 있는데 이런 제약 조건에 따라 또 다른 동기화 기법이나 캡슐화 방법을 사용해야 할 수도 있음
- 특정한 연산을 실행했을 때 올바르지 않은 상태 값을 가질 가능성이 있다면 해당 연산은 단일 연산으로 구현해야함
    - 서로 연관된 값은 단일 연산으로 한번에 읽거나 변경해야 함
    - 만약 두개의 변수가 있고 하나의 값을 변경하고 락을 해제하고 락을 확보하고 다른 값을 변경한다면 올바르지 않은 상태가 될 수 있음
- 상태 범위에 두 개 이상의 변수가 연결되어 동시에 관여하고 있다면 이런 변수를 사용하는 모든 부분에서 락을 사용해 동기화를 맞춰야 함
- 객체가 가질 수 있는 값의 범위와 변동 폭을 정확하게 인식하고 스레드 안전성을 완벽하게 확보해야함

<br>

#### 상태 의존 연산
- 상태를 기반으로 선행조건(precondition)을 갖기도 하는데 예를 들면 비어있는 큐에서는 값을 뽑아낼 수 없음
- 이처럼 현재 조건에 따라 동작 여부가 결정되는 연산을 상태 의존(state-dependent) 연산이라고 함

<br>

#### 상태 소유권
- 객체의 상태를 정의하고자 할 때, 객체가 실제로 소유하는 데이터만 기준으로 잡아야함
- 소유권이라는 개념은 자바 언어 자체에 내장되어 있지는 않지만 클래스를 설계할 때 충분히 고려할 수 있는 요소
- 대부분의 경우 소유권과 캡슐화 정책은 함께 고려하는 경우가 많음. 캡슐화 정책은 내부에 객체와 함께 상태 정보를 숨기기 때문에 객체의 상태에 대한 소유권이 있음
- 특정 변수에 대한 소유권을 가지고 있기 때문에 락 구조가 어떻게 동작하는지도 소유권을 가짐
- 컬렉션 클래스에서는 소유권 분리의 형태를 사용하는 경우도 많음
    - 소유권 분리는 컬렉션 클래스를 놓고 볼때 컬렉션 내부의 구조에 대한 소유권은 컬렉션 클래스가 갖고, 컬렉션에 추가되어 있는 객체에 대한 소유권은 컬렉션을 호출해 사용하는 클라이언트 프로그램이 갖는 구조
    - 서블릿 프레임워크에서 볼 수 있는 ServletContext 클래스가 대표적인 예로 ServletContext는 Map과 비슷한 구조로 만들어져 있고 객체를 불러다 쓰는 프로그램은 setAttribute 메서드와 getAttribute 메서드를 통하여 추가되어 있는 객체를 사용

```java
@WebServlet("/hello")
public class HelloServlet extends HttpServlet {

    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        // ServletContext 객체 가져오기
        ServletContext servletContext = getServletContext();

        // ServletContext에서 객체 가져오기
        String message = (String) servletContext.getAttribute("message");

        // 클라이언트에게 메시지 보내기
        response.setContentType("text/html");
        response.getWriter().println("<h1>" + message + "</h1>");

        // 객체 자체의 소유권은 ServletContext가 가지고 있지만 해당 객체 내부의 message에 있어 소유권은 메시지를 조작할 수 있는 클라이언트가 가지고 있음
    }
}
```

<br>

### 2. 인스턴스 한정
- 객체를 적절하게 캡슐화하는 것으로도 스레드 안전성을 확보할 수 있는데 '인스턴스 한정' 기법을 사용하는 셈
- 특정 객체가 다른 객체 내부에 완벽하게 숨겨져 있다면 훨씬 간편하게 스레드 안전성을 분석해볼 수 있음
    - 데이터 객체 내부에 숨겨두면 해당 내용은 해당 객체의 메서드에서만 사용할 수 있어 항상 지정된 형태의 락이 적용되는지 쉽게 확인할 수 있음
- 인스턴스 한정 기법을 사용하면 클래스 내부의 여러가지 데이터를 여러 개의 락을 사용해 따로 동기화 시킬 수 있음
- 자바 플랫폼 라이브러리에는 이런 클래스를 멀티스레드 환경에서 안전하게 사용할 수 있도록 Collections.synchronizedList 같은 팩토리 메소드가 만들어져 있음
    - 대부분 데코레이터 패턴을 활용하여 래퍼 클래스는 호출하는 연동 역할만 하면서 동시에 모든 메서드가 동기화 되어 있음
- 한정되어야 할 객체를 공개하면 객체가 특정 코드 범위에 한정됬어야 하는데 해당 코드 범위를 넘어 유출된 경우는 버그이며 반복 객체나 내부 클래스 인스턴스를 사용하면서 공개한다면 한정됬어야 할 객체를 간접적으로 외부에 유출시킬 가능성이 있음 

<br>

```java
@ThreadSafe
public class PersonSet {
    @GuardedBy("this")
    private final Set<Person> mySet = new HashSet<Person>();

    public synchronzied void addPerson(Person p) {
        mySet.add(p);
    }

    public synchronzied boolean containsPerson(Person p) {
        return mySet.contains(p);
    }
    
    // Person 클래스는 HashSet 클래스에 보관되어 있고 HashSet 자체는 스레드 안전한 객체가 아님
    // 하지만 private로 지정되어 있어 직접적으로 외부에 유출되지 않아 해당 변수를 사용하는 방법은 addPerson과 containsPerson 뿐임
    // 해당 메서드들에 동기화를 적용하여 스레드 안전성을 확보했음
}

```

<br>

#### 자바 모니터 패턴
- 인스턴스 한정 기법에 대한 원리와 내용은 결국 자바 모니터 패턴에 해당함
- 변경 가능한 데이터를 모두 객체 내부에 숨긴 다음 객체의 암묵적 락으로 데이터에 대한 동시 접근을 막는 것을 모니터 패턴이라고 함
- 만약 락이 외부에 공개되어 있다면 다른 객체도 해당하는 락을 활용해 동기화 작업에 함께 참여할 수 있음. 올바르지 않게 참여하면 큰 문제가 됨
- 외부에서 변경 가능한 데이터를 요청할 경우 그에 대한 복사본을 넘겨주는 방법을 사용하면 스레드 안정성을 부분적이나마 확보할 수 있음
    - 만약 차량 위치 정보를 가져오는 get메서드와 차량 위치 정보를 업데잍하는 set메서드를 구현했을 경우 외부에 차량 위치 정보를 복사본으로 주면 값이 변경이 가능하지만 실제 차량 위치가 변경되었을 때 외부에서 가져간 위치 정보는 바뀌지 않음
    - 위의 경우처럼 시시각각으로 상태를 확인한다면 알고싶은 시점마다 매번 복사본을 만들어야 하므로 성능에 문제가 있을 수 있음

<br>

### 3. 스레드 안전성 위임
- 클래스를 구현할 때 새로 만들거나 이미 만들어져있지만 스레드 안전성이 없는 객체를 조합해 만들 경우 스레드 안전성을 확보하고자 한다면 자바모니터 패턴을 유용하게 사용할 수 있음
- 조합하고자 하는 클래스가 이미 스레드 안전성을 확보하고 있고 해당 클래스로 스레드 안전성을 확보하려면 동기화 과정을 거쳐야할 수도 있고 아닐 수도 있음
- A 클래스는 스레드 안전히며 B 클래스는 A클래스를 사용하여 다른 제한 조건이 없을 경우 B클래스 또한 스레드 안전하며 해당 경우 스레드 안전성 문제를 A 클래스에게 '위임(delegate)'한다고 함

<br>

```java
// 111p 예제
@Immutable
public class Point {    // 불변인 클래스로 외부에 공개할 수 있어 객체 인스턴스를 복사해줄 필요가 없음
    public final int x, y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y; 
    }
}

@ThreadSafe
public class DelegatingVehicleTracker {
    private final ConcurrentMap<String, Point> locations;   // 모든 동기화 작업은 ConcurrentMap에서 담당
    private final Map<String, Point> unmodifiableMap;   // Map에 들어있는 모든 값은 불변

    public DelegatingVehicleTracker(Map<String, Point> points) {
        locations = new ConcurrentHashMap<String, Point>(points);
        unmodifiableMap = Collections.unmodifiableMap(locations);
    }

    public Map<String, Point> getLocations() {
        return unmodifiableMap;
    }

    public Point getLocation(String id) {
        return locations.get(id);
    }

    public void setLocation(String id, int x, int y) {
        if (locations.replace(id, new Point(x, y)) == null) 
            throw new IllegalArgumentException("invalid vehicle name: " + id);
    }
}
// ConcurrentHashMap은 자바에서 제공하는 인터페이스로 내부적으로 동기화 매커니즘을 사용해 스레드 안전함
// Collections.unmodifiableMap를 사용하여 원본 객체를 래핑하여 맵을 변경할 수 없는 불변 객체로 생성
```

<br>

### 독립 상태 변수
- 스레드 안전한 내부 변수가 두개 이상이라도 해당 변수끼리 독립적이라면 변수가 서로의 상태값에 연관성성이 없어 스레드 안전성을 위임할 수 있음
- 