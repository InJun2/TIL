# 1 Week (1 ~ 3 챕터)


## 1 Chapter 개요
- 여러 작업을 동시에 실행하는 프로그램을 제대로 돌아가게 작성하기는 매우 어려움. 여러 작업을 동시에 하는 프로그램은  순차적으로 실행하는 프로그램보다 오류 발생 가능성이 높음
- 그럼에도 동시에 실행하는 문제에 신경쓰는 이유는 스레드는 자바 언어에서 피할 수 없는 특징이고 복잡한 비동기 코드를 더 단순한 순차적 코드로 바꿔 복잡한 시스템을 단순하게 개발할 수 있게 해주기 때문
- 또한 프로세서 개수가 늘어날수록 여러 작업을 동시에 실행하는 일이 더욱 중요

<br>

### 1. 작업을 동시에 실행하는 일에 대한 간략한 역사
- 초창기에는 컴퓨터에 운영체제가 없었고 모든 자원을 직접 접근할 수 있었으나 운영체제 없이 하드웨어 위에서 바로 실행되는 프로그램은 작성하기 어렵고 한 번에 하나의 프로그램만 실행하여 컴퓨터 자원을 드문드문 사용하여 자원 대비 성능이 비효율적
- 현재의 운영체제는 프로세스 마다 독립된 채로 실행되어 프로세스마다 메모리, 파일 핸들, 보안 권한 등의 자원을 할당하고 프로세스마다 서로 통신을 할 수도 있음
- 여러 프로그램을 동시에 실행할 수 있는 운영체제를 개발한 요인은 다음과 같음
```
자원 활용
- 프로그램은 때로 입출력과 같이 외부 작업이 끝나기를 기다려야 하는 경우가 많은데 기다리는 동안은 유용한 일을 처리하지 못했음
- 하나의 프로그램이 기다리는 동안 다른 프로그램을 실행하도록 지원하는 것이 더 효율적

공정성
- 여러 사용자와 프로그램이 컴퓨터 내 자원에 대해 동일한 권한을 가질 수 있음
- 한 번에 프로그램 하나를 끝까지 실행해 종료된 이후에야 다른 프로그램을 시작하는 것보다 더 작은 단위로 컴퓨터를 공유하는 방법이 바람직

편의성
- 때론 여러 작업을 전부 처리하는 프로그램 하나를 작성하는 것보다 각기 일을 하나씩 처리하고 필요할 때 프로그램 간에 조율하는 프로그램을 여러 개 작성하는 편이 더 쉽고 바람직
```

<br>

#### 작업을 동시에 작업하게된 동기

- 초기 시분할 시스템에서는 각 프로세스가 가상적인 폰 노이만 컴퓨터였고 각각 명령어와 데이터를 저장하는 메모리 공간을 가지고 기계어로 된 명령어를 순차적으로 수행하며 운영체제가 제공하는 I/O 수단을 통해 컴퓨터 외부와 교류했음
- 각 명령어 마다 다음 명령이 정의되어 있었고 명령어 집합의 규칙에 따라 실행 흐름이 제어됬는데 현재 널리 사용되는 대부분의 프로그래밍 언어가 이러한 순차적 프로그래밍 방식을 따름
- 순차적 프로그래밍 모델은 사람이 생각하는 방식과 같게 직관적이고 자연스럽게 대부분의 경우 한 번에 한가지씩 순서대로 처리함.
- 사람의 경우도 순차적으로 실행하는 도중 토스트를 준비하거나 주전자에 물을 끓이는 등의 행동을 하고 그 동안 비동기적으로 할 일을 수행하여 적절히 균형을 찾아냄
- 이와 같이 자원 활용, 공정성, 편의성 등 프로세스 개념을 만들어낸 것과 같은 동기를 가지고 스레드가 고안되었음. 스레드로 인해 한 프로세스 안에 여러 개의 프로그램 제어 흐름이 공존이 가능해 졌음

<br>

### 2. 스레드의 이점
- 스레드를 제대로만 사용하면 개발 및 유지 보수 비용을 줄이고 애플리 케이션의 성능을 향상 시킬 수 있음
- 또한 비동기적인 일 흐름을 거의 순차적으로 바꿀 수 있어 사람이 일하고 상호 작용을 하는 방식을 모델링하기 쉬워짐
- 스레드는 GUI 애플리케이션에서 사용자 인터페이스가 더 빨리 반응하게 만들기도 하고, 서버 애플리 케이션에서 자원 활용도와 처리율을 높이는데 유용
    - 스레드는 JVM을 더 단순하게 구현할 수 있도록 도와주기도 함. 가비지 컬렉터는 보통 하나 또는 두 개 이상의 전용 스레드에서 실행됨
    - 아주 단순한 자바 프로그램이 아니라면 여러 개의 스레드를 사용함

<br>

#### 멀티프로세서 활용

- 예전 멀티 프로세서 시스템은 비싸고 드물어서 쉽게 보지 못하지만 요즘은 싸고 흔해져서 멀티 프로세서 환경이 흔함
- 클럭 주파수를 올리는 일이 점점 힘들어지면서 프로세서 제저 업체는 칩 하나에 더 많은 프로세서 코어를 넣으려 하고 있으며 현재 이미 컴퓨터는 많은 프로세서를 탑재하고 있음
- 프로세서 스케줄링의 기본 단위는 스레드 이므로 스레드 하나로 동작하는 프로그램은 한 번에 하나의 프로세서만 사용하므로 프로세서가 여러개인데 하나의 스레드만 처리할 수 있다면 자원을 낭비하는 것
- 또한 프로세서가 하나로 해도 여러 개의 스레드를 사용하면 동기 I/O 작업동안 다른 스레드가 작업이 가능해 처리 속도를 높일 수 있음

<br>

#### 단순한 모델링
- 여러 종류의 일을 하나의 프로그램에서 처리하는 것보다 한 종류의 작업을 여러개 처리하는 것이 처리에 있어서도 테스트나 유지보수에 있어서도 훨씬 쉬움
- 종류별 작업마다 또는 시뮬레이션 작업의 각 요소마다 스레드를 하나씩 할당하면 마치 순차적인 작업처럼 처리할 수 있음
- 또한 스케줄링, 교차 실행되는 작업, 비동기 I/O, 자원 대기 등의 세부적인 부분과 상위의 비즈니스 로직에 대한 부분을 분리할 수 있음
    - 즉, 스레드에서 수행되는 더 단순하고 동기적인 작업 흐름 몇개로 나눌 수 있음
- 이러한 장점은 서블릿이나 RMI(Remote Method Invocation)같은 프레임 워크에서 종종 활용 됨
    - 프레임 워크는 요청 관리, 스레드 생성, 로드 밸런싱, 작업 흐름내 적절한 시점에 컴포넌트에게 요청을 분배하는 등의 상세한 부분 처리
- 서블릿 개발자는 동시에 다른 요청이 얼마나 많이 처리되고 있는지, 소켓 입출력 스트림이 대기 상태에 들어갔는지에 대해서는 걱정할 필요가 없음
    - 웹 요청이 들어와서 서블릿의 service 메서드가 호출될 때 해당 요청을 마치 단일 스레드 프로그램인 것처럼 처리할 수 있어 컴포넌트 개발 작업이 훨씬 단순해짐

<br>

#### 단순한 비동기 이벤트 처리
- 여러 클라이언트 프로그램에서 소켓 연결을 받는 서버 애플리케이션의 경우 각 연결 마다 스레드를 할당하고 동기 I/O를 사용하도록 하면 개발 작업이 쉬워짐
- 읽을 데이터가 없을 때 소켓에서 애플리케이션은 추가 데이터가 들어올 때까지 read 연산에서 대기하는데 이때 스레드가 하나 뿐이라면 해당 요청에 대한 작업이 멈추는 것 만이 아니라 다른 모든 요청도 처리하지 못하고 멈춤
- 이런 경우를 피하려면 단일 스레드 서버 프로그램은 훨씬 복잡하고 실수하기 쉬운 넌블로킹 I/O 기능을 사용해야하지만 각 요청을 별개의 스레드에서 처리하면 대기 상태에 들어가도 다른 스레드가 요청을 처리하는데 영향을 끼치지 않음

<br>

#### 더 빨리 반응하는 사용자 인터페이스
- GUI 애플리케이션은 보통 스레드 하나로 동작하였으나 코드 전반에 걸쳐 사용자 입력을 계속 점검하거나 모든 애플리케이션 코드를 '메인 이벤트 루프'를 통해 간접적으로 실행하여야 했음
- 해당 경우 메인 이벤트 루프에서 직접 호출한 코드가 너무 오랫동안 실행되면 다음 이벤트를 처리할 수 없어 사용자 인터페이스가 멈춘 것 처럼 보임
- AWT나 스윙같은 GUI 프레임워크는 메인 이벤트 루프를 이벤트 전달 스레드(EDT)로 대체하여 사용자 인터페이스 이벤트가 발생하면 애플리케이션이 정의한 이벤트 핸들러가 이벤트 전달 스레드에서 호출됨
- 대부분의 GUI 프레임 워크는 단일 스레드로 움직이도록 구현되어 있어 메인 이벤트 루프가 여전히 남아있기는 하지만 별도의 스레드에서 애플리케이션이 아닌 GUI 툴킷 관할하에 실행됨

<br>

### 3. 스레드 사용의 위험성
- 자바 자체에 스레드 관련 기능이 내장되어 있는 것은 양날의 칼이라 할 수 있음
- 언어 및 라이브러리 측면에서 스레드 지원과 플랫폼 독립적으로 정형화된 메모리 모델 때문에 병렬 프로그래밍을 개발하는 것이 쉽긴 하지만 스레드를 사용해 작성하는 프로그램이 더 많아져 개발자에 대한 기대치도 높아졌음
    - 스레드가 소수만의 난해한 주제였을 때 병렬 문제는 고급 문제 였으나 현재는 개발자라면 대부분 스레드 안전성에 대해 필수 지식이 되었음

<br>

#### 안정성 위해 요소
- 스레드는 동기화를 충분히 해두지 않으면 여러 스레드에서 실행되는 연산의 순서를 예측하기 어려움
- 특정 변수를 ++ 하는 간단한 메서드도 두 스레드가 동시에 접근했다면 기존 값이 9라고 가정했을 때 A 스레드가 9를 읽고 10으로 바꾸려는 도중 B 스레드가 9를 읽어버려서 9 -> 10 -> 11이 되어야 하지만 B는 9에서 +1을 하여 결과적으로 10이 됨
- 해당 연산은 사실 값을 읽고, 값에 더하고, 그 값을 다시 저장하는 3개의 단일 연산으로 구성되어 있음
- 따라서 서로 다른 스레드가 각기 해당 메서드를 호출해도 양쪽이 같은 값을 얻을 수도 있음

<br>

#### 동기화
- 스레드는 서로 같은 메모리 주소 공간을 공유하고 동시에 실행되기 때문에 다른 스레드가 사용 중일지도 모르는 변수를 읽거나 수정할 수도 있음
- 스레드 통신보다 데이터 공유가 훨씬 쉽기 때문에 이러한 일이 발생하지만 데이터가 예측 못한 시점에 변경되 스레드가 혼동될 수 있고 원래 순차적이던 프로그래밍 모델에 비순차적인 요소가 들어가 동작 과정을 추론하기 어려워짐
- 멀티스레드 프로그램이 동작하는 모습을 예측하려면 스레드가 서로 간섭하지 않도록 공유된 변수에 접근하는 시점에 적절하게 조율해야 하는데 다행이 자바에서는 공유 변수 접근을 조율하기 위한 동기화 수단이 제공됨
    - synchronized, volatile 등
- 동기화를 진행하였다면 스레드 안전성을 문서화 하기 위해 @ThreadSafe 라고 표기하여 어노테이션으로 문서화하면 멀티스레드 환경에서 문제가 없다는 점을 명확히 알 수 있음

```java
@ThreadSafe
public class Sequence {
    @GuardedBy("this") private int value;

    public synchronized int getNext() {
        return value ++;
    }
}
```

<br>

#### 활동성 위험
- 동시 수행 코드를 개발할 때는 반드시 스레드 안전성 문제를 신경 써야 함
- 멀티 스레드 프로그램에서는 단일 스레드 프로그램에는 발생하지 않는 추가적인 안전성 위험에 노출되는 추가적인 형태의 활동성 장애가 생길 수 있음
- 활동성은 "원하는 일이 결국 일어난다"는 보완적인 목표지만 해당 목표를 수행하지 못함

<br>

#### 성능 위험
- 활동성과 함께 성능도 관련이 많음. 활동성은 일반적으로 좋은 일들은 빨리 일어나길 바라지만 결과는 별로 좋지 않을 수도 있음
- 성능 문제는 형편없는 서비스 시간, 반응성, 처리율, 자원 소모, 규모에 대한 확장성 등 넓은 범위의 문제들을 포괄
- 잘 설계된 병렬 프로그램은 궁극적으로 성능을 향상시킬 수 있지만 스레드가 많은 프로그램에서는 컨텍스트 스위칭으로 어느 정도 부하가 생기는 것도 사실이고 상담한 부담이 생김
- 해당 부담에 따라 실행중인 컨텍스트를 저장하고 다시 읽어들이고 메모리를 읽고 쓰는데 있어 지역성이 손실되고 CPU 시간을 스케줄링 하는데 소모해야 하며 스레드가 데이터를 공유할 때는 동기화 수단도 사용해야 하여 성능 측면에서 추가적인 손실을 유발할 수 있어 이러한 손실을 분석하고 최소화해야 한다
    - 11장에서 다룬다고 함

<br>

### 4. 스레드는 어디에나
- 프로그램을 작성할 때 스레드를 직접 생성하지 않더라도 프로그램이 사용하는 프레임워크에서 스레드를 생성할 수도 있음
- 그런 스레드에서 호출되는 코드는 스레드에 대해 안전해야 함. 스레드에 안전한 클래스를 개발할 때는 더 세심하게 주의하고 분석해야 하며 이런 면은 개발자 입장에서 설계와 구현 어느 부분에서도 상당한 부담이 됨
- 모든 자바 프로그램은 기본적으로 스레드를 사용함. 메소드를 실행할 주 스레드 뿐만 아니라 가비지 컬렉션이나 객체 종료와 같은 JVM 내부 작업을 담당할 스레드도 생성하고 AWT와 스윙 UI 프레임워크는 사용자 인터페이스 이벤트를 관리할 스레드를 생성하고 Timer는 대기 중인 작업을 실행할 스레드를 생성하며 서블릿이나 RMI 같은 컴포넌트 프레임워크 역시 스레드를 관리하는 풀을 여러 개 생성하고 이 스레드를 사용해 컴포넌트의 메소드를 호출함
- 많은 개발자가 이러한 편리한 수단을 사용한다면 병렬성과 스레드 안전성에 잘 알아야 함. 현실에서 거의 모든 자바 프로그램이 멀티 스레드로 동작하는 프로그램이고 외부에서 프로그램 내부의 상태에 접근하는 과정을 적절히 조율하지 않아도 될 만큼의 기본적인 조율 기능을 프레임 워크가 담당해 주지는 않음
- 그렇기 때문에 프레음 워크 때문이 아닌 병렬로 실행되는 사실을 프로그램에서도 인식하고 적절히 대응해야 한다. 게다가 컴포넌트의 기능을 호출해 결과를 받아오는 형태로 동작하면 필수적으로 프로그램 내부의 상태를 사용하므로 프레임 워크에 의해 호출되는 컴포넌트 뿐만 아니라 해당 컴포넌트가 실행되는 과정에서 접근하는 코드 경로에 포함된 컴포넌트는 모두 스레드 안전해야 함

<br>

## 2 Chapter 스레드 안전성
- 병렬 프로그램을 작성하려면 스레드와 락을 잘 사용해야 하는데 이것이 목적이 되는 것이 아니라 수단이 되어야 함
- 스레드에 안전한 코드를 작성하는 것은 근본적으로는 상태, 특히 공유되고 변경할 수 있는 상태에 대한 접근을 관리하는 것
- 공유되었다는 것은 여러 스레드가 특정 변수에 접근할 수 있다는 뜻이고 변경할 수 있다는 것은 해당 변수 값이 변경될 수 있다는 뜻으로 스레드 안전성을 위한 것은 데이터에 제어 없이 동시에 접근하는 것을 막으려는 의미
- 객체가 스레드에 안전해야 하느냐는 해당 객체에 여러 스레드가 접근할지의 여부에 달려있음
- 즉, 프로그램에서 객체가 어떻게 사용되는 가의 문제지 그 객체가 무엇을 하느냐에는 무관함
- 이렇게 스레드 안전성을 위해 동기화를 진행하고 동기화가 제대로 되지 못하면 데이터가 손상되거나 바람직 하지 않은 여러 가지 결과가 생길 수 있음
- 스레드가 하나 이상 상태 변수에 접근하고 그 중 하나라도 변수의 값을 쓰면 해당 변수에 접근할 때 관련된 모든 스레드가 동기화를 통해 조율해야함
- 자바에서는 동기화를 위한 기본 수단은 synchronzied 키워드로 배타적인 락을 통해 보호 기능을 제공하며 volatile 변수, 명시적 락, 단일 연산 변수 등을 사용하는 경우도 동기화 라는 용어를 사용함
```
여러 스레드가 변경할 수 있는 하나의 상태 변수를 적절한 동기화 없이 접근하면 잘못된 프로그램이며 해당 프로그램을 고치는 세가지 방법은 다음과 같음
- 해당 상태 변수를 스레드 간에 공유하지 않기
- 해당 상태 변수를 변경할 수 없도록 만들기
- 해당 상태 변수에 접근할 땐 언제나 동기화를 사용하기

스레드 안전한 클래스를 설계할 땐, 바람직한 객체 지향 방법이 왕도이며 캡슐화나 불변 객체를 잘 활용하고 불변 조건을 명확하게 기술해야 함
```

<br>

### 1. 스레드 안전성이란
- 스레드 안전성은 여러 정의가 나오지만 해당 책에서는 해당 정의들이 "여러 스레드에서 안전하게 사용될 수 있으면 해당 클래스는 스레드 안전하다"라고 가르키는 식의 말 같다고 함
- 스레드에 대한 납득할 만한 정의의 핵심은 모두 정확성 개념과 관련있고 스레드 안전성에 대한 정의가 모호한 것은 정확성에 대한 명확한 정의가 없기 때문임
- 정확성이란 클래스가 해당 클래스의 명세에 부합한다는 뜻으로 잘 작성된 클래스 명세는 객체 상태를 제약하는 불변조건과 연산 수행 후 효과를 기술하는 후조건을 정의
- 여러 스레드가 클래스에 접근할 때, 실행 환경이 해당 스레드들의 실행을 어떻게 스케줄링하든 어디에 끼워 넣든, 호출하는 쪽에서 추가적인 동기화나 다른 조율 없이도 정확하게 동작하면 해당 클래스는 스레드 안전하다고 말함
- 모든 단일 스레드 프로그램은 멀티스레드 프로그램의 한 종류로 볼 수 있어 애당초 단일 스레드 환경에서도 제대로 동작하지 않으면 스레드 안전한 것이 아니고 스레드에 안전한 클래스 인스턴스에 대해서는 순차적이든 동시든 어떤 작업들을 행해도 해당 인스턴스를 잘못된 상태로 만들 수 없음
- 스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능도 캡슐화함

<br>

```java
@ThreadSafe
public class StatelssFactorizer implements Servlet {    // 해당 클래스는 대부분의 서블릿 처럼 상태가 없어 선언한 변수가 없고 다른 클래스의 변수를 참조하지도 않으므로 안전한 스레드
    public void service(ServletRequest req, ServletResponse resp) {
        BigInteger i = extractFromRequest(req);
        BigIntegerp[] factors = factor(i);
        encodeIntoResponse(resp, factors);
    }
}

// 상태 없는 객체는 항상 스레드 안전하다
```

<br>

### 2. 단일 연산
- 위의 객체에 상태를 하나 추가한다면 단일 스레드 환경에서는 잘 작동하겠지만 변경한 값을 잃어버리는 경우 값을 제대로 변경하지 못한다
- 해당 연산은 1 챕터 설명처럼 값을 가져오고, 값을 더하고, 새 값을 저장하는 별도의 3개의 단일 연산을 순차적으로 실행한 것이기 때문
- 이런 복합 연산을 동기화 없이 사용한다면 여러번 호출 했을 때 같은 값을 돌려주는 사소한 문제가 심각한 데이터 무결성의 원인이 됨
    - 병렬 프로그램에서 이렇게 불확실한 결과는 굉장히 중요한 개념으로 해당 책에서는 경쟁 조건이라는 별도 용어 정의

<br>

#### 경쟁 조건
- 경쟁 조건이란 상대적인 시점이나 또는 JVM이 여러 스레드를 교차해서 실행하는 상황에 따라 계산의 정확성이 달라질 때 나타냄. 즉 타이밍이 맞았을 때만 정답을 얻는 경우
    - 공유 자원에 여러개의 스레드가 접근하는 경우 경쟁 조건이 발생한다
    - 관찰하고나서 시각이 이후 더이상 유효하지 않은 시각이 될 수 있다

<br>

#### 늦은 초기화 시 경쟁 조건
- 점검 후 행동하는 흔한 프로그래밍 패턴으로 늦은 초기화(lazy initialization)가 있으며 늦은 초기화는 특정 객체가 실제 필요할 때까지 초기화를 미루고 동시에 단 한번만 초기화되도록 하기 위한 것
- 아래 코드는 늦은 초기화를 구현하여 ExpensiveObject가 이미 초기화 됬는지 점검하고 반환하는데 해당 클래스는 경쟁 조건으로 제대로 동작하지 않을 수 있음
- 스레드 A와 스레드 B가 접근하였을 때 A는 null 이므로 초기화를 하려고 할때 B가 null로 점검하고 초기화하여 각 스레드가 각자 다른 인스턴스를 가져갈 수도 있음
- 카운터를 증가시키는 작업과 같은 읽고 수정하고 쓰기 동작은 이전 상태를 기준으로 객체의 상태를 변경하는데 카운터를 증가 시키려면 이전 값을 알아야 하고 카운터를 갱신하는 동안 다른 스레드에서 그 값을 변경하거나 사용하지 않도록 해야 함

<br>

```java
@NotThreadSafe
public class LazyInitRace {
    private ExpensiveObject instance = null;

    public ExpensiveObject getInstance() {
        if (instance == null) {
            instance = new ExpensiveObject();
        }
        return instance;
    }
}
```

<br>

#### 복합 동작
- 처리하는 일련의 작업은 외부 스레드에서 봤을 때 더 이상 나눠질 수 없는 단일 연산이어야 했음
- 경쟁 조건을 피하려면 변수가 수정되는 동안 다른 스레드가 해당 변수를 사용하지 못하도록 막을 방법이 있어야 하며 이런 방법으로 보호해두면 특정 스레드에서 변수를 수정할 때 다른 스레드는 수정 도중이 아닌 수정 이전이나 이후에만 상태를 읽거나 변경을 가할 수 있음
- 만약 위의 코드가 단일 연산이었다면 경쟁 조건이 생길 수 없고 각 증가 연산은 의도했던 대로 카운터를 정확히 1만큼 증가 시켰을 것이다. 즉 스레드 안정성을 보장하기 위해 점검 후 행동과 읽고 수정하고 쓰기 등의 작업은 항상 단일 연산이어야 한다
- 점검 후 행동과 읽고 수정하고 쓰기 같은 일련의 동작을 복합 동작(compound action)이라고 함
- 즉, 스레드가 안전하기 위해서는 전체가 단일 연산으로 실행돼야 하는 일련의 동작을 지칭하는 것이다
- 아래 코드는 숫자나 객체 참조 값에 대해 상태를 단일 연산으로 변경할 수 있도록 AtomicLong으로 바꿔 카운터에 접근하는 모든 동작이 단일 연산으로 처리하게 바꿔 서블릿 상태가 카운터의 상태이고 카운터가 스레드에 안전하다고 말할 수 있음
    - 하지만 이후 상태가 안전한 객체 하나로 모든 상태를 관리할 수 없는 경우가 많아 간단하지 않을 수 있음

<br>

```java
@ThreadSafe
public class CountingFactorizer implements Servlet {
	private final AtomicLong count = new AtomicLong(0);

	public long getCount() {
		return count.get();
	}

	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = factor(i);
		count.incrementAndGet();
		encodeIntoResponse(resp, factors);
	}
}
```

<br>

### 3. 락
- 더 많은 상태를 추가할 때에는 스레드 안전한 상태 변수를 추가한다고 충분하지 않음
- 서로 다른 클라이언트가 동시에 접근하면 최근 결과를 캐시에 보관한다고 했을 때 서블릿은 가장 마지막에 수행하기 위해 입력된 값과 해당 결과 값인데 두개를 저장한다고 했을 때 여러 스레드에서 수행되는 작업의 타이밍이나 스케줄링에 따른 교차 실행과 관계 없이 불변 조건이 유지되어야 스레드 안전할 수 있음
    - 이 변수 둘은 독립적이지 않아 한 변수의 값이 다른 변수에 들어갈 수 있음
    - 다른 변수도 동일한 연산 작업 내에서 함께 변경해야 한다
    - 즉, 상태를 일관성 있도록 유지하려면 관련 있는 변수들을 하나의 단일 연산으로 갱신해야 함

<br>

#### 암묵적인 락
- 자바에는 단일 연산 특성을 보장하기 위해 synchronized 라는 구문으로 사용할 수 있는 락을 제공
- 해당 구문은 락으로 사용될 객체의 참조 값과 해당 락으로 보호하려는 코드 블록으로 구성되어 메서드 부분에 선언하면 메서드 내부의 코드 전체를 포함하며 메소드가 포함된 클래스의 인스턴스를 락으로 사용
- 모든 자바 객체는 락으로 사용할 수 있고 이와 같이 자바에 내장된 암묵적인 락 혹은 모니터 락이라고 함
- 락은 스레드가 synchronzied 블록에 들어가기 전에 자동으로 확보되며 정상적으로든 예외가 발생해서든 해당 블록을 벗어날 때 자동으로 해제됨
- 해당 락으로 보호된 synchronzied 블록이나 메서드에 들어가야만 암묵적인 락을 확보할 수 있음
- 자바에서 암묵적인 락은 뮤텍스로 동작하여 한 번에 한 스레드만 특정 락을 소유할 수 있음
    - 스레드 B가 가지고 있는 락을 스레드 A가 가지려면 계속 기다릴 수 밖에 없음
    - 특정 락으로 보호된 코드 블록은 한 번에 한 스레드만 실행할 수 있기 때문에 같은 락으로 보호되는 synchronzied 서로 다른 블록 역시 서로 단일 연산으로 실행됨
- synchronzied 블록을 동기화 수단으로 쓰면 쉽게 스레드 안전하게 고칠 수 있음. 하지만 메서드를 모두 블록으로 지정하면 여러 클라이언트가 동시에 사용할 수 없어 응답성, 성능이 엄청나게 떨어지져 다시 다룸

<br>

#### 재진입성
- 스레드가 다른 스레드가 가진 락을 요청하면 해당 스레드는 대기 상태에 들어간다. 하지만 암묵적인 락은 재진입 가능(reentrant)하기 때문에 특정 스레드가 자기가 이미 획득한 락을 다시 확보할 수 있음
- 재진입성은 확보 요청 단위가 아닌 스레드 단위로 락을 얻는다는 것을 의미한다
- 재진입성을 구현하려면 각 락마다 확보 횟수와 확보한 스레드를 연결시켜두고 확보 횟수가 0 이면 락은 해제된 상태, 스레드가 해제된 락을 확보하면 JVM이 락에 대한 소유 스레드를 기록하고 확보 횟수를 1로 지정
- 같은 스레드가 락을 다시 얻으면 횟수를 증가시키고, 소유한 스레드가 synchronzied 블록 밖으로 나가면 횟수를 감소 시키고 이렇게 횟수가 0이 되면 락은 해제됨
- 진입 가능한 락이 없으면 하위 클래스에서 synchronized 메서드를 제정의하고 상위 클래스의 메서드를 호출하는 단순한 코드에서도 데드락에 빠질 것
    - 죽, 재진입성 때문에 락의 동작을 쉽게 캡슐화할 수 있고, 객체 지향 병렬 프로그램을 개발하기가 단순해질 수 있음

<br>

### 4. 락으로 상태 보호하기
- 락은 자신이 보호하는 코드 경로에 여러 스레드가 순차적으로 접근하도록 하기 떄문에 경쟁 조건을 피하려면 하나의 공유된 상태에 대한 복합 동작을 단일 연산으로 만들어야 항상 일관적인 상태를 유지할 수 있음
- 하지만 단순히 복합 동작 부분을 synchronized 블록으로 감싸는 것으로는 부족하며 특정 변수에 대한 접근 하기 위해 동기화할 때는 해당 변수에 접근하는 모든 부분을 동기화해야 한다. 또한 해당 변수에 접근하는 모든 곳에서 반드시 같은 락을 사용해야 한다
    - 모든 변경할 수 있는 공유 변수는 정확하게 단 하나의 락으로 보호해야 한다. 유지보수하는 사람이 알 수 있게 어느 락으로 보호하고 있는지를 명확하게 표시하라.
- 락을 활용함에 있어 일반적인 사용 예는 먼저 모든 변경 가능한 변수를 객체 안에 캡슐화하고, 해당 객체의 암묵적인 락을 사용해 캡슐화한 변수에 접근하는 모든 코드 경로를 동기화함으로써 여러 스레드가 동시에 접근하는 상태에서 내부 변수를 보호하는 방법임
- 하지만 이런식의 락은 새로운 메서드나 코드 경로를 추가하면서 실수로 동기화하는 것을 잊기만 해도 쉽게 무너질 수 있음
- 특정 변수가 락으로 보호되면 해당 변수에 항상 락을 확보한 상태에서 접근하도록 하면, 한 번에 한 스레드만 해당 변수에 접근할 수 있다는 점을 보장할 수 있다. 클래스에 여러 상태 변수에 대한 불변조건이 있으면 불변조건에 관련된 각 변수는 모두 같은 락으로 보호돼야 한다는 추가 요구사항이 따라 붙는다.
    - 여러 변수에 대한 불변 조건이 있으면 해당 변수들은 모두 같은 락으로 보호해야 한다
    - 모든 메서드를 동기화 해버리면 활동성이나 성능에 문제가 생길 수 있음

<br>

### 5. 활동성과 성능
- 성능 향상을 위해 캐시기능을 추가헀을 때 해당 상태의 무결성을 위해 동기화가 필요했지만 모두 동기화를 한다면 엄청나게 성능이 떨어짐
    - synchronized 키워드를 지정하였는데 해당 규모가 메서드 전체로 하면 한 번에 한 스레드만 실행이 가능한데 동시에 여러 요청을 처리할 수 있게 설계된 서블릿 프레임워크의 의도와 배치됨
- 이러한 경우 synchronized 블록의 범위를 줄이면 스레드 안전성을 유지하면서 쉽게 동시성을 향상시킬 수 있음
- 하지만 synchronized 블록을 너무 작게 나누면 안되지만 오래 걸리는 작업을 synchronized 블록에서 최대한 뽑아 낼 필요는 있음
- 해당 방법으로 수정한 코드가 아래와 같고 synchronized 블록 밖에 있는 코드는 다른 스레드와 공유되지 않는 지역 변수(스택 변수)만 사용하기 때문에 동기화가 필요하지 않음
- 이렇게 접근하는 방식에서 동기화를 적용했기 때문에 이전처럼 AtomicLong을 같이 사용할 필요는 없음. 서로 다른 동기화 수단을 사용해봐야 이미 동기화 되어 있기도 하고 혼동을 줄 뿐 아니라 성능이나 안정성 측면으로 이점이 없음
- synchronized 블록의 크기를 적정하게 유지하는 데에서 안전성은 절대 타협할 수 없으며 단순성, 성능 등의 설계 원칙 사이에 적절한 타협이 필요할 수 있음
- 락을 사용할 땐 블록 안의 코드가 무엇을 하는지, 수행하는데 얼마나 걸릴지를 파악하는 것이 중요하며 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 락을 잡지 않는 것이 좋음

<br>

```java
@ThreadSafe
public class CachedFactorizer implements Servlet {
	@GuardedBy("this") private BigInteger lastNumber;
	@GuardedBy("this") private BigInteger[] lastFactors;
	@GuardedBy("this") private long hits;
	@GuardedBy("this") private long cacheHits;

	public synchronized long getHits() { return hits; }
	public synchronized double getCacheHitRatio() {
		return (double) cacheHits / (double) hits;
	}

	public void service(ServletRequest req, ServletResponse resp) {
		BigInteger i = extractFromRequest(req);
		BigInteger[] factors = null;
		synchronized (this) {
			++hits;
			if (i.equals(lastNumber)) {
				++cacheHits;
				factors = lastFactors.clone();
			}
		}
		if (factors == null) {
			factors = factor(i);
			synchronized (this) {
				lastNumber = i;
				lastFactors = factors.clone();
			}
		}
		encodeIntoResponse(resp, factors);
	}
}
```

<br>

## 3 Chapter 객체 공유

<br>