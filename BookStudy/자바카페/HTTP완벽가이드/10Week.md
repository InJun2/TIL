# 15. 엔터티와 인코딩, 16. 국제화

<br>

## 15. 엔터티와 인코딩
### 궁금한 내용
- HTTP 메시지 엔터티란?
- 청크 인코딩이란?
- HTTP/1.1에서 content-length 헤더가 필요한 이유
- 현재도 엔터티 요약에 MD5 알고리즘을 사용하는지?
- 전송 인코딩을 사용하는 이유?
- 범위 요청 방법
- 현재도 델타 인코딩을 사용하는지?

<br>

## 16. 국제화
### 궁금한 내용
- 주로 사용되는 charset 종류는?
- 유니코드와 UTF-8
- URI의 문자 인코딩

<br>

### HTTP 메시지 엔터티
- HTTP 메시지는 시작줄, 헤더, 본체로 구성되어 본문에 실제 데이터가 들어가는데 HTTP 엔터티는 이러한 본문과 본문을 설명하는 엔터티 헤더로 구성됨
- 엔터티 헤더
    - Content-Type: 본문의 MIME 타입. 예: text/html, application/json.
    - Content-Length: 본문의 길이를 바이트 단위
    - Content-Encoding: 본문의 인코딩 방식
    - Content-Language: 본문의 언어
    - Content-Location: 본문의 원본 위치
    - Last-Modified: 엔터티의 마지막 수정 시간
    - Expires: 엔터티의 만료 시간
    - ETag: 엔터티의 고유 식별자
    - Cache-Control: 캐싱 지시자
- 즉, 엔터티란 HTTP 메시지의 엔터티 관련 헤더와 엔터티(본문)을 가진 전송 데이터와 메타데이터

```
MIME (Multipurpose Internet Mail Extensions) 타입 : 인터넷에서 다양한 데이터 유형을 식별하는데 사용되는 표준 식별자로 주 타입과 부 타입으로 구성됨
- text/plain: 일반 텍스트 파일
- text/html: HTML 문서
- image/jpeg: JPEG 이미지 파일
- image/png: PNG 이미지 파일
- audio/mpeg: MP3 오디오 파일
- video/mp4: MP4 비디오 파일
- application/pdf: PDF 문서
- application/json: JSON 데이터
- application/xml: XML 데이터
- application/xhtml+xml: XHTML 문서
- application/javascript: JavaScript 코드
- application/octet-stream: 이진 데이터 (일반적으로 다른 MIME 타입으로 분류되지 않는 경우에 사용됨)
- text/css: CSS 스타일 시트
- text/csv: CSV 파일 (쉼표로 구분된 값)
- text/calendar: iCalendar 데이터
- image/gif: GIF 이미지 파일
- image/svg+xml: SVG 이미지 파일
- audio/wav: WAV 오디오 파일
- multipart/form-data: 웹 폼 데이터를 서버로 전송할 때 사용. 파일 업로드와 함께 텍스트 데이터를 함께 보낼 수 있음
- multipart/mixed: 여러 다른 MIME 유형의 부분을 포함하는 메시지. 이메일 메시지에서 첨부 파일과 함께 텍스트를 포함하는 데 사용
- multipart/alternative: 여러 MIME 유형의 부분 중에서 하나가 선택될 수 있는 대체 버전의 메시지. 예를 들어, HTML 형식과 일반 텍스트 형식의 이메일을 함께 제공하는 경우에 사용
- multipart/related: 관련된 콘텐츠를 함께 그룹화하는 데 사용. HTML 이메일에서 이미지와 같은 리소스를 함께 포함하는 데 사용
```

<br>

### 청크 인코딩
- HTTP 프로토콜에서 메시지 본문을 크기가 불명확하거나 동적으로 생성되는 경우에도 클라이언트와 서버 간에 데이터를 전송할 수 있도록 하기 위한 인코딩 방식
- HTTP/1.1에서 도입된 이 방식은 메시지를 일정한 크기의 청크(chunks)로 나누어 전송
    - 각 청크는 청크의 크기를 나타내는 16진수 값과 그에 따른 데이터로 구성됨
- 이 방법은 웹 서버가 본문을 생성하는 동안 데이터를 빠르게 전송하고, 클라이언트는 청크를 수신하는 동안 본문을 처리할 수 있기 때문에 대역폭과 처리 시간을 절약할 수 있음
    - HTTP/2는 단일 TCP 연결에서 다중 요청 및 응답을 처리할 수 있으며, 헤더 압축 및 다른 성능 향상 기능을 제공하여 전송 속도를 향상하여 상대적으로 청크 인코딩은 적어지는 추세
    - 하지만 여전히 대량의 데이터를 실시간으로 스트리밍해야 하는 경우에는 청크 인코딩이 유용 ex)실시간 오디오 또는 비디오 스트리밍 서비스

```
청크(Chunk)
- 일정한 크기로 나누어진 데이터 블록
- 청크의 크기는 전송 중에 동적으로 결정될 수 있으며, 각 청크는 개별적으로 전송됨

청크 인코딩(Chunked Transfer Encoding)
- HTTP 메시지 본문을 여러 청크로 나누어 전송하는 방식
- 각 청크의 크기는 전송 중에 명시
```

<br>

### Content-Length 가 필요한 이유
- 문제로 출제

<br>

### 엔터티 요약 알고리즘
- 현재는 MD5 는 충돌 공격에 취약한 해시 알고리즘으로 대신 SHA-256, SHA-3 같은 안전한 해시 알고리즘을 사용한다고 함

<br>

### 전송인코딩을 사용하는 이유
- 문제로 출제

<br>

### 범위 요청 방법
- 일반적으로 HTTP 범위 요청은 단일 범위 요청(single range request)이 주로 사용되며 여러 범위 요청(multiple range requests)은 multipart/byteranges 헤더로 응답함
    - 단일 범위 요청 : 클라이언트가 서버에게 하나의 연속적인 데이터 범위를 요청. 서버는 요청에 대한 범위의 데이터를 응답으로 반환
    - 여러 범위 요청 : 클라이언트가 서버에게 여러 개의 비연속적인 데이터 범위를 요청. multipart/byteranges 형식의 응답으로 반환
    - 두 요청 범위는 모두 Range 헤더를 사용하여 지정
- 단일 범위 요청은 웹 서버와 클라이언트 간에 간단하고 효율적인 데이터 전송을 가능하므로 주로 단일 범위 요청을 한다고 함
- 단일 범위 요청은 HTTP 요청 헤더의 Range 헤더를 사용하여 서버에게 특정 범위의 데이터를 요청하는 방식으로 다음과 같이 사용함
    - 범위 요청으로 서버가 응답시 상태코드는 206 Partial Content

```
단일 범위 요청
Range 헤더
Range: bytes=start-end

클라이언트가 파일의 첫 500 바이트 요청시 다음과 같이 Range 헤더 설정
Range: bytes=0-499

클라이언트가 4000 바이트 이후 범위 요청
Range : bytes=4000-

서버가 클라이언트에게 0부터 499번째 바이트까지의 데이터를 응답으로 반환하면 다음과 같이 Content-Range 헤더를 포함함
Content-Range: bytes 0-499/10000
```

<br>

### 현재 델타 인코딩 사용 유무
- 현재는 델타 인코딩보다 더 효율적이고 성능이 우수한 압축 및 데이터 처리 방법이 사용된다고 함. 예시는 다음과 같음
- 압축 알고리즘
    - 현재는 다양한 압축 알고리즘이 개발되어 있으며, 이전에 비해 훨씬 효율적이고 강력한 압축을 제공
    - gzip, Brotli, LZMA 등의 압축 알고리즘이 널리 사용되며, 델타 인코딩보다 더 효율적인 데이터 압축을 제공
- 차등 동기화 알고리즘
    - 델타 인코딩과 유사한 방식으로 변경된 부분만 전송하는데 사용되는 차등 동기화 알고리즘들은 델타 인코딩보다 더 나은 성능과 효율성을 제공
- 패치 및 업데이트 기술
    - 소프트웨어나 파일의 업데이트를 배포하는데 사용되는 패치 및 업데이트 기술은 델타 인코딩보다 효율적
    - 예를 들어, 미러링, 인크리멘털 백업, 파일 동기화 등의 기술이 존재
- 원격 백업 및 복원 시스템
    - 원격 백업 및 복원 시스템은 변경된 파일의 복사본을 관리하는데 사용하지만 델타 인코딩 대신 효율적인 데이터 전송 및 저장 방법을 제공하는 경우가 많음
- 네트워크 최적화 기술
    -  네트워크 최적화 기술은 네트워크 트래픽을 최적화하고 대역폭을 효율적으로 사용

<br>

### 주로 사용되는 문자 인코딩(charset)
- charset은 문자 집합을 의미하는 것이 아니라 MIME 차셋 값은 데이터 비트를 고유한 문자의 코드로 매핑하는 알고리즘의 이름
1. UTF-8: 현재 가장 일반적으로 사용되는 문자 인코딩. 유니코드 문자를 나타내는데 사용, 다국어 지원이 가능하고 호환성이 뛰어남
2. ISO-8859-1 (Latin-1): 서유럽 언어를 포함한 라틴 문자 세트를 나타내는데 사용됩. 유럽 언어에서 널리 사용되며, HTML의 기본 문자 인코딩으로 사용
3. Shift_JIS: 일본어를 위한 문자 인코딩으로 주로 사용. 마이크로소프트 윈도우 시스템에서 일본어 텍스트 파일을 표현하는데 사용
4. EUC-KR (Extended Unix Code-KR): 한글 텍스트를 위한 문자 인코딩. 주로 한국어 웹사이트나 한국어 문서에서 사용
5. ISO-8859-15: ISO-8859-1의 확장판으로, 유럽 언어의 추가 문자를 지원. 유럽 언어를 포함한 다양한 언어를 지원
6. GB2312: 간체 중국어를 위한 문자 인코딩으로, 중국어 웹사이트에서 주로 사용

<br>

### 유니코드와 UTF-8
- 유니코드는 전 세계의 모든 문자를 표현하기 위한 표준으로 각 문자에 고유한 코드 포인트를 할당
- 유니코드는 문자 집합이며 각 문자에 대한 고유한 코드 포인트를 정의함
- UTF-8 (Unicode Transformation Format - 8-bit)은 유니코드를 저장하고 전송하기 위한 인코딩 방식
    - UTF-8은 유니코드 코드 포인트를 바이트로 인코딩하는 방식을 정의
    - UTF-8은 ASCII 문자를 그대로 나타내기 때문에 ASCII와의 하위 호환성이 높음 (초기의 문자 인코딩 표준은 ASCII -> UTF-8)
- 즉, UTF는 유니코드(Unicode)를 저장하고 전송하기 위한 인코딩 방식이며 유니코드 문자를 컴퓨터에서 사용할 수 있는 형태로 변환(인코딩)하는 방법을 정의한 것

<br>

### URI의 문자 인코딩
- 기본적으로 IS-ASCII 를 사용하지만 유니코드 문자를 포함한 다른 언어를 표현하기 위해 UTF-8과 퍼센트 인코딩을 사용함
- 현대적인 웹에서는 유니코드 문자를 포함한 다양한 문자집합을 사용할 필요가 있어 URI에서는 비-ASCII 문자를 인코딩하는 퍼센트 인코딩(percent-encoding)이라는 표준 방법을 사용
    - 예를 들어, 유니코드 문자 "ü" (U+00FC)는 UTF-8로 인코딩하면 두 바이트의 시퀀스 C3 BC
    - 퍼센트 인코딩을 통해 이 UTF-8 바이트 시퀀스는 "%C3%BC"로 변환됨
    - 비-ASCII 문자 처리 : UTF-8로 인코딩한 후 퍼센트 인코딩


<br>

## 연습 문제

### Q1. HTTP/1.1에서 Content-Length가 필요한 이유

<details>
<summary>정답</summary>

- Content-Length가 없다면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 메시지 전송 중에 서버에 충돌이 난 것인지 구분하지 못함
- 클라이언트는 메시지 잘림을 검출하기 위해 Content-Length를 필요로 함
    - 이러한 메시지 잘림은 캐싱 프락시 서버에서 취약한데 잘린 메시지를 받았으나 잘렸다는 것을 인지하지 못하고 그대로 캐싱한다면 결함 있는 콘텐츠를 계속 제공할 것
    - 그렇기 때문에 캐싱 프락시 서버는 명시적으로 Content-Length을 가지고 있지 않은 HTTP 본문은 보통 캐시하지 않음
- Content-Length는 본문이 인코딩 되어 있다면 인코딩된 바이트의 길이를 Content-Length 값으로 제공하여 압축 데이터를 인식하고 이러한 데이터의 전송 완료도 확인이 가능
- Content-Length는 또한 지속 커넥션(Persistent Connection)에서는 필수적인데 HTTP 커넥션은 어디까지가 메시지 본문이고 어디부터가 다음 메시지인지 인식하기 위해 Content-Length가 필요
    - 클라이언트와 서버가 하나의 연결에서 연속적인 메시지를 구분할 수 있게하며 이 Content-Length 헤더가 없다면 클라이언트는 현재 응답이 끝났고 다음 응답이 시작된 지점을 정확히 알 수 없음
    - 청크 인코딩을 사용하면 헤더 없는 지속 커넥션을 사용할 수 있다고 함
- HTTP/2의 프레임에는 자체적으로 길이 정보가 포함되어 있어 Content-Length 없이도 데이터의 경계를 명확히 구분 할 수 있음
    - HTTP/2의 경우 데이터를 프레임 단위로 쪼개고 하나의 TCP 연결을 통해 여러 스트림을 동시에 다룸
    - HTTP/2에서는 각 스트림이 'END_STREAM' 플래그로 종결되어 스트림의 끝을 알 수 있음
- HTTP/3의 경우에도 마찬가지로 프레임을 스트림으로 전송하여 Content-Length 헤더가 필수가 아님
    - 마찬가지로 프레임에 길이 정보가 포함되어 있고, 스트림의 끝은 'FIN' 플래그로 표시

</details>

<br>

### Q2. 전송 인코딩을 사용하는 이유

<details>
<summary>정답</summary>

- 책에서 나오는 보안적인 이유보다는 주로 웹 서버와 클라이언트 간에 데이터를 압축하고 전송 효율을 높이는 데 사용
    - 보안 방면은 주로 SSL/TLS 보안을 사용하기 때문
- 성능 향상 : 데이터를 압축하여 전송하면 대역폭을 절약하고 네트워크 지연을 줄일 수 있음
- 로딩 속도 개선 : 웹 페이지의 로딩 속도를 개선하기 위해 전송 인코딩을 사용가능.  CSS, JavaScript 및 이미지와 같은 웹 리소스를 압축하여 전송하면 웹 페이지의 로딩 시간을 단축할 수 있음
- 데이터 비용 절감 : 데이터를 압축하여 전송하면 데이터 사용량을 줄일 수 있으므로 이동 통신망을 통해 전송되는 데이터 비용을 절약할 수 있음
- 네트워크 효율성 : 전송 인코딩은 TCP/IP 네트워크에서 효율적으로 작동하며, 데이터를 안정적으로 전송

```
전송 인코딩 예시
1. gzip 인코딩
- gzip은 DEFLATE 알고리즘을 사용하여 데이터를 압축하는 방법. 대부분의 현대적인 웹브라우저에서 gzip 인코딩 지원

2. deflate 인코딩
- deflate는 zlib 압축 라이브러리에서 사용되는 압축 방법. gzip보다는 압축 효율이 낮을 수 있음

3. br (Brotli) 인코딩
- Brotli는 Google에서 개발된 새로운 압축 알고리즘으로, gzip보다 더 효율적인 압축을 제공. 최신 버전의 웹 서버와 브라우저는 해당 인코딩을 지원

4. chunked 전송 인코딩
- chunked 전송 인코딩은 데이터를 여러 청크(chunk)로 분할하여 전송
```

</details>

<br>