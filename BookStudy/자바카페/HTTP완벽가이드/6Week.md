# 8. 통합점 : 게이트웨이, 터널, 릴레이, 9. 웹 로봇

<br>

## 8장 게이트웨이, 터널, 릴레이

### 궁금한 부분
- 원격 프로시저 호출(remote procedure call)이란?
    - 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게 하는 프로세스 간 통신 기술
    - 네트워크를 통한 메시징을 수행하여 다른 주소 공간의 함수를 사용
    - 스프링에서 제공하지 않지만 유사한 기능 수행 방법으로 Spring Remoting, Spring Cloud Netflix - Feign가 있다고 함
- SOAP(Simple Object Access Protocol)과 XML(eXtensible Markup Language) 이란?
    - SOAP : 네트워크 상에서 서로 다른 시스템 간에 메시지를 교환하기 위한 프로토콜(흔히 HTTP, HTTPS, SMTP 등을 통해 XML 기반의 메시지를 컴퓨터 네트워크 상에서 교환하는 프로토콜)으로 주로 RestFul 방식과 비교되는 방법
    - XML : 다목적 마크업 언어로, 데이터를 구조화하고 표현하기 위한 형식을 정의하는 데 사용
    - SOAP은 XML을 기반으로 하며, 서로 다른 플랫폼과 언어 간의 상호 운용성을 제공하는 웹 서비스를 구현하는 데 사용됨
- HTTP는 HTTP 커넥션을 통하여 트래픽을 전송하는데 웹 터널에서는 HTTP TCP를 사용하되 HTTP가 아닌 트래픽을 전송한다는데 무슨 이야기 인지?
    - 문제로 사용
- 터널의 끝단 어느 부분이든 커넥션이 끊어지면 끊어진 곳으로부터 온 반대편으로 전달된다는 것은 서버에서 보냈지만 클라이언트 부분이 끊겨 있다면 다시 서버로 보내서 커넥션을 끊는다는 건지?
    - 터널의 어느 커넥션이 끊어지면 해당 전송은 다시 전송처로 돌아가거나 그자리에서 커넥션이 끊김
    - 전송하려던 메시지는 없어짐

<br>

### 게이트웨이
- 리소스와 애플리케이션을 연결하는 역할
    - 애플리케이션은 게이트웨이에게 요청을 처리해달라고 할 수 있고(HTTP 혹은 그 밖의 정의해 둔 인터페이스를 통해), 게이트웨이는 그에 응답할 수 있음
- 게이트웨이는 요청을 받고 응답을 보내는 포털 같이 동작하는데, 동적인 콘텐츠를 생성하거나 데이터베이스에 질의를 보낼 수 있음
- 클라이언트 측 프로토콜과 서버측 프로토콜을 빗금 (/)으로 구분하여 기술함
    - <클라이언트 프로토콜>/<서버 프로토콜>

<br>

### 프로토콜 게이트 웨이
- 프락시에 트래픽을 바로 보내는 것과 같이 게이트웨이에도 HTTP 트래픽을 바로 보낼 수 있음
- HTTP/*: 서버 측 웹 게이트웨이
    - 서버 측 웹 게이트웨이는 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환함
- HTTP/FTP 게이트웨이 역할은 다음과 같은 일을 함
    - USER와 PASS 명령을 보내서 서버에 로그인
    - 서버에서 적절한 디렉터리로 변경하기 위해 CWD 명령을 내린다.
    - 다운로드 형식을 ASCII로 설정한다.
    - DTM으로 문서의 최근 수정 시간을 가져온다.
    - PASV로 서버에게 수동형 데이터 검색을 하겠다고 말한다.
    - RETR로 객체를 검색한다.
    - 제어 채널에서 반환된 포트로 FTP 서버에 데이터 커넥션을 맺는다. 데이터 채널이 열리는 대로, 객체가 게이트웨이로 전송
- HTTP/HTTPS: 서버 측 보안 게이트웨이
    - HTTP 클라이언트의 요청을 게이트웨이는 자동으로 사용자의 모든 세션을 암호화하여 보안 웹서버에게 전달함
    - HTTP 클라이언트 <-> HTTP/HTTPS 인바운드 보안 게이트웨이 <-> 보안 웹 서버
- HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이
    - 해당 게이트웨이는 보안 HTTPS 트래픽을 받아서 복호화하고, 웹 서버로 보낼 일반 HTTP 요청을 만듬
    - 브라우저(SSL(HTTPS)를 통한 HTTP) <-> HTTPS/HTTP 보안 가속 게이트웨이 <-> 웹 서버

<br>

### 리소스 게이트웨이
- 게이트웨이의 가장 일반적인 형태인 애플리케이션 서버는 목적지 서버와 게이트웨이를 한 개의 서버로 결합함
- 애플리케이션 서버는 HTTP를 통해서 클라이언트와 통신하고 서버 측에 있는 애플리케이션 프로그램에 연결하는 서버 측 게이트웨이임
- CGI (공용 게이트웨이 인터페이스)
    - 최초의 서버 확장이자 지금까지도 가장 널리쓰이는 서버 확장임
    - 이는 웹에서 동적인 HTML, 신용카드 처리, DB 질의 등을 제공하는 데 사용
    - 초기에는 매 CGI요청마다 프로세스를 생성하기 때문에 부하가 컸지만 어느 정도 기술이 발전하면서 이런 성능 저하는 해결되었음

<br>

### 서버 확장 API
- 모듈을 HTTP와 직접 연결할 수 있는 강력한 인터페이스인 서버 확장 API를 제공함
- 확장 API는 프로그래머가 자신의 코드를 서버에 연결하거나 서버의 컴포넌트를 자신이 만든 것으로 교체할 수 있게 하였음
- FPSE(FrontPage Server Extension)
    - 프론트 페이지 클라이언트로부터 전송되는 원격 프로시져 호출 명령(Remote Procedure Call, RPC)을 인식할 수 있음
    - 이 명령은 HTTP에 편승하여 옴

<br>

### 애플리케이션 인터페이스와 웹 서비스
- 데이터를 교환할 때 두 어플리케이션의 프로토콜 인터페이스를 맞추는 것은 까다로운 이슈였음
    - HTTP 메시지 포맷으로는 제약이 있었기 때문
- HTTP 헤더에 XML을 사용하여 정보 교환을 하는 방식을 표준으로 삼았고 이를 SOAP(Simple Object Access Protocol)이라 함

<br>

### 터널
- 웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공
- CONNECT로 HTTP 터널 커넥션 맺기
    - 웹 터널은 HTTP의 CONNECT 메서드를 사용해 커넥션을 맺음
- CONNECT 메서드를 활용한 게이트웨이와 터널 연결하는 방법은 다음과 같음
    - 클라이언트는 게이트웨이여 터널을 연결하려고 CONNECT 요청을 보냄
    - TCP 커넥션은 게이트웨이 -> 웹 서버에 커넥션 요청으로 연결을 맺음
    - TCP 커넥션이 맺어지면 게이트웨이는 클라이언트에게 HTTP/1.0 200 Connection Established 응답 전송
    - 터널이 연결되고, HTTP 터널을 통해 전송된 클라이언트의 모든 데이터는 TCP 커넥션을 통해 웹 서버에 전달

```http
<!-- CONNECT 요청 --!>
CONNECT home.netscape.com:443 HTTP/1.0
User-Agent: Mozilla/4.0

<!-- CONNECT 응답 --!>
HTTP/1.0 200 Connection Established
Proxy-agent: Netscape-Proxy/1.2
```

<br>

### 데이터 커널링, 시간, 커넥션 관리
- 터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없어서, 게이트웨이는 패킷의 순서나 흐름에 대한 어떤 가정도 할 수 없음
- 게이트웨이는 커넥션이 맺어지는 대로 헤더를 포함해서 읽어들인 모든 데이터를 서버에 전송해야 함
- 터널의 어느 부분이든 커넥션이 끊어지면, 그 곳으로부터 온 데이터는 반대편으로 전달되고, 그 다음 커넥션이 끊어졌던 터널의 끝단 반대편의 커넥션도 프락시에 의해서 끊어짐

<br>

### SSL 터널링
- 웹 터널은 방화벽을 통해서 암호화된 SSL 트래픽을 전달하려고 개발됨
- SSL 트래픽을 HTTP 커넥션으로 전송하여 80포트의 HTTP만을 허용하는 방화벽을 통과 시킴

<br>

### SSL 터널링 vs HTTP/HTTPS 게이트웨이
- HTTPS 프로토콜은 다른 프로토콜과 같은 방식으로 게이트웨이를 통과할 수 있음
- 게이트웨이가 FTP를 처리하는 방식과 같음
- HTTPS 프로토콜을 사용할 때의 단점은 다음과 같음
    - 클라이언트-게이트웨이 사이에는 보안이 적용되지 않은 일반 HTTP 커넥션이 맺어져 있음
    - 프락시가 인증을 담당하고 있기 때문에, 클라이언트는 원격 서버에 SSL 클라이언트 인증을 할 수 없음
    - 게이트웨이는 SSL을 완벽히 지원해야 함
- SSL 터널링을 사용하면
    - 프락시에 SSL을 구현할 필요가 없음
    - SSL 세션은 클라이언트가 생성한 요청과 목적지 웹 서버 간에 생성됨
    - 서버는 트랜잭션의 보안에는 관여하지 않고 암호화된 데이터를 그대로 터널링함

<br>

### 터널 인증
- HTTP의 다른 기능들은 터널과 함께 적절히 사용할 수 있음
- 프락시 인증 기능은, 클라이언트가 터널을 사용할 수 있는 권한을 검사하는 용도로 터널에서 사용할 수 있음

<br>

### 터널 보안에 대한 고려 사항
- 터널 게이트웨이는 통신하고 있는 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 없음
- 터널의 오용을 최소화하기 위해서, 게이트웨이는 HTTPS 전용 포트인 443같이 잘 알려진 특정 포트만을 터널링할 수 있게 허용해야 함

<br>

### 릴레이
- HTTP 명세를 완전히 준수하지 않는 간단한 HTTP 프락시
- 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 전달함
- 릴레이는 Connection 헤더를 제대로 처리하지 못해서 keep-alive 커넥션이 행(hang)에 걸리는 문제점이 있음
    - 웹 클라이언트는 'Connection: Keep-Alive' 헤더를 보내서, 릴레이에 커넥션을 맺기를 원한다는 내용의 요청 메시지를 전송함
    - 릴레이가 HTTP 요청을 받지만,'Connection' 헤더를 이해하지 못하므로 요청을 서버로 넘김
    - 웹 서버가 프락시로부터 'Connection: Keep-Alive' 헤더를 받으면, 릴레이가 keep-alive를 하기 바란다고 잘못된 결론을 내림
    - 릴레이는 웹 서버로부터 받은 Connection: Keep-Alive 헤더를 포함한 응답 메시지를 클라이언트에게 전달함
        - 클라이언트와 서버는 keep-alive로 통신한다고 믿고 있지만, 실제로 통신하는 릴레이는 keep-alive가 무엇인지도 모름
    - 원서버는 릴레이가 자신에게 커넥셔능ㄹ 계속 맺고 있기를 요청했다고 믿기 때문에 커넥션을 끊지 않을것이다.
        - 따라서 릴레이는 커넥션이 끊길 때를 기다리며 계속 커넥션을 맺고(hang) 있을 것
    - 클라이언트가 응답 메시지를 받으면, 바로 다음 요청을 keep-alive 커넥션을 통해 릴레이에게 전송한다. 브라우저는 계속 돌고 있지만, 아무런 작업도 진행되지 않음

<br>

---

<br>

## 9장 웹 로봇

### 궁금한 부분
- 크롤러와 크롤링
    - 크롤러는 웹 크롤링을 수행하는 소프트웨어 봇이나 프로그램
    - 크롤링은 웹 크롤러가 웹 페이지를 방문하고 데이터를 수집하는 과정
- 책에서 나온 예시 외의 크롤러를 사용하는 예시가 있을지?
- 웹 로봇이 80포트와 443포트로 같은 URL을 읽었을때 각각 저장하는지?
    - 로봇은 프로토콜과 포트 번호를 구분하여 저장하지는 않으므로 동일한 페이지로 저장한다고함
    - 하지만 저장 방식이나 로봇의 구현 방식에 따라 다를 수도 있음
- 웹 로봇의 루프를 피하기 위해 깊이 우선이 아닌 너비 우선이 좋은 이유는?
    - 문제로 사용
- 웹 로봇은 아직도 주로 요구사항이 적은 HTTP/1.0 으로 요청을 보내는지?
    - 아직까지 HTTP/1.0을 사용하는 로봇도 있지만 현재는 HTTP/1.1이나 HTTP/2.0을 주로 사용하다고 함
- 서버 요청 테스팅을 웹 로봇으로 서버 가용성을 체크해볼 수도 있지 않을까?
    - 일반적인 방법이라고 함
    - ex) Apache JMeter, Gatling, Selenium, Pingdom
- 현재의 로봇 차단 표준 버전
    - 여전히 1.0 을 주로 사용하며 일반적인 확장 방법으로 'robots meta'태그와 'Robots.txt Specification'을 사용한다고 함

```
- HTML 파일 내의 robots meta 태그
<meta name="robots" content="noindex, follow">

- Robots.txt Specification 예시
User-agent: *
Crawl-delay: 10
Allow: /public/
Noindex: /private/
```

<br>

---

<br>

## 질의 문제

### 1. 기존 게이트웨이 통신과 터널 게이트웨이를 통한 통신의 차이점은?

<br>

<details>
<summary>정답</summary>

### 기존 게이트웨이 통신
- 클라이언트와 서버 간의 HTTP 통신을 중개하고 제어하는 역할으로 서로 다른 프로토콜을 중계하고 연결함
- 기존의 HTTP 통신은 일반적으로 텍스트 기반의 요청과 응답을 사용하여 HTTP 프로토콜의 특성상 헤더와 본문으로 구성되어 사용하는데 기존 게이트웨이는 HTTP 통신을 중개하고 제어하기 때문에 HTTP 프로토콜의 특성을 이해하고 해당 통신을 처리
    - 게이트웨이는 HTTP 통신의 요청과 응답을 이해하고 처리하기 위해 헤더와 본문을 확인하고 분석
    - HTTP 요청을 해석하고, 이에 따라 적절한 동작을 수행하여 처리함

<br>

### 터널 게이트 웨이 통신
- 터널 게이트웨이는 HTTP 프로토콜을 사용하지만 HTTP가 아닌 트래픽을 전송하는데 사용됨
    - 데이터에 상관없이 HTTP 에서의 TCP 연결을 통해 클라이언트와 서버 간의 통신을 터널링하여, 클라이언트나 서버 상관없이 보내는 모든 데이터를 전달함
    - HTTP 프로토콜 자체에 대한 이해나 해석은 필요하지 않음 (HTTP 헤더, 응답코드에 대한 처리 하지 않음)
    - 터널 게이트웨이를 사용하는 경우, 중간에 있는 게이트웨이들은 터널을 통해 데이터를 전달하기만 하고 내용을 확인할 수 없음
- 단순히 클라이언트와 서버 사이에 데이터를 전달하는 역할을 수행하므로 헤더 같은 프로토콜 레벨을 처리할 필요가 없음
    - 터널 게이트웨이는 데이터에 대해 처리하지 않으므로 데이터가 중간에 변경되지 않음을 보장함

<br>

</details>

<br>

### 2. 웹 로봇의 루프를 피하기 위해 깊이 우선 방식이 아닌 너비 우선 방식이 좋은 이유는?

<br>

<details>
<summary>정답</summary>

- 두 탐색방식 모두 그래프나 트리에서 탐색을 수행하는 알고리즘으로 웹 로봇이나 웹 크롤러는 웹 사이트를 탐색하는데 사용되므로 루프를 피하는 것에 좀 더 중점을 두어야 하므로
- 너비 우선 탐색 방식은 현재 노드의 모든 이웃을 먼저 탐색하는 방법으로 현재 레벨에 맞는 노드를 우선적으로 방문하므로 루프 발생 가능성이 줄어듬
    - 너비 우선 탐색을 사용하면 로봇이 특정 경로에서 루프에 빠져도 다른 경로에서 여전히 수많은 페이지를 수집할 수 있어 한 경로에서 루프에 빠져도 지속적으로 탐색이 가능하므로
- 깊이 우선 탐색 방식은 현재 경로를 따라 더 깊은 노드로 점차 탐색하기 때문에 더 빠르게 한 경로를 탐색하기에는 좋지만 주로 재귀적으로 동작하여 루프에 빠지기 쉬움
    - 재귀적으로 동작하기 때문에 우선 찾고 있는 경로에서 루프에 빠질 경우 다른 페이지를 탐색할 수 없고, 스택 오버플로우의 문제가 발생할 수도 있음

<br>

</details>

<br>

### Reference
- https://devhtak.github.io/http%20완벽%20가이드/2021/01/24/HTTP_Chap08.html

<br>