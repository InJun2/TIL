# 13. 다이제스트 인증, 14. 보안 HTTP

<br>

## 13. 다이제스트 인증
### 궁금한 내용
- 다이제스트 인증과 기본 인증의 가장 큰 차이점은 난스다?
- OAuth2를 다이제스트 인증 대신 사용하는 이유

<br>

## 14. 보안 HTTP
### 궁금한 내용
- HTTPS 에서 SSL 에서 주요 사용되는 암호화 방법은 무엇인가?
- 오늘날의 디지털 인증서 표준 방법은 없는지?
- SSL 적용 과정은 어떻게 되는지?

<br>

## 찾아본 내용

### 다이제스트 인증
- 기본 인증은 base64 인코딩 / 디코딩할뿐 평문을 그대로 사용하는 것과 다르지 않음
- 다이제스트 인증에서 중요한 것은 비밀번호를 네트워크를 통해 보내지 않는 것이며 비밀번호 대신 fingerprint(지문) 또는 digest(요약)을 보냄
- 서버와 클라이언트가 모두 비밀번호를 알고 있기 때문에 서버가 클라이언트가 보낸 요약과 자신이 계산한 요약이 일치하는지 확인하는 방식으로 인증이 동작
    - 요약은 단방향 함수로 동작하여 모든 입력값들을 유한한 범위의 압축으로 변환하며 MD5나 SHA를 주로 요약함수로 사용
    - 요약 함수는 보통 암호 체크섬이라고 불리고 단방향 해시함수거나 지문함수임
    - 인증 세션은 WWW-Authenticate 인증 요구에 대한 클라이언트의 응답으로 그 보호 공간에 대한 인증 세션을 시작하게 함
- 재전송 방지를 위해 난스(nonce)사용
    - 요약을 가로채서 서버로 재전송하는 재전송 공격을 막기위해 서버가 클라이언트에게 난스를 건네주어 비밀번호에 난스를 섞어 난스가 바뀔 때마다 요약도 바뀌게 됨
- 다이제스트 인증 핸드 셰이크는 다음과 같음
    1. 서버가 난스를 생성한다.
    2. 서버가 영역(realm), 난스, 알고리즘을 보낸다. (인증 요구)
    3. 알고리즘을 선택하고 응답 요약을 생성한다.
    4. 클라이언트가 요약을 담아서 서버에게 돌려준다. 만약 클라이언트가 서버 인증을 원한다면 클라이언트 난스를 생성하여 함께 보낼 수도 있다.
    5. 서버는 클라이언트가 했던 그대로 요약을 계산한 다음 자신이 계산한 요약과 네트워크로 전송되어 온 요약이 일치하는지 확인한다. 만약에 클라이언트가 대칭적으로 서버에게 클라이언트 난스를 가지고 인증을 요구했다면, 클라이언트 요약이 만들어진다.

<br>

### 다이제스트 인증을 사용하지 않는 이유
- 연습 문제로 출제

<br>

### HTTPS 에서 SSL 에서 주요 사용되는 암호화 방법은 무엇인가?
- 대칭 키 암호화 (AES)
- 비대칭 키 암호화 (RSA, ECDHE)
- 해시 함수 (SHA-256)

<br>

### 대칭키 암호법
- 한 쌍의 호스트가 하나의 인코딩/디코딩 키를 사용
    - 인코딩 / 디코딩 알고리즘은 대부분 공개적으로 알려져 있고 키만이 유일한 비밀이므로 어떤 암호법이던 누설되지 않아야 함
- 대칭키 암호에서는 보통 모든 키가 유효하며 40비트 키라면 2^40 약 1조가지가 가능한데 오늘날 빠른 워크스테이션에서는 쉽게 깨질 수 있어 중요한 업무에는 128비트 대칭키 암호화를 사용
    - 키의 길이를 길게하는 것은 보안에 있어 중요한 요소
- 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야하는 단점 존재
    - 클라이언트와 서버가 은밀하게 대화를 나누려면 서버가 수천 개의 키를 생성하고 기억해야 함
- 주요 알고리즘으로는 AES, DES, 3DES 등이 존재

<br>

### 공개키 암호법
- 한 쌍의 호스트가 하나의 인코딩/디코딩 키를 사용하는 대신 두 개의 비대칭 키를 사용
    - 하나는 호스트의 메시지를 인코딩하기 위해 사용이고 다른 하나는 그 호스트의 메시지를 디코딩 하기 위한 것
    - 인코딩 키(공개키)는 모두를 위해 공개되어 있음
    - 개인 디코딩 키(개인키)는 호스트만이 가지고 있음
- 공개키 암호 방식의 알고리즘은 계산이 느린 경향이 있어 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰임 (혼성 암호 체계와 세션 키)
    - 노드들 사이 안전한 의사소통 채널을 수립할 때는 공개키 안호 사용
    - 이렇게 만들어진 안전한 채널링을 통해 임시 무작위 대칭 키를 생성하고 교환하여 나머지 데이터를 암호화할 때는 빠른 대칭 키를 사용이 흔히 사용됨
- 주요 알고리즘으로는 RSA, DSA 등이 존재

<br>

### 디지털 서명
- 암호 체계에서 누가 메시지를 썼는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명을 진행
- 디지털 서명은 메시지에 붙어있는 특별한 암호 체크섬
    - 서명은 메시지를 작성한 저자가 누구인지 알려줌. 저자는 극비 개인키를 가지고 있어 저자만이 체크섬을 계산할 수 있음. 체크섬은 저자의 개인 '서명' 처럼 동작
    - 서명은 메시지 위조를 방지함. 만약 악의적인 공격자가 송신 중인 메시지를 수정했다면 체크섬은 더 이상 그 메시지와 맞지 않게 될 것이므로 위조된 메시지에 대해 올바른 체크섬을 날조할 수 없음
- 디지털 서명은 보통 비대칭 공개키에 의해 생성되어 오직 소유자만이 알고 있어 저자의 개인 키는 일종의 '지문'처럼 사용됨
- 디지털 서명 방식
    - 노드 A는 가변 길이 메시지를 정제하여 고정된 길이의 요약(digest)로 만듦
    - 노드 A는 그 요약에, 사용자의 개인 키를 매개변수로 하는 '서명' 함수를 적용해서 서명과 메시지를 노드 B에 전송
    - 메시지를 받은 노드 B는 공개키를 이용한 역함수를 적용하여 서명을 검사 -> 이 결과가 노드 B가 갖고 있는 버전의 요약과 일치하지 않는다면, 메시지는 송신 중에 위조되었거나 발송자가 노드 A가 보낸 메시지가 아닌 것

<br>

### 디지털 인증서
- 공식적으로 인증 기관에 의해 디지털 서명된 정보의 집합이 담겨 있는 인증서
    - 대상의 이름 (사람, 서버, 조직 등)
    - 유효 기간
    - 인증서 발급자(누가 이 인증서를 보증하는가)
    - 인증서 발급자의 디지털 서명
- 추가적으로 디지털 인증서는 대상과 대상의 공개키도 담고 있음
    - 누구나 디지털 인증서를 만들 수 있지만 그 모두가 인증서의 정보를 보증하고 인증서를 개인키로 서명할 수 있는 널리 인정 받는 서명 권한을 얻을 수 있는 것은 아님
- 여전히 X.509 인증서가 주로 사용되며 디지털 인증서의 형식과 인증서 검증 절차를 정의하는 국제 표준임

<br>

### 서버 인증을 위해 인증서 사용하기
- 사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져옴
    - 만약 서버가 인증서를 갖고 있지 않다면, 보안 커넥션은 실패
- 브라우저가 서버 인증서를 받으면 서명 기관을 검사
    - 만약 그 기관이 공공이 신뢰할만한 서명 기관이라면 브라우저는 그것의 공개키를 이미 알고 있을 것
    - 만약 서명 기관이 모르는 곳이라면, 서명 기관을 신뢰하는지 확인하기 위한 대화상자를 보여줌
- 서버 인증서가 포함하는 필드는 다음과 같음
    - 웹 사이트의 이름과 호스트 명
    - 웹 사이트의 공개키
    - 서명 기관의 이름
    - 서명 기관의 서명

<br>

### HTTPS 개요
- HTTPS는 그저 보안 전송 계층을 통해 전송되는 HTTP
    - HTTPS는 HTTP 메시지를 TCP로 보내기 전에 먼저 그걸 암호화하는 보안 계층으로 보냄
    - 현재 HTTPS 보안 계층은 SSL 혹은 TLS로 구현되었음
- SSL 트래픽은 바이너리 프로토콜으로 HTTP와 완전히 다른데 그 트래픽은 다른 포트(보통 443포트)로 전달
- 만약 SSL과 HTTP 트래픽 모두 80번 포트로 도착한다면 대부분의 웹 브라우저는 바이너리 SSL 트래픽을 잘못된 HTTP로 해석하고 커넥션을 닫을 것임

<br>

### 보안 전송 셋업
- 일단 TCP 연결이 되고 나면, 클라이언트와 서버는 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화 (SSL 핸드셰이크)
- 핸드 셰이크가 완료되면 클라이언트는 요청 메시지를 보안 계층에 보낼 수 있음
    - 이 메시지는 TCP로 보내지기 전에 암호화됨

```
1. 서버의 443 포트로 TCP 커넥션 수립
2. SSL 보안 매개변수 핸드 셰이크
3. SSL을 통해 보내진 HTTP 요청/TCP를 통해 보내진 암호화된 요청 전송
4. SSL을 통해 보내진 HTTP 응답/TCP를 통해 보내진 암호화된 응답 전송
5. SSL 닫힘 통지 및 커넥션 닫기
```

<br>

### SSL 핸드 셰이크
- 이후 연습 문제로 출제

<br>

### 서버 인증서
- 클라이언트 인증서는 최근 브라우저에서는 주로 사용되지 않음
- 서버 인증서는 신뢰할 수 있는 서버, 조직인지 확인하기 위해 HTTPS에서 무조건 요구됨

<br>

### 사이트 인증 검사
- 웹 서버 인증서 검사를 위한 알고리즘 수행 단계
1. 날짜 검사
    - 브라우저 인증서가 여전히 유효함을 확인
2. 서명자 신뢰도 검사
    - 만약 신뢰할 만한 CA가 A 사이트에 서명을 하고, A 사이트가 어떤 사이트 인증서에 서명을 한다면, 브라우저는 그 인증서를 올바른 CA 경로에서 파생된 것으로 받아들일 수 있음
3. 서명 검사
    - 서명 기관이 믿을 만하다고 판단하면, 브라우저는 서명기관의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄으로써 인증서의 무결성을 검사
4. 사이트 신원 검사
    - 대부분의 브라우저는 인증서의 도메인 이름이 대화 중인 서버의 도메인 이름과 비교하여 맞는지 검사
    - 몇몇 CA는 와일드카드 표현이 들어있는 인증서를 만들기도 함

<br>

### OpenSSL
- SSL은 복잡한 바이너리 프로토콜이므로 암호 전문가가 아닌 이상 가공되지 않은 SSL 트래픽을 직접 보내면 안됨
- 이에 대해 SSL 프로그래밍을 쉽게 해주는 오픈소스 라이브러리 임
- OpenSSL은 SSL과 TLS의 가장 인기 있는 오픈 소스 구현으로 SSLeay 라이브러리를 계승하였음

<br>

### 프락시를 통한 보안 트래픽 터널링
- 프록시는 방화벽 라우터가 HTTP 트래픽의 교환을 허락한 유일한 장치
    - HTTPS가 프록시와도 잘 동작할 수 있게 하기 위해, 클라이언트가 프록시에게 어디에 접속하려고 하는지말해주는 방법을 약간 수정해야 함
    - 인기 있는 기법 중 하나가 HTTPS SSL 터널링 프로토콜
- HTTPS 터널링 프로토콜은 다음과 같음
    - 클라이언트는 먼저 프록시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 말해줌
        - 클라이언트는 이 내용을 프록시가 읽을 수 있도록 암호화가 시작되기 전의 평문으로 말해줌
    - 이를 위해 CONNECT 메서드를 이용해서 평문으로 된 endpoint 정보를 전송
    - 이후 클라이언트와 서버 사이에 데이터가 direct로 오갈 수 있는 터널을 만듦
- HTTPS 터널링 프로토콜에서 프록시는 서버와 클라이언트 사이에서 HTTPS 헤더를 이해하지 못해도 통신 터널을 생성하여 데이터를 전달하는 것

<br>

## 연습 문제

### Q1. 현재 다이제스트 인증을 사용하지 않는 이유는?

<details>
<summary>정답</summary>

- 다이제스트 인증은 기본 인증과 호환되는 더 안전한 대체제지만 현재는 거의 사용되지는 않는다
- 다이제스트 인증은 비밀번호 자체를 보호하는 것 일뿐이고 그 외의 어떤 비밀 보호를 제공하는 것은 아니기 때문에 HTTPS보다 안전한 프로토콜이라 볼 수는 없음
    - 요청 & 응답 외의 다른 부분에 대해선 다른 사람이 엿볼 수 있음
    - SSL 의 경우 보안 채널을 구성하므로 데이터 전송에도 안전
- 주로 사용되는 MD5는 충돌 공격에 취약한데 해당 알고리즘에 의존하는 구현이 많음
- 다이제스트 인증은 난스의 일회성 사용 및 만료 관리를 필요로 하여 서버측에 추가적인 상태 유지 및 관리 부담이 존재
- 현재 사용되는 OAuth2, JWT 등의 현대적인 인증 방식은 더 높은 보안성과 유연성을 제공하여 다양한 클라이언트에 대해 일관된 인증 방식을 제공
    - 표준화된 프로토콜 사용으로 여러 라이브러리와 프레임 워크 존재하여 구현과 유지보수도 용이
- 인증과 인가에 있어 보안이 더 강화되었으며 사용자가 자신의 자격증명을 제 3자 어플리케이션에 제공하지 않아도 특정 리소스에 접근할 수 있도록 권한을 위임함

</details>

<br>

### Q2. SSL 핸드 셰이킹 과정은 어떻게 진행되는지?

<details>
<summary>정답</summary>

- 암호화된 HTTPS 트랜잭션은 기존 HTTP 메시지 전송 과정과 매우 유사하지만 서버의 443포트 TCP 커넥션을 수립하고 SSL 보안 매개변수 핸드셰이크를 진행하고 이후 클라이언트/서버에서 각각 암호화된 요청과 응답을 전송함
    - 암호화된 HTTP 메시지를 보낼 수 있게 되기 전에 클라이언트와 서버는 SSL 핸드 셰이크를 할 필요가 있음
- 핸드 셰이크에서는 다음과 같은 일이 일어남
    - 프로토콜 버전 번호 교환
    - 양쪽이 알고있는 암호 선택
    - 양쪽의 신원을 인증
    - 채널을 암호화하기 위한 임시 세션 키 생성
- 단순화된 책의 SSL 핸드 셰이크 핵심 과정
1. 클라이언트가 암호 후보들을 보내고 인증서를 요구
2. 서버는 선택된 암호와 인증서를 보냄
3. 클라이언트가 비밀 정보를 보냄. 클라이언트와 서버는 키를 만듬
4. 클라이언트와 서버는 서로에게 암호화를 시작한다고 말해줌
- 그러니까 TCP 연결 수립 이후 SSL 핸드 셰이크는 보안 채널을 생성하기 위해 실행되는 과정으로 SSL 정보를 주고받아 사용할 SSL을 확정하고 이후 해당 보안 채널에서 메시지 전달에 사용할 키를 생성하기 위한 정보를 전달하고 생성하여 해당 키로 암호화하여 메시지를 HTTP 으로 전송하는 것임
- 결과적으로는 HTTPS 통신은 TCP 연결 수립 -> SSL 핸드셰이크 -> 데이터 전송 순으로 작동됨

<br>

```
- SSL 핸드 셰이크 보안 채널 설정
1. 클라이언트 헬로우 (Client Hello): 클라이언트가 서버에게 사용할 수 있는 SSL/TLS 버전, 암호화 스위트, 압축 방법 등을 제안
2. 서버 헬로우 (Server Hello): 서버가 클라이언트의 제안을 수락하거나, 사용될 SSL/TLS 버전, 암호화 스위트 등을 선택하여 응답
3. 서버 인증 (Server Certificate): 서버는 자신의 디지털 인증서를 클라이언트에게 전송함. 클라이언트는 이 인증서를 검증하여 서버의 신원을 확인
4. 서버 키 교환 (Server Key Exchange) : 필요한 경우 서버는 키 교환에 필요한 추가 데이터를 전송. 필요하지 않다면 이 과정은 패스됨
    - 클라이언트와 서버가 안전하게 대칭키(세션 키)를 공유하기 위해 생성하여 데이터를 쉽게 교환하기 위함임 (주로 DHE/ECDHE와 같은 일시적인 키 교환 메커니즘에서 필요)
    - 만약 RSA 방식으로 동작하고 있다면 클라이언트가 서버의 공개 키로 프리마스터 시크릿을 암호화하여 서버에 전송하므로 해당 과정은 진행되지 않음
5. 서버 헬로우 완료 (Server Hello Done): 서버가 초기 설정을 완료했음을 클라이언트에게 알림
6. 클라이언트 키 교환 (Client Key Exchange): 클라이언트는 프리마스터 시크릿을 생성하여 서버의 공개 키로 암호화하고 서버에 전송함. 이후 양쪽은 동일한 세션 키를 생성
    - 프리마스터 시크릿(premaster secret)은 SSL/TLS 핸드셰이크 과정에서 클라이언트와 서버가 최종적으로 세션 키를 생성하기 위해 사용하는 임시 비밀값
7. 클라이언트 완료 (Client Finished): 클라이언트는 핸드셰이크가 완료되었음을 알리는 메시지를 전송 (해당 메시지는 세션키로 암호화됨)
8. 서버 완료 (Server Finished): 서버도 핸드셰이크가 완료되었음을 알리는 메시지를 클라이언트에게 전송 (해당 메시지도 세션키로 암호화됨)
```

<br>

```
새션 재개
- 클라이언트와 서버가 이전에 수립한 세션을 재개하는 경우, 전체 핸드셰이크 과정을 반복하지 않고 세션 재개를 위한 간단한 절차를 수행할 수 있음
- 세션 ID: 클라이언트는 이전 세션의 ID를 서버에 제공하고, 서버가 이를 수락하면 세션 키를 재사용
- 세션 티켓: 세션 키를 포함하는 세션 티켓을 사용하여 세션을 재개. 이는 서버 상태를 유지하지 않는 방식
```

<br>

</details>

<br>