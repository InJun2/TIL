# 7. 캐시

<br>

### 캐시를 사용하는 이유
- 불필요한 데이터 전송 방지
    - 복수의 클라이언트가 자주쓰이는 원 서버로부터 각각 똑같은 데이터를 받으면 효율적이지 않음. 캐시를 사용하여 클라이언트에게 동일한 응답으로 전송
- 대역폭 병목 방지
    - 대부분 네트워크가 원격 서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공
- 갑작스런 요청에 대한 쇄도를 방지
    - 많은 사람이 동시에 웹 문서에 접근할 때 -> 트래픽 급증 -> 네트워크와 웹 서버의 심각한 장애. 해당 문제를 방지
- 거리로 인한 지연(latency)를 방지
    - 빛의 속도라도 거리에 의해 지연이 생길 수 있음

<br>

### 적중과 부적중
- 캐시 적중(cache hit) : 요청이 도착했을 때 그에 대응하는 사본이 있는 경우
- 캐시 부적중(cache miss) : 사본이 없어서 원서버로 요청을 보내야 되는 경우

<br>

### 재검사(Revalidation)
- 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야함
    - 신선도 검사 혹은 재검사 사용
- 캐시는 원한다면 스스로 언제든 사본을 재검사할 수 있음
- 재검사 요청 -> 서버응답 : (콘텐츠가 변경되지 않았다면) 304 Not Modified
    - 캐시는 사본이 신선하다고 임시로 다시 표시한 뒤 그 사본을 클라이언트에 제공 -> 재검사 적중, 느린 적중
        - 순수 캐시 적중보다 느림 - 원서버와 검사를 할 필요가 있기 때문
        - 캐시 부적중 보다 빠름 - 서버로부터 객체 데이터를 받아올 필요가 없기 때문
- HTTP는 캐시된 객체를 재확인 하기위한 몇 가지 도구 제공
    - If-Modified-Since 헤더
        - 서버에 보내는 GET요청에 이 헤더를 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미
- GET If-Modified-Since 요청이 서버에 도착했을 때 세 가지 상황이 존재
    - 서버 콘텐츠가 변경되지 않은 경우
    - 서버 콘텐츠가 변경된 경우
    - 객체가 삭제된 경우

<br>

#### 1. 서버 콘텐츠가 변경되지 않은 경우(재검사 적중)
- 서버는 클라이언트에게 HTTP 304 Not Modified 응답을 보냄

#### 2. 재검사 부적중
- 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보냄

#### 3. 객체 삭제
- 만약 서버 객체가 삭제되었다면, 서버는 404 Not Found 응답을 보내며, 캐시는 사본을 삭제한다

<br>

### 적중률
- 캐시가 요청을 처리하는 비율 : 캐시 적중률(혹은 캐시 적중비)
- 0 ~ 1 (0 ~ 100%)
- 책에서는 적중률 40%면 웹 캐시로 괜찮은 편이라고 함
- 즉 캐시를 사용하면 자주 쓰이는 문서들을 보관하여 상당히 트래픽을 줄이고 성능을 개선할 수 있음

<br>

### 바이트 적중률
- 문서들이 모두 같은 크기인 것은 아니기 때문에 적중률이 모든 것을 말해주지는 않는다
- 몇몇 객체는 덜 접근되지만 그 크기는 크기 때문에 전체 트래픽에는 더 크게 기여한다
- 이런 이유로, 어떤 사람들은 바디트 단위 적중률 측정값을 더 선호한다

<br>

### 적중과 부적중의 구별
- HTTP는 클라이언트에게 응답이 캐시 적중이었는지 아니면 원 서버 접근인지 말해줄 수 있는 방법을 제공하지 않음
- 두 경우 모두 응답 코드는 응답이 본문을 갖고 있음을 의미하는 200 OK가 됨
- 클라이언트가 응답이 캐시에서 왔는지 알아내는 방법 : Date헤더를 이용
- 응답의 Date헤더 값을 현재 시각과 비교하여, 응답의 생성일이 더 오래되었다면 클라이언트는 응답이 캐시된 것임을 알 수 있음
- Age 헤더를 사용하는 방법도 존재

<br>

### 캐시 토폴로지
- 전용 캐시(private cache) : 한명에게만 할당된 캐시
    - 한명의 사용자가 자주찾는 페이지를 담음
- 공용 캐시(public cache) : 사용자 집단에게 자주 쓰이는 페이지를 담음

<br>

#### 개인 전용 캐시
- 웹 브라우저는 개인 전용 캐시를 내장하고 있다
    - 개인용 컴퓨터의 디스크와 메모리 캐시하고 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용
    - 사용자는 브라우저의 캐시된 목록을 볼 수 있음

<br>

#### 공용 프락시 캐시
- 캐시 프락시 혹은 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버
- 캐시는 자주찾는 객체를 단 한번만 가져와 모든 요청에 공유된 사본을 제공함으로써 네트워크 트래픽을 줄인다
- 인터셉트 프락시는 HTTP요청이 캐시를 통하도록 강제할 수 있음. 해당 설명은 20장에서 추가 설명

<br>

### 프락시 캐시 계층들
- 클라이언트 주위에 작고 저렴한 캐시를 사용하고 계층 상단으로 갈수록 더 크고 강력한 캐시를 사용
    - 클라이언트 주위 작은 캐시부터 계층 구조를 이룸
    - 캐시 계층으로 프락시 연쇄가 생기고 해당 연쇄가 길어질수록 각 중간 프락시는 성능저하 발생

<br>

### 캐시망, 콘텐츠 라우팅, 피어링
- 몇몇 네트워크 아키텍처는 복잡한 캐시망을 이루고 있음
    - 캐시망 안에서 콘텐츠라우팅을 위해 설계된 캐시들은 다음에 나열된 일들을 모두 할 수 있을 것
        - URL에 근거하여, 부모 캐시와 원 서버 중 하나를 동적으로 선택
        - URL에 근거하여 특정 부모 캐시를 동적으로 선택
        - 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아봄
        - 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되,그들의 캐시를 통한 인터넷 트랜짓(Internet transit: 트래픽이 다른 네트워크로 건너가는 것)은 허용하지 않음
    - 복잡한 캐시 사이의 관계는 서로 다른 조직들이 그들의 캐시를 연결하여 서로를 찾아볼 수 있도록 해줌
        - 선택적인 피어링 지원하는 캐시는 형제 캐시
        - HTTP는 형제 캐시를 지원하지 않으며 인터넷 캐시 프로토콜(ICP) 혹은 하이퍼 텍스트 캐시 프로토콜(HTCP)같은 프로토콜을 이용해 HTTP를 확장

<br>

### 캐시 처리 단계
- HTTP GET 메세지 처리하는 기본적인 캐시 처리 절차 7단계가 존재
1. 요청받기 : 캐시는 네트워크로 부터 도착한 요청 메세지를 읽는다
2. 파싱 : 캐시는 메세지를 파싱 -> URL과 헤더들을 추출한다
3. 검색 : 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다(그리고 로컬에 저장한다)
4. 신선도 검사 : 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다
5. 응답 생성 : 캐시는 새로운 헤더와 캐시된 본문으로 응답 메세지를 만든다
6. 발송 : 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다
7. 로깅 : 선택적으로 캐시는 로그 파일에 트랜잭션에 대해 서술한 로그 하나를 남긴다

<br>

#### 1: 요청 받기
- 네트워크 커넥션에서 활동 감지하면 들어오는 데이터를 읽음
- 고성능 캐시의 경우 메세지 전체가 도착하기 전에 트랜잭션 처리를 시작

#### 2: 파싱
- 요청 메세지를 여러 부분으로 파싱하고 헤더 부분을 조작하기 쉬운 자료구조에 담음
- 캐싱 소프트웨어가 헤더 필드를 처리하고 조작하기 쉽게 만들어 줌

#### 3: 검색
- URL을 알아내고 그에 해당하는 로컬 사본이 있는지 검사
- 로컬 본사본은 메모리 or 디스크 or 근처의 다른 컴퓨터에 있을 수 있음
- 캐시는 상황이나 설정에 따라서 그것을 원 서버나 부모 프락시 에서 가져오거나 혹은 실패를 반환함
- 캐시된 객체는 서버 응답 본문과 원 서버 응답 헤더를 포함하고 있으므로, 캐시 적중 동안 올바른 서버 헤더가 반환될 수 있음
- 캐시된 객체는 객체가 얼마나 오랫동안 캐시에 머무르고 있었는지를 알려주는 기록이나 얼마나 자주 사용되었는지 등에 대한 메타데이터를 포함함

#### 4: 신선도 검사
- HTTP는 캐시가 일정 기간 동안 서버 문서의 사본을 보유할 수 있도록 함
- 일정 기간이 넘은 것은 신선하지 않은 것으로 간주 
    - 문서를 제공 전에 어떤 변경이 있었는지 검사하기 위해 서버와 재검사를 해야 함
    - 이후 대부분의 해당 챕터의 남은 내용을 신선도 검사를 설명

#### 5: 응답 생성
- 캐시된 응답을 원서버에서 온 것 처럼 보이게 하고 싶기 때문에 캐시는 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성함
- 이 기저 헤더들은 캐시에 의해 수정되고 늘어난다
- 캐시는 클라이언트에 맞게 이 헤더를 조정해야함
    - 클라이언트가 HTTP/1.1 응답을 기대하는 상황에서 서버가 HTTP/1.0 응답을 반환했다면, 캐시는 반드시 헤더를 적절하게 번역해야 함
    - 캐시는 또한 캐시 신선도 정보를 삽입(Cache-Control, Age, Expires 헤더)
    - 요청이 프락시 캐시를 거쳐갔음을 알려주기 위해 종종 Via 헤더를 포함 시킴
    - 캐시가 Date헤더를 조정해서는 안 된다는 것에 주의할 것
        - Date헤더는 그 객체가 원 서버에서 최초로 생겨난 일시를 표현하는 것임

#### 6: 전송
- 응답 헤더가 준비되면 캐시는 응답을 클라이언트에게 돌려줌
- 모든 프락시 서버와 마찬 가지로, 프락시 캐시는 클라이언트와의 커넥션을 유지할 필요가 있음

#### 7: 로깅
- 캐시는 로그 파일과 캐시 사용에 대한 통계를 유지한다
- 각 트랜잭션 완료되면 캐시는 통계 캐시 적중과 부적중 횟수(그리고 다른 관련 지표들)에 대한 통계를 갱신
    - 로그 파일에 요청 종류, URL 그리고 무엇이 일어났는지 알려주는 항목을 추가
- 캐시 로그 포맷 : 스퀴드 로그 포맷, 넷스케이프 확장 공용 로그 포맷
    - 대부분 커스텀 로그 파일 허용

<br>

### 사본을 신선하게 유지하기
- 오래된 데이터를 제공하는 캐시는 불필요
- 캐시된 데이터는 서버의 데이터와 일치하도록 관리되어야 함
    - HTTP의 문서만료와 서버 재검사

<br>

### 문서 만료
- HTTP는 Cache-Control과 Expires라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 유효가기간을 붙일 수 있게 해줌
- 우유팩에 쓰여 있는 유효기간과 마찬가지로, 이 헤더들은 콘텐츠가 얼마나 오랫동안 신선한 상태로 보일 수 있는지 좌우함

<br>

```http
// Expires 헤더
HTTP/1.0 200 OK
...
Expires: Sun, 12 Dec 2021, 17:40:00 GMT
...

// Cache-Control: max-age 헤더
HTTP/1.0 200 OK
...
Cache-Control: max-age=484200
...
```

<br>

### 유효기간과 나이
- 서버는 응답 헤더를 이용해서 유효기간을 명시
    - Cache-Control : 초 단위 숫자
    - Expires : 절대 유효기간
- Cache-Control, Expires는 기본적으로 같은 일을 하지만, 절대 시간은 컴퓨터의 시계가 얼마나 올바르게 맞춰져 있을 것을 요구
- 둘 다 있는 경우 max-age가 우선되고 expires는 무시

<br>

### 서버 재검사
- 캐시된 문서 만료는 검사할 시간이 되었다는 것으로 원 서버에 문서가 변경되었는지 여부를 물어봐 서버 재검사를 진행
- 재검사 결과 경우
    - 콘텐츠 변경되었을 경우 : 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내줌
    - 콘텐츠 변경되지 않았을 경우 : 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신

<br>

### 조건부 메서드와의 재검사
- HTTP의 조건부 메서드로 조건부 GET 요청이 있음
    - 조건부 GET 요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는것과 다른 경우에만 객체 본문을 보내달라고 하는 것
- 조건부 GET은 GET 요청 메세지에 특별한 조건부 헤더를 추가함으로써 시작 됨
    - If-Modified-Since, If-None-Match 의 경우 캐시 재검사를 할 때 유용
- If-Modified-Since : <data>
    - 문서가 날짜 이후로 수정되었다면 요청 메서드를 처리
    - 캐시된 버전으로 부터 콘텐츠가 변경된 경우에만 콘텐츠를 가져오기 위해 Last-Modified 서버 응답 헤더와 함께 사용됨
- If-None-Match : <tags>
    - 마지막 변경된 날때를 맞춰보는 대신, 서버는 문서에 대한 일련번호 같은 특별한 태그(ETag 등)를 제공할 수 있음
    - 캐시된 태그가 서버에 있는 문서의 태그와 다를 때만 요청을 처리함

<br>

### If-Modified-Since : 날짜 재검사
- 가장 흔히 쓰이는 캐시 재검사 헤더
- 재검사 요청은 흔히 IMS 요청으로 불림
- IMS 요청은 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 본문을 보내달라고 함
- 문서가 변경되지 않은 경우 새 만료 날짜를 보내줌

<br>

### If-None-Match : 엔터티 태그 재검사
- 어떤 문서는 일정 시간 간격으로 다시 쓰여지지만 실제로는 같은 데이터를 포함하고 있음
- 만약 서버의 엔터티 태그가 변경되었다면, 서버는 응답으로 새 콘텐츠르 새 ETag와 함께 반환했을 것으로 다음과 같은 경우 유용하게 대처 가능
    - 내용에는 아무런 변화가 없는데 주기적으로 업데이트가 되어야하는 경우
    - 단순하게 주석을 수정하였을 경우
    - 1초보다 작은 간격으로 수정이 이뤄지는 경우

<br>

### 약한 검사기와 강한 검사기
- 때로 서버는 모든 캐시 사본을 무효화시키지 않고 문서를 살짝 고칠 수 있도록 허용하고 싶은 경우가 있는데 이에 따라 약한 검사기와 강한 검사기가 있음
- 강한 검사기(strong validator) : 콘텐츠가 바뀔 때마다 바뀜
- 약한 검사기 : 어느 정도 콘텐츠 변경을 허용하고 콘텐츠의 중요한 의미가 변경되면 함께 변경됨
- 서버는 “W/” 접두사로 약한 검사기를 구분

```http
ETag: W/"v2.6"
If-None-Match: W/"v2.6"
```

<br>

### 언제 ETag를 사용하고 언제 Last-Modified를 사용하는가
- HTTP/1.1 클라이언트는 만약 서버가 ETag를 반환했다면 반드시 ETag 검사기를 사용해야 함
- 만약 서버가 Last-Modified 값만을 반환했다면, 클라이언트는 If-Modified-Since 검사를 사용할 수 있음
- 만약 엔터티 태그와 최근 변경일시가 모두 사용 가능하다면, HTTP1.0, HTTP1.1 캐시 모두 적절히 응답할 수 있도록 클라이언트는 두 가지의 재검사 정책을 모두 사용해야 함

<br>

### 캐시 제어
- 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인가? HTTP는 이를 위한 여러 방법을 제시
- 응답에 첨부하는 Cache-Control 헤더를 서버의 우선순위대로 나열해보면 다음과 같음
    - no-store
    - no-cache
    - must-revalidate
    - max-age
    - 아무 만료 정보 제공 없이 캐시 스스로의 체험적인(휴리스틱) 방식

<br>

### no-cache, no-store 응답 헤더
- 이 두 헤더는 캐시가 검증되지 않은 캐시된 객체로 응답하는 것을 막음
- no-store 표시된 응답은 캐시가 그 응답의 사본을 만드는 것을 금지함
    - 즉, 클라이언트에게 no-store 응답을 전달하고 나면 객체를 삭제할 것
- no-cache 표시된 응답은 사실 로컬 캐시 저장소에 저장될 수 있음
    - 다만 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없을 뿐임
    - 헤더 이름만 보면 절대 캐시를 하면 안 될 것만 같은데, 작명이 잘못된 것 같다. 이 책의 저자는 차라리 "Do-Not-Serve-From-Cache-Without-Revalidation" 이런 이름이 낫겠다고 말함

<br>

### Max-Age 응답 헤더
- max-age 헤더는 초로 나타내고, 리소스가 유효하다고 판단되는 최대 시간이라고 볼 수 있음
- 이를 0으로 설정할 경우, 캐시가 매 접근마다 문서를 캐시하거나 리프레시하도록 요청할 수 있음

<br>

### Expires 응답 헤더
- 이 헤더는 현재 Deprecated 되었다. 그래도 굳이 설명을 덧붙여보자면, 초 단위의 시간 대신 실제 만료 날짜를 명시함
- HTTP를 설계한 사람들은 많은 서버가 동기화되어있지 않거나 부정확한 시계를 갖고 있기 때문에, 만료를 이 헤더처럼 절대시각으로 표현하는 것은 문제의 소지가 있다고 판단했음
- 대신 max-age같은 경과된 시간으로 표현하는 방법으로 대체될 수 있을 것

<br>

### Must-Revalidate 응답 헤더
- 만약 캐시가 만료 정보를 엄격하게 따르길 원한다면, 원 서버는 응답헤더에 must-revalidate을 붙일 수 있음
- 이 헤더는 캐시가 객체의 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안 됨을 의미함
- 그러나 만약 캐시가 must-revalidate 신선도 검사를 시도했을 때 원 서버가 사용할 수 없는 상태라면, 캐시는 반드시 504 Gateway Timeout error를 반환해야 함
- 이 헤더가 no-cache와 다른 것은 Must-Revalidate 헤더는 캐시 사본이 신선한 경우 원 서버와의 재검사 없이 바로 객체를 반환할 수 있으나 no-cache 의 경우 매번 원 서버와 재검사를 해야함
    - 즉, no-store 상태란 must-revalidate이며 max-age=0인 경우와 같다고 볼 수 있음

<br>

## 질의 문제

### 1. 서버 재검사와 캐시 재검사는 무엇인지?

<br>

<details>
<summary>정답</summary>

- 캐시 재검사와 서버 재검사는 모두 둘 다 클라이언트가 캐시된 데이터의 유효성을 확인하기 위해 서버에 요청을 보내는 과정을 의미
- 재검사 결과에 따라 해당 과정 동작
    - 재검사 적중 : 서버는 클라이언트에게 HTTP 304 Not Modified 응답을 보냄 (여전히 신선하다는 응답)
    - 재검사 부적중 : 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보냄
    - 객체 삭제 : 서버는 404 Not Found 응답을 돌려보내며 캐시는 사본을 삭

### 서버 재검사
- 클라이언트가 가지고 있는 데이터가 여전히 최신인지 확인하는 과정을 의미
- 클라이언트는 서버에게 해당 데이터의 최신 버전을 요청하고, 서버는 클라이언트에게 최신 데이터를 전송함
- 서버 재검사는 주로 캐시된 데이터의 만료 시간이 지났을 때 발생하며, 새로운 데이터를 가져와서 캐시를 갱신하는 역할
    - 재검사 결과 콘텐츠가 변경시 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 클라이언트에게 해당 사본을 전달
    - 재검사 결과 콘텐츠가 변경되지 않았다면 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신

<br>

#### 캐시 재검사
- 캐시된 데이터가 서버에 의해 수정되었는지 확인하는 과정을 의미
- 서버 재검사에서 캐시된 데이터가 서버에 의해 수정되었는지 확인하는 과정이 바로 캐시 재검사로 서버 재검사 안에 캐시 재검사가 존재
- 서버는 클라이언트가 보낸 요청을 기반으로 캐시된 데이터와 서버의 최신 데이터를 비교하여 변경 여부를 판단하고, 변경이 있었다면 새로운 데이터를 제공하는 것

<br>

</details>

<br>

### 2. 캐시 재검사에 사용되는 조건부 요청헤더 두 가지와 각각의 기능은?

<br>

<details>
<summary>정답</summary>

- 오래된 데이터를 제공하는 캐시는 불필요하므로 캐시된 데이터는 서버의 데이터와 일치하도록 유지해야하기 때문
    - 캐시된 데이터는 충분히 신선해야함
    - 신선하지 않다면 에러 메시지를 출력하거나 재검사를 진행해야함
- 주로 사용되는 방식은 If-Modified-Since와 If-None-Match 라고 함

#### 1. If-Modified-Since (IMS)
- 캐시된 객체가 마지막으로 변경된 시간을 서버에 전달함
- 서버는 이 시간 이후로 객체가 변경되었는지 확인하고, 변경이 있으면 새로운 객체를 반환함
- 주로 날짜를 기반으로 한 캐시 재검사에 사용됨

#### 2. If-None-Match (INM)
- 캐시된 객체의 엔터티 태그(ETag)를 서버에 전달함
- 서버는 이 태그를 사용하여 캐시된 객체가 최신인지 여부를 판단하고, 객체가 최신이 아니면 새로운 객체를 반환
- 엔터티 태그를 기반으로 한 캐시 재검사에 사용됨

<br>

</details>

<br>

### Reference
- https://jihyundev.tistory.com/16
- https://github.com/TEAM-ARK/HTTP_The_Definitive_Guide/blob/master/07.%20%20%EC%BA%90%EC%8B%9C/07_%EC%BA%90%EC%8B%9C_Tony.md