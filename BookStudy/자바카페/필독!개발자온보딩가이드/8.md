# 8장

## 8장 고객 앞으로! 소프트웨어 전달
- 소프트웨어 전달 단계는 빌드 -> 릴리스 -> 배포 -> 롤아웃 의 2가지로 구분

<br>

### 브랜칭 전략
- 앞서 전달 단계를 설명하기 전에 소스 컨트롤 브랜칭 전략이란 어디에 코드 변경을 커밋하고 어떻게 릴리스 코드를 유지보수할지 결정. 주요 브랜칭 전략은 해당 2가지가 있음
    - 트렁크 기반 개발 : (main, mainline이라고도 하는) 트렁크는 변경 이력을 가진 주 버전의 코드로 브랜치란 코드를 수정하기 위해 트렁크로부터 나온것이며 트렁크 기반 개발은 모든 개발자가 브랜치를 트렁크에게 가지치기하고 일 단위로 신속하게 트랭크로 머지하는 환경에 적합한 방법. 자주 머지하는 방식을 지속적 통합(CI, Continuous Integration)이라고 함
    - 기능 브랜치 기반 개발 : 기능 브랜치가 상당히 오래 유지되며 많은 개발자가 동시에 이 브랜치에서 작업. 너무 오래된 상태로 유지하지 않도록 트렁크의 변경사항을 기능 브랜치로 가져오는 리베이스를 수행할 것
        - 주요 방법으로 깃 플로 전략이 존재

<br>

### 빌드
- 빌드 : 소프트웨어를 전달하기 전에 먼저 패키지를 빌드해야하는데 소프트웨어 빌드는 의존성 해석 및 링킹, 린터 실행, 컴파일, 테스트, 소프트웨어 패키징 등 여러 단계로 구성
- 컨테이너와 머신 패키지는 소프트웨어 뿐만 아니라 소프트웨어를 실행하는 환경 자체를 빌드할 수 있으며 어떤 소프트웨어를 릴리스할지에 따라 패키징이 달라짐
- 패키지에는 버전을 명시하고 리소스는 각각 별도로 패키징 해야함. 패키지를 위한 패키지인 메타 패키지를 통해 고객에게 최종 패키지를 제공해라

<br>

### 릴리스
- 릴리스 단계 : 사용자가 소프트웨어를 사용할 수 있게함. 내부 웹 서비스의 릴리스 절차는 소프트웨어 패키지를 공유 패키지 리포지토리에 발행하는 하나의 단계로 끝나기도 하나 사용자가 직접 사용하는 기능의 릴리스는 산출물 발행, 문서 업데이트, 릴리스 노트, 사용자와의 소통 등 다양한 절차가 필요. 릴리스 관리자는 테스트, 기능 검증, 보안 절차, 문서화 등의 절차를 조율
- 릴리스를 다른 운영팀에게 의존하지말고 사용자에게 어떻게 전달되는지 책임 의식을 가져라 
    - 코드에 대해 개발자가 가장 잘알기 때문에 배포되어 동작하는 것은 우리의 책임
- 패키지는 깃 버전 제어 시스템에 간단히 태그로 생성할 수도 있지만 릴리스 리포지토리로 발행하자 
    - 버전 제어 시스템에서는 검색이나 배포 관련 기능을 별로 제공하지 않음
- 릴리스 요구사항과 개발 요구사항은 확연히 다르므로 모두 처리해야하고 처리하면 운영 이슈가 발생할 수도 있음
- 개발자는 작은 커밋은 자주하는 반면 체크아웃은 그다지 빈번히 수행하지 않는데 배포는 대부분 한 번에 여러 머신으로부터 코드를 체크아웃해 동일한 리포지토리나 물리머신을 공유하면 배포 요청과 개발자도구가 서로의 성능에 영향을 미칠 수 있음
- 자주 릴리스하는 것이 중요
- 변경 로그와 릴리스 노트는 릴리스에 어떤 변경사항이 반영되었는지 고객지원팀이 이해하는데 도움이 됨. 변경로그는 고객지원팀을 위한 것이고 릴리스 노트는 사용자들을 위한 것
- 변경 로그 생성을 자동화하려면 커밋 메시지나 이슈 트래커 레이블을 이용해 변경사항을 추적해야함

<br>

### 배포
- 배포 : 소프트웨어 패키지를 실행할 곳으로 옮기는 것
- 소프트웨어 배포는 직접 수행하지 말고 스크립트를 이용하고 배포를 자동화하면 스크립트의 동작을 재현할 수 있고 버전 제어도 가능하므로 좀 더 예측 가능한 배포를 구현할 수 있음
- 배포 자동화는 사람이 배제되어 일관적인 결과를 가지고 원하는 만큼 자주 배포를 실행할 수 있음. 배포 자동화는 이미 개발된 도구를 이용해 적용할 것
- 인스톨 스크립트는 여러 단계로 구성되는 경우가 많고 예상치 못해 실패할 수 있음. 그렇기때문에 애플리케이션을 완전히 배포하거나 아무것도 배포하지 않도록 원자적으로 만들어야 함
- 애플리케이션은 독립적으로 배포해라. 순서에 의존하게 되면 애플리케이션이 다른 애플리케이션의 처리를 기다려야하므로 처리속도가 느려지고 업그레이드해야 하는 두 애플리케이션이 서로 의존적인 경우 충돌이 발생하기도한다

<br>

### 롤아웃
- 롤아웃 : 새 코드가 배포되고 나면 그 코드를 동작시킬수 있음 ( 롤아웃할수있음 )
- 롤아웃은 한번에 진행하면 안되고 점진적으로 진행하여 동시에 문제를 겪는 일을 줄인다.
- 롤아웃 전략은 다음과 같으며 이후 설명하겠음
    - 기능플래그 : 각각의 코드 경로를 실행하는 사용자 비율을 제어할 수 있음
    - 서킷 브레이커 : 문제 발생시 자동으로 코드 경로를 바꿔줌
    - 다크론치 : 동시에 여러 버전의 소프트웨어를 실행하는 방법
    - 카나리 배포 : 동시에 여러 버전의 소프트웨어를 실행하는 방법
    - 블루-그린 배포 : 동시에 여러 버전의 소프트웨어를 실행하는 방법
- 그러나 너무 복잡한 롤아웃 전략을 채택하면 운영 복잡도만 증가할 뿐
- 롤아웃을 모니터링해라. 고급 릴리스 파이프라인은 자동으로 관측한 통계값을 기반으로 변경사항을 더 많은 사용자에게 롤아웃하거나 되돌림. 자동화가 되어있어도 모니터링을 필수며 사전에 미리 평상시의 상태 지표를 확인해두고 서비스 수준 지표는 서비스의 상태를 표시하는 지표로 해당 지표를 통해 서비스 성능 저하 여부를 주시해라. 어떤 지표나 로그를 확인해야 여러분의 변경사항이 올바르게 동작하는지 확일할 수 있고 예상 지표가 실제로 나타나는지 검증해라
- 기능 플래그를 활용해라 : 코드가 플래그(보통 정적 설정이나 동적 서비스를 이용해 설정하는)를 확인해서 특정 코드를 실행할지 여부를 결정하는 if문으로 감싸져 있음
- 기능 플래그를 사용한 코드가 상태를 변경할 때는 특별한 주의가 필요. 데이터베이스는 기능 플래그로 제어하지 않는 경우가 많아 게이터를 격리하고 플래그의 모든 상태에 대해 코드를 테스트하며 기능을 롤백할 때 데이터를 정리하는 스크립트도 작성해라
- 서킷브레이커를 이용해 코드를 보호 : 대부분 기능플래그는 사람이 제어하는데 서킷브레이커는 레이턴시나 예외 같은 운영 이벤트에 의해 자동으로 제어되는 기능 플래그. 성능이 저하되는 상황에서 시스템을 보호하기 위해 사용됨
- 서비스 버전은 병렬로 올리자. 웹 서비스는 기존 버전을 계속 실행하면서 새로운 버전을 배포하는 것이 가능한데 해당 경우 패키지는 동일한 머신에 함께 배포할 수도 있고 완전히 새로운 하드웨어에 배포할 수도 있음. 병렬 배포를 이용하면 천천히 버전을 올리면서 위험을 완화할 수 있으며 뭔가 잘못된 경우 신속하게 롤백할 수도 있음
- 서비스로 호출되는 일정 비율은 기능 플래그 비슷한 스위치를 이용해 기존 버전이 아닌 새 버전이 처리하게 할 수 있으나 해당 스위치는 애플리케이션의 진입점(대부분 로드밸런서나 프록시)에 위치함. 가장 보편적인 병렬 배포 방식은 카나리 배포와 블루-그린 배포임
- 카나리 배포 : 대규모 트래픽을 처리하며 수많은 인스턴스에 배포되는 서비스에 활용. 새로운 버전의 애플리케이션을 제한된 수의 머신에만 배포하여 약간의 사용자만 카나리 버전을 사용하게 함.카나리 버전이 비정상적으로 동작해도 소규모의 사용자만 영향을 받으며 에러가 발생하면 이 사용자들이 다시 예전 버전을 사용하도록 신속히 변경 가능
- 블루-그린 배포 : 두 가지 버전의 애플리케이션을 하나는 액티브 모드, 다른 하나는 패시브 모드로 동시에 실행하여 각각 패시브 클러스트와 액티브 클러스트가 존재하며 준비가 되면 트래픽을 새로운 버전으로 전달하고 액티브 환경으로 만든 후 기존 버전을 패시브 버전으로 전환. 새로운 버전이 문제가 발생하면 다시 액티브버전을 패시브 버전으로 전환함. 블루-그린 배포는 카나리와 달리 트래픽은 원자적으로 전환되며 블루와 그린 환경은 최대한 동일하게 유지됨. 클라우드 환경의 경우 보통 릴리스가 안정적이라고 판단되면 패시브 환경을 제거
- 다크 모드 : 기능 플래그, 카나리 배포, 블루-그린 배포 모두 일정 규모의 사용자에게 롤아웃하며 문제가 발생했을 때 완화할 수 있는 매커니즘을 제공하나 반면 트래픽 섀도잉 이라고 부르는 다크 론치는 최종 사용자에게는 볼 수 없는 상태에서 새로운 코드를 실제 트래픽에 노출하는 방법임. 다크코드가 잘못 동작해도 사용자에게는 별 다른 영향이 없음
- 다크 론치가 적용된 소프트웨어는 여전히 활성화 되어 있고 코드도 실행되지만 그 결과는 저장되지 않는다. 그래서 개발자와 운영자는 사용자의 영향을 최소화하면서도 소프트웨어가 프로덕션 환경에서 어떻게 실행되는지 파악할 수 있음
- 다크 론치의 경우 실제 트래픽과 애플리케이션 사이에 애플리케이션 프록시가 위치해 프록시가 요청을 다크 시스템으로 복제함. 그리고 동일한 요청에 대해 두 시스템으로부터 받은 응답을 비교한 후 차이점을 기록하는데 이때 프로덕션 시스템의 응답만 사용자에게 전달됨
- ‘다크 읽기’ 모드로 동작하는 시스템의 경우 읽기용 트래픽만 전달되며 데이터는 변경되지 않으며 ‘다크 쓰기’ 모드로 동작하는 시스템에는 쓰기 트래픽도 전달되며 완전히 독립적인 데이터스토어를 사용
- 하나의 요청에 대해 프로덕션 시스템에서 한 번, 다크 시스템에서 한 번, 총 두번의 처리가 발생하는 셈으로 중복 관련 에러는 피해야 하며 다크 시스템으로의 트래픽은 사용자 분석에서 제외해야 하며 이중 과금 같은 부수 효과도 처리해야 한다. 그래서 헤더를 수정해 다크 시스템으로 복제된 트래픽을 표시해 제외할 수 있음

<br>

## 이야기를 하면서 정리 및 생각되는 내용
- 깃 플로우기능 브랜치 전략을 써서 하고있는 줄 알았는데 책을 보니 트렁크 기반 개발에 좀더 가까웠던 것 같음
- 배포 쪽으로 많이 해보지도 않고 자동화 툴도 사용해보지 않다보니 내용이 이해가 많이 부족하게 되었는데 이후 배포/운영으로 공부를 진행해보고자 함
- 기능 플래그의 경우 CMS(Content Management System) 를 사용하는 팀에서 많이 사용할 것 같다고 예상 하심
- 다크 모드 (다크론치)는 무슨 기능인지 자세히 몰라서 질문을 통해 어느정도 다시 이해하였음. 프로덕션 데이터를 변경하지 않고 적용하기 위한 방법으로 이해
- 배포, 롤아웃을 공부하고 싶다면 쿠버네티스 환경을 공부하는 것이 좋을 것 같다고 하셨는데 이전 컨퍼런스를 통해 듣기도 했고 이후 배포/운영에 있어 쿠버네티스를 공부해보고자 함

---

<div style="text-align: right">23-10-25</div>