# 5장, 6장

## 5장 피할 수 없는 코드 의존성의 관리
- 의존성이란 코드가 의존하는 코드를 의미하며 의존섬 범위(dependency scope)는 의존성이 필요한 시점으로 컴파일 시점, 테스트, 런타임 등이 있음
- 버저닝 스키마를 잘 따르는 버전은 다음 특징이 존재
    - 고유성 : 버전은 재사용되지 않아야 한다. 산출물은 자동화된 워크플로를 통해 배포되고 캐시되며 사용됨. 변경된 코드를 이미 존재하는 버전으로 재배포하는 것은 안됨
    - 비교성 : 버전은 사람과 도구가 버전의 우선권을 이해하는데 도움이 된다. 우선권은 동일한 산출물의 여러 버전에 빌드가 의존하는 경우 충돌을 해결
    - 정보성 : 버전은 사전 릴리스한 코드와 정식 릴리스한 코드를 구분하고 산출불에 빌드 번호를 매기며 안정성과 호환성을 설명
- 시멘틱 버저닝 : 가장 보편적으로 사용하는 버저닝 스키마로 버전 번호 명세를 주버전(Major), 보조버전(Minor), 패치버전(Patch) 으로 구성
    - ex) httpclient 4.3.6
    - 주버전이 0인 것은 '사전 릴리스'로 개발 주기를 빠르게 가져가기 위해 사용되며 호환성은 전혀 보장되지 않음
    - 시맨틱 버저닝은 생소하지만 게임이나 서비스에서 많이 본 방식이었는데 고유성, 비교성, 정보성을 가지는 방법이라니 신기했음 
- 이행적 의존성 : 라이브러리를 주로 의존하는 라이브러리 처럼 다른 라이브러리에 의존하는 것. 의존성 보고서는 완전히 해석된 의존성 트리(혹은 의존성 그래프)를 보여줌
- 다른 라이브러리를 의존하는 라이브러리를 의존하는 이행적 의존성은 말은 어렵지만 계층 별로 의존한다고 생각. 100개의 라이브러리를 의존하는 1개의 라이브러리는 101개의 라이브러리를 의존하는 것과 같으며 하나가 변경되면 프로그램은 영향을 받게되어 외존성 트리를 확인하는 방법을 익혀놔야 함
- 의존성 지옥 : 동일 라이브러리 충돌이나 라이브러리 업그레이드 후 비호환성 문제를 유발하나 가장 보편적인 주범은 순환의존성, 다이아몬드 의존성, 버전 충돌이 있음
    -  해당 경험으로 생각나는 내가 직접 겪은 문제는 swagger springfox와 2.6 이상의 스프링 버전에서 발생. swagger 3.0과 spring actuator 호환성 문제 발생. 엔드포인트에 대해 의존성이 충돌 혹은 javax 와 jakarta 처럼 네임스페이스가 변경 되었을 때
- 다이아몬드 의존성 : 다른 라이브러리가 같은 라이브러리를 의존할 때 동시에 사용할 수 없으므로 하나의 버전을 선택해야함. 그렇기 때문에 업그레이드된 버전의 라이브러리를 쓰면 다른 하나의 라이브러리가 동작하지 않을 수 있음
- 순환의존성 : A->B->C->A 의존. 자연어 처리 라이브러리가 문자열 파싱 기능을 제공하는 유틸 라이브러리에 의존하는데 다른 개발자가 단어간 추출 유틸 라이브러리를 작성하며 같은 의존성을 추가할 경우
- 의존성 지옥은 언젠가 오고 피할 수 없지만 새로운 의존성이 추가될 때마다 비용이 따름. 의존성의 가치를 잘 생각해봐야 할 것
- 의존성은 빌드와 패키지 시스템을 위해 관리를 그만 둘 필요는 없음. 의존 코드 또한 복사도되고 벤더 도구로 관리되기도 하고 가려질 수 도 있음. 코드복사는 자기가 원하는 코드만 선택해서 사용할 수 있지만 자동화를 포기해야하고 직접 관리해야함
- 의존성 가리기는 충돌을 피하기 위해 의존성을 다른 네임 스페이스로 자동 이전하는 것. some.package.space -> shaded.some.package.space로 바꾸어 의존성을 강제하지 않게하지만 공개 API에 노출하면 안됨. 그것은 개발자가 가려진 패키지 공간의 객체를 생성해야 한다는 뜻으로 충돌 가능성이 높은 의존성을 광범위하게 사용하도록 만들고 있을 때만 의존성 가리기 기법을 적용할 것
- 버전은 고정해두는 것이 좋음. 그러나 스프링 부트는 의존성을 관리해주긴 함
- 의존성 범위를 좁히자. 의존성은 빌드 수명주기 중 언제 사용되는지 결정되는데 사용되는 범위를 줄이면 충돌에 도움되고 런타임 바이너리의 크기를 줄일 수 있음

<br>

## 6장 테스트! 개발자의 든든한 지원군
- 테스트는 동작을 확인하여 신뢰성을 주는 것이라고만 생각했는데 많은 이점이 있음. 다른 개발자가 자신의 API를 쓰게하여 코드의 동작이 바뀌는 것을 방지하고 코드가 명시된 대로 동작하는 지 보여줄 수 있어 기존 동작을 유지할 수 있게 하며 스파게티 코드나 의존성이 너무 많은 코드 등 엉망으로 구현된 코드를 개선할 기회를 얻게 되기도 함. 또한 개발자는 테스트를 작성하면서 관심사의 분리를 개선해 코드를 잘 정리하고 코드 간의 강력한 결합을 줄일 수도 있음
- 테스트주도개발(TDD)는 차츰 보편화되었는데 코드 작성 전 테스트를 먼저 작성하는 방법으로 코드가 완성되면 테스트가 성공하게 되는 방식. TDD 원칙을 따르면 실제 코드에 앞서 코드의 동작, 인터페이스 설계, 다른 코드와의 통합을 먼저 고민하게 됨
- 테스트 유형은 주로 단위테스트, 통합테스트, 시스템 테스트, 성능테스트, 인수 테스트 정도가 있음
    - 단위 테스트 : 코드의 단위로 메소드나 동작 하나를 검증
    - 통합 테스트 : 여러 컴포넌트가 함께 어우러져 동작하는지 검증
    - 시스템 테스트 : 시스템 전체를 검증, 중단 간(end-to-end) 워크플로는 프로덕션 환경의 전반적인 단계에서 실제 사용자의 동작을 시뮬레이션 함
    - 성능 테스트 : 주어진 설정 하에서 시스템의 성능 측정으로 예시로는 부하테스트, 스트레스 테스트가 존재
    - 인수 테스트 : 사용자나 사용자의 대리인이 제공된 소프트웨어가 인수조건을 만족하는지 검증하는 테스트
- 테스트 도구 : 테스트 작성도구, 테스트 실행 프레임워크, 코드 품질 도구 등 몇가지로 분류 가능
- 모킹(mocking)라이브러리 같은 테스트 작성 도구를 이용하면 깔끔하고 효율적인 테스트 작성이 가능
    - 모킹 라이브러리는 객체지향 코드 단위 테스트에 주로 사용되는데 주로 외부 시스템이나 라이브러리 또는 객체에 의존하는 경우가 많기 때문
    - 모의객체(mock)는 실체 시스템이 제공하는 인터페이스를 유사하게 모방하는 스텁 객체로 외부 의존성을 대체
    - 외부 의존성을 줄이면 단위 테스트가 용이하고 네트워크 호출없이, 셋업이 간편, 한가지 기능만 검증하는 단위 테스트에 집중이 가능해짐
    - 모의 객체를 과도하게 의존하는 것도 코드가 강하게 결합되어 있음을 의미하는 코드악취가 됨
- 테스트 프레임워크는 셋업부터 마무리까지 테스트의 수명주기를 모델링하여 테스트를 실행하게 해주는 도구
- 코드 품질 도구는 코드 커버리지와 복잡도 등을 분석하거나 정적 분석을 통한 버그 발견 및 코딩 스타일 에러 검사 등에 사용
- 코드 품질 규칙을 강제하는 도구를 린터(linter)라고 부르는데 린터는 정적 분석과 스타일 검사를 실행. 코드 품질 모니터링 도구는 복잡도나 테스트 커버리지 같은 지표도 보고해줌
    - 정적 코드 분석기 : 파일 핸들이 열린채로 둔다거나 값이 대입되지 않은 변수를 사용하는 등 일반적인 실수를 찾아줌. 거짓양성 보고의 가능성이 있으므로 정적 분석기가 보고한 문제는 신중하게 생각해야 하며 분석기가 특정 위반 사항을 무시하지 않도록 코드 애노테이션을 이용해 내용에 거짓양성 항목이 추가되지 않게해야 함
    - 코드 스타일 검사기 : 모든 소스 코드를 동일한 방식으로 작성할 수 있게함.
    - 코드 복잡도 도구 : 순환 복잡도를 계산하거나 간단한 코드의 분기 횟수를 확인해 너무 복잡한 로직을 작성하지 않게 함
    - 코드 커버리지 도구 : 테스트가 몇 줄의 코드를 실행했는지를 측정. 코드 커버리지가 낮아졌다면 테스트를 더 많이 작성해야 하나 적절한 커버리지(65%~85%) 유지. 100% 커버리지는 안정성이 보장되는 것도 아님
    - 그러나 새로운 도구를 추가할 때마다 복잡도가 증가시켜 테스트를 더디게 하는 도구도 간혹 존재
- 개발자 스스로 직접 테스트를 작성하고 품질 보증 팀(QA)팀의 역할과 협업 방법을 알아내는 것이 좋음
- 테스트는 깔끔하게 작성. 테스트 떄문에 의존성이 더해질 수 있고 유지보수가 필요하기 때문에 편법을 쓴 테스트 코드는 유지보수 비용이 높음. 안정성이 떨어지면 신뢰할 수 있는 결과를 기대하기 어려움
- 과도한 테스트는 어떤 테스트가 꼭 필요한지 감을 놓치게 만들고 비용낭비일 가능성이 크다. 위험 메트릭스를 이용하여 집중할 부분을 찾고 해당 메트릭스를 통해 발생 가능성이 높고 영향도가 큰 부분을 집중해라
- 테스트코드는 항상 같은 결과가 나와야되는데 DB도 테이블에 있는지 없는지 등으로 외부 요인이 없는 편이 좋고 고려해야함
    - 결정적 코드 (deterministic code) : 입력이 같으면 출력도 항상 같은 코드
    - 비결정적 코드 (nondeterministic code) : 입력이 같아도 출력은 다를수 있는 코드
- 비결정적 코드는 테스트의 가치를 떨어뜨리며 재현과 디버깅이 어려움. 비결정성은 주로 슬립이나 타임아웃 난수 생성 등을 제대로 처리하지 못해 발생하기도 한다. 부수 효과(side effect)가 있거나 원격 시스템에 의존하는 테스트도 비 결정성을 유발
- 마찬가지로 단위 테스트에서 원격 시스템을 호출하면 안됨. 원격 시스템 호출은 네트워크 연결이 필요한데 네트워크는 대체로 안정적이지 않고 네트워크 호출에 타임아웃이 발생해서 비결정성이 추가되기도 함. 원격 시스템에 문제가 생기면 테스트도 실패하게 되는데 원격 호출을 제거하면 단위 테스트에서는 속도와 이식성이 중요하며 이를 유지할 수 있음
- 특정한 시간에 의존하는 코드는 제대로 처리하지 않으면 비결정성을 유발. 시간을 리턴하는 정적 메소드를 활용하는 것보다는 테스트 시점에 시간을 제어할 수 있도록 클럭을 주입하는 것이 좋음
     - 모의 객체를 사용하여 클럭을 주입하고 의존성 주입 방법을 사용하여 테스트 코드가 모의 객체를 전달해 클럭의 동작을 재정의 할 수 있음
- 별도의 스레드나 프로세스, 머신에서 테스트가 돌아가는 경우 테스트가 결과를 검증하기 전에 작업을 완료할 수 있도록 슬립이나 타임아웃을 이용하는 경우가 많은데 이는 다른 스레드의 실행이 어느 시점이 지나면 완료될 것이라고 가정하는 것이므로 가정에 의존한다. 그렇기 떄문에 해당 방법은 사용하지 않는 것이 좋음
- 네트워크 소켓과 파일 핸들을 닫아라. 개발자가 테스트가 종료되면 운영체제가 모든 리소스를 해제할 거라고 생각하여 운영체제 리소스 누수를 일으키는 테스트도 많음. 그러나 테스트 실행 프레임 워크는 하나의 프로세스에서 여러 테스트를 실행시키므로 리소스 누수 발생 시 그 즉시 정리되지 않음
- 테스트는 특정 네트워크 포트를 바인딩해서는 안됨. 정적 포트 바인딩도 비결정성을 유발하는 요소. 테스트가 어떤 머신에서는 성공하지만 사용중인 포트에서는 실패할 수 있기 떄문에 네트워크 소켓에 0번 포트를 바인딩하면 운영체제는 사용 가능한 포트를 자동으로 열어줌
- 파일과 데이터베이스에 대해 고유한 경로를 생성해라. 테스트는 정적으로 선언한 위치에 데이터를 기록해서는 안됨. 데이터를 기록하는 것도 네트워크 포트 바인딩과 동일한 문제 유발하는데 동일한 파일 경로와 데이터베이스 위치를 사용하면 각 테스트가 서로 간섭하게 됨
    - 파일명, 디렉터리 경로, 데이터베이스나 테이블 명은 동적으로 생성하면 모든 테스트가 각자 다른 위치에서 읽고 쓰는 방법을 수행하므로 테스트를 병렬 수행 가능
    - 대부분의 언어는 임시 디렉터리를 안전하게 생성하는 유틸리티 라이브러리 제공. 파일 경로나 데이터베이스 위치에 UUID를 덧붙이는 것도 좋은 방법
- 이전 테스트의 상태를 격리하고 해제해라. 상태를 정리하지 않으면 디스크 공간이 부족하게 되서 테스트 환경이 불안정해지기도 함. 공유 리소스 때문에 테스트 결과가 달라질 수 있어 주의해야 함
    - 매번 테스트를 실행할 때마다 테스트 파일을 삭제하고 데이터베이스를 정리하고 메모리에 기록된 테스트 상태를 리셋해라. 테스트 스위트를 실행할 때마다 환경을 재빌드해서 테스트 머신의 상태가 정리되지 않고 남겨지는 경우가 없게 해라
    - 컨테이너나 머신 가상화 같은 도구를 이용하면 기존 전체 머신을 쉽게 제거하고 새로운 머신을 생성할 수 있으나 셋업 및 해제 메소드를 호출하는 것보다 느리게 실행되므로 테스트 규모가 큰 경우에만 효용성이 존재
- 테스트의 실행 순서의 의존해서는 안된다. 순서에 대한 의존성은 보통 한 테스트가 데이터를 기록하고 그 다음 테스트는 데이터가 기록된 상태임을 가정할 때 주로 발생하는데 다음 문제가 있음
    - 첫 번째 테스트가 실패하면 두 번째 테스트도 실패
    - 두 번째 테스트는 첫 번째 테스트가 완료되기 전까지 실행할 수 없으므로 테스트의 병렬 실행이 어려움
    - 첫 번째 테스트를 수정하면 의도지 찮게 두 번째 테스트가 실패할 수 있음
    - 테스트 실행기의 변경으로 테스트가 다른 순서로 실행될 수 있음
- 테스트 사이에 로직을 공유하려면 셋업과 해제 메서드를 사용하면 된다. 각 테스트에 필요한 데이터는 셋업 메소드를 이용해 마련하고 해제 메소드에서 해당 데이터를 제거하면 된다. 해당 동작을 통해 상태의 변화로 테스트가 서로 간섭받는 일이 없어짐

<br>

## 이야기를 하면서 정리 및 생각되는 내용
- 의존성 지옥을 해결하기 위한 코드 복사는 개인적으로 좋지 않은 생각이라는 의견이 있었음. 나도 그렇게 생각함
- 버전은 고정해두는 것이 좋으나 스프링 부트는 자체로 의존성을 관리해주기 때문에 고정할 필요는 없음
    - 그러나 스프링 버전마다 사용되는 버전이 명시되어 있으므로 충돌이 생길경우 확인해보는 것은 필요 ( https://docs.spring.io/spring-boot/docs/current/reference/html/dependency-versions.html#appendix.dependency-versions.coordinates )
- 테스트 코드 구현을 한 적이 적어 거의 그대로 작성하였는데 이후 공부가 필요할 것 같음
- 최근 적용되는 트렌드한 기술을 사용해보는 것이 좋음. 최근은 AI 같은 기술들을 통해 많은 기술들이 존재하는데 미리 사용해보고 적응해서 앞서나가는게 좋다는 의견 존재
- 소프트웨어 key 3 원칙을 간단하게 말해주셨는데 이후 공부해보면 좋을 것 같음 ( https://hongjinhyeon.tistory.com/136 )
    - DRY
    - KISS
    - YAGNI

<br>

---

<div style="text-align: right">23-10-10</div>