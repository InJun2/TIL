# 연결리스트

### 내용 정리하기 전에
- 해당 내용 정리는 코딩 인터뷰 완전 분석 책의 자료구조 파트를 정리하였음
- 자료구조에 널리 사용되는 보편적인 기법에 대해 작성되어 있음

<br>

### 연결리스트란?
- 위에서 설명했듯이 차례로 연결된 노드를 표현해주는 자료구조
- 배열과는 달리 연결리스트에서는 특정 인텍스를 상수 시간에 접근할 수 없고 리스트에서 K번째 원소를 찾고 싶다면 처음부터 K번 루프를 돌아야함
- 연결리스트의 장점은 리스트의 시작 지점에서 아이댐을 추가하거나 삭제하는 연산을 상수 시간에 할수 있다는 점
- 기본적으로 단일 연결리스트, 이중 연결리스트, 원형 연결리스트 등이 있음

```
1. 단일 연결리스트 (Singly Linked List):
- 각 노드가 데이터와 다음 노드를 가리키는 포인터(참조)로 이루어져 있음
- 각 노드에서 다음 노드로만 이동이 가능
- 마지막 노드의 다음 노드는 보통 null이거나 특별한 값으로 표시
- 구현이 간단하고 메모리를 효율적으로 사용할 수 있움

2. 이중 연결리스트 (Doubly Linked List):
- 각 노드가 데이터와 이전 노드, 다음 노드를 가리키는 포인터(참조)로 이루어져 있음
- 양쪽 방향으로 이동이 가능
- 첫 번째 노드의 이전 노드와 마지막 노드의 다음 노드는 보통 null이거나 특별한 값으로 표시
- 양방향으로 이동이 가능하므로 특정 노드에서의 삽입 및 삭제가 더 편리

3. 원형 연결리스트 (Circular Linked List):
- 마지막 노드가 첫 번째 노드를 가리키는 형태의 연결리스트
- 단일 연결리스트나 이중 연결리스트 모두 원형으로 구현될 수 있음
- 특정 노드에서 시작하여 모든 노드를 순회하는 데 유용
```

<br>

### 간단한 단방향 연결리스트 만들기
```java
class Node {
    Node next = null;
    int data;

    public Node(int d) {
        data = d;
    }

    void appendToTail(int d) {
        Node end = new Node(d);
        Node n = this;
        while (n.next != null) {
            n = n.next;
        }
        n.next end;
    }
}
```
- 연결리스트에 접근할 때 head 노드의 주소를 참조하는 방법을 사용했으나 해당 경우 문제는 여러 객체들이 동시에 연결리스트를 참조하는 도중에 head가 바뀌면 어떤 객체는 계속 이전 head를 계속 가르키고 있을 수도 있음

<br>

### 단방향 연결리스트에서 노드 삭제
- 연결리스트에서 노드를 삭제하는 연산은 노드 n이 주어지면 이전 노드를 찾아 다음 노드를 n의 기존 다음 노드와 같도록 변경
- 리스트가 양방향 연결 리스트인 경우에는 n의 다음 가리키는 노드를 찾고 다음 노드에서 이전 노드를 n의 이전 노드와 같도록 변경
- 해당 과정에서 유의해야하는 부분은 널 포인터 검사와 필요하면 head와 tail 포인터도 갱신해야 함
    - C나 C++처 럼 메모리 관리가 필요한 언어를 사용해 구현하는 경우에는 삭제한 노드에 할당되었던 메모리가 제대로 반환되었는지 반드시 확인해야 한다.

<br>

### Runner 기법
- 부가포인터라고도 부르며 연결리스트 문제에서 많이 활용되는 기법
- 연결리스트를 순회할 때 두 개의 포인터를 동시에 사용하는 것
- 이때 한 포인터가 다른 포인터보다 앞서도록 함
    - 앞선 포인터가 따라오는 포인터보다 항상 지정된 개수만큼을 앞서도록 할 수도 있고， 아니면 따라오는 포인터를 여러 노드를 한 번에 뛰어넘도록 설정할 수도 있음

<br>

### 재귀 문제
- 연결리스트 관련 문제 가운데 상당수는 재귀 호출에 의존하는데 재귀 호출 깊이가 n이 될 경우 해당 재귀 알고리즘이 최소 O(n) 만큼의 공간을 사용한다는 사실을 기억헤라
- 모든 재귀(recursive) 알고리즘은 반복적(iterativε) 형태로도 구현될 수 있긴 하지만 반복적 형태로 구현하면 한층 복잡해질 수도 있음