# Ssafy System Design Book Study Week4

## 기존 프로젝트 구현 기능
### 1. 비회원/회원 모두 Short URL 제공
- 로그인이 되어 있다면 회원 ID를 기록
- 회원이거나 비회원이거나 UUID를 받아와 Short URL 제공
- 최근 요청의 Short URL은 Redis Cache 를 통해 저장 후 반환
- UUID가 없다면 예외 발생

<br>

### 2. UUID를 통한 처리율 제한
- UUID를 키값으로 사용하여 Redis TTL 을 통한 처리율 제한 적용
- 동시성 문제를 해결하기 위해 스핀락을 통해 동시성 문제를 해결했으나 블로킹 락과 비교 필요
    - 세마포어, ReentrantLock, CountDownLatch 같은 Concurrency 자료구조

<br>

### 3. 생성된 URL 이 6개월이 지났을 경우 삭제
- 스케줄링을 통하여 6개월이 지난 Short URL을 삭제
- NamedParameterJdbcTemplate 를 사용한 Short URL delete 청크 처리

<br>

### 4. 회원 가입 시 유저가 생성한 Short URL 사용 기록 조회
- 회원의 경우 자신이 생성한 Short URL 목록 조회 가능
- 다른 유저가 자신의 Short URL 을 사용하는 경우 다른 유저가 보낸 요청 헤더에서의 클라이언트 정보를 기록하여 접근한 기록 조회 가능 
- 비회원의 UUID 로 Short URL 생성 후 회원 가입 시 해당 UUID를 통한 유저 생성 Short URL 기록 추가

<br>

## 기존 프로젝트 고도화 설계
### 1. 비밀번호 찾기 및 URL 연장 알림
- 현재 알림 기능을 서버를 새로 생성하여 적용할지, URL 연장 자체도 고민 중
- 현재 로그 배치 처리 서버 및 Short URL 인기 순위를 위한 실시간 서버 증설 고민에 있어 알림 서버는 배치하지 않을 것 같음
    - 혹은 실시간 순위를 위한 서버에서 추가적인 작업을 진행할 수도 있음

<br>

### 2. 현재 NamedParameterJdbcTemplate 를 사용한 6개월이 지난 ShortURL 삭제 스프링 배치로 변경
- 단순하게 쿼리를 여러번 끊어서 단일 스레드로 배치 단위로 데이터를 조회하고 삭제하고 있음
- 삭제 실패에 대한 재시도를 진행하고 있지 않음
    - 실패한 삭제 작업을 재시도할 수 있도록 RetryTemplate을 사용하면 다시 큐에 넣을 수 있다고 함
- 스프링 배치가 아니라도 멀티 스레드를 사용한 병렬 처리로 변경 예정
    - ExecutorService의 멀티 스레드를 사용한 배치 처리
- 해당 배치 삭제 처리를 추가 서버에서 해당 기능을 추가로 작업해도 가능하지만 그럴 경우 Redis Cache 에 저장했던 값이 DB에 삭제되어 없을 수 있음..

<br>

### 3. 메시지큐를 사용한 현재 Short URL 최고 사용 순위 실시간 제공
- URL Shortener 시스템의 동작 과정이 MySQL에 저장되고 있으므로 추가 EC2 프리티어 서버를 통한 실시간 순위 제공
    - 실시간이 아니라면 MySQL 에서 쿼리로 개수가 가장 많은 URL을 그룹화해서 정렬하면 될 것 같음..
- 메시지 큐를 사용하여 MySQL에서 데이터를 비동기적으로 수신한다는데 이에 대해 조사 필요
    - Kafka, Redis Streams, RabbitMQ 중 어떤 메시지 큐를 사용할지

<br>

### 4. 파일을 통한 로그 저장 및 배치 처리로 어노테이션을 사용한 Logback 수정하여 Slack 로그 모니터링
- 현재 로그에 대해 파일로 저장하고 있지 않음
- Short URL 서버에서 로그를 파일로 기록해두고 해당 파일을 추가 EC2 프리티어 서버에서 배치로 처리
    - Short URL 서버에서의 로그를 SCP 혹은 S3 에 저장
    - 이후 추가 서버에서 해당 로그를 읽기 및 외부 스토리지에 저장
    - Slack 으로 주요 로그 전송
- Prometheus & Grafana or AWS CloudWatch 등의 모니터링으로 트래픽에 대해 로드밸런싱 또는 레드,그린 배포 등을 처리 가능할 듯
    - 그런데 해당 기능은 무거움
    - 장애가 발생하면 알림을 보내려면 서버 모니터링이 필요

<br>

### 5. 트위터 스노플레이크 생성 기법 같은 UUID 대신 키 값을 줄일 수 있는 충돌이 적은 키값으로 변경
- 현재 UUID는 128 비트이며 이를 키 값으로 사용하고 있는데 해당 비트를 줄일 수 있는 방법이 있다면 변경 예정
- 현재 Redis 에 UUID를 키 값으로 사용하고 있는데 인메모리 데이터베이스이므로 키 값을 줄이는 것이 효과적

<br>

### 6. 이후 로그 서버, 인기 순위를 위한 서버 끼리의 데이터 동기화
- 동기화가 필요한 부분이 있을지


<br>

## 프로젝트 피드백
- 오히려 메시지큐를 사용하다보니 오버헤드가 생길 수 있음
    - 알림 서비스에서 오히려 메시지큐를 사용해서 알림마다 넣어서 사용하는 것이 나을 것 같아보임
    - 요청 정보를 이벤트로 전송후 해당 이벤트를 받은 서버에서 로깅 후 처리
    - 많은 트래픽이 온다는 상황을 제약조건으로 두고 해당 트래픽 상황에 대해 기록하고 보여주는 것이 좋을 것 같음
- 많은 유저가 사용했을 때 만들고 나서 6개월이 지난다고 삭제는 애매한 것 같음
    - 이에 대해 마지막으로 조회한 날짜가 어느정도 지났을 때 삭제하는 것이 나을 것 같음
    - 이에 대해 연장 기능 및 알림을 추가할지..

<br>

---

## 토스 문제

### 1. 인기글 서비스 개선하기
- 인기글 검색을 5분마다 스케줄링을 통해 내부 자료구조(트리맵?)로 초기화
- 내부 용량에 문제가 있을 것 같다면 레디스를 사용한 캐싱
- 가능하다면 인기글 서비스를 처리하는 서버를 두고 멀티 스레드를 통해 분할-정복으로 값을 저장해두고 있는 것이 좋을 것 같음
- 요청 마다 캐싱한 값을 클라이언트에게 반환

<br>

### 2. 전 국민 로또 이벤트
1. 1등이 반드시 나오도록 당첨 단어 6개를 자동으로 산출하는 시스템을 설계해 주세요.
- 

2. 당첨 단어를 산출한 이후, 당첨 여부를 즉시 확인할 수 있는 시스템을 설계해 주세요.
- 당첨 단어를 내부 자료구조 혹은 Redis에 List로 넣어놓는다?

3. 이를 설계하고 구현할 때 고려해야 할 부분도 서술해 주세요. 
- 모든 단어를 읽어오되 1등이 반드시 나와야 하므로 특정 단어들이 모두 한 인원에게 있는지 확인?
- 어떻게 구현해야할지 모르겠음..

<br>

### 3. 파트너사 지연 문제 해결하기
1. 튼튼뱅크 홈 API는 왜 10초보다 느려졌을까요? 느려질 수 있는 원인을 생각나는 대로 서술하고, 각각에 대해 실제 원인이 맞는지 확인할 수 있는 방법을 알려주세요.
- 튼튼뱅크 앱을 통해 기존 계좌 조회와 운세 확인 유저가 모두 튼튼 뱅크에 접근하기 때문에 조회하는 경우도 모든 데이터를 유저에게 전송하고 있어서?
- 또한 대박 운세의 데이터를 가져오는 과정에서 네트워크 IO가 발생하고 해당 정보가 출력되기 전에 유저에게 API가 제공되지 않아서?
- 현재 대박 운세의 API가 느려지는 경우가 있으니 해당 요청이 안갔을 때 재전송되는 횟수가 늘었을 것이다.

2. 본인이 생각한 원인이 맞다고 가정했을 때, 대박운세 API가 느릴 때도 튼튼뱅크를 정상적으로 이용할 수 있는 방법에 대해 알려 주세요.
- 특정 유저가 이미 운세를 받았다면 캐싱한 데이터를 반환
    - 그런데 항상 특정 기간동안 같은 데이터를 보내는 것은 요구사항에 존재하지 않음
- 운세를 원하는 유저에 한에서만 대박운세에 접근하여 데이터 제공
- 대박 운세와 튼튼 뱅크 API 커넥션 타임아웃을 늘린다 혹은 지나치게 응답이 안가면 미리 정해져 있는 운세중 하나를 랜덤으로 보낸다

<br>

### 4. 콘서트 티켓 재고 관리하기
- 동시성 제어 필요한데 어떻게 처리할지.. 메시지큐도 완벽한 동시성 제어를 제공해주지는 않는다고 생각
    - 우선 들어온 요청에 대해 메시지큐에 넣어놓고 이후 처리
    - 만약 들어온 요청이 동시에 들어왔다면 어떻게 하지..
- 또한 5개라는 제한 조건 이전에 실시간 재고 관리가 필수적인데 구매 중인 유저의 티켓은 어떻게 처리할 것인지
    - 구매 대기 중이라도 결제되거나 결제실패되기 전까지 락(Redis 분산락?)으로 해당 티켓을 막아놓는다

<br>

### 5. 포인트 지급
- Follower 노드가 Leader 노드로 변환되기 전 Leader 노드가 Follower 노드에 아직 동기화되지 않은 데이터들이 남아있어서?
- Leader 노드가 Follower 노드에 최신화 한 이후 부터의 로그를 통해 적용(리두로그 같은?)시키고 Leader 노드로 전환?