# CHAPTER3 CPU 스케줄링

## 1. 스케줄링의 개요
### 1-1. CPU 스케줄링
- CPU 스케줄러는 프로세서 스케줄러라고도 하며 프로세스가 생성된 후 종료될 때까지 모든 상태 변화를 조정하는 일을 함
- 해당 책에서는 스케줄링을 요리사 모형에서 식당 관리자로 설명해주고 있음
    - 요리가사 요리에 집중할 수 있도록 식당 메니저는 예약 관리, 좌석 관리, 주문 관리, 조리 순서 관리 등 외부적인 요소를 처리
    - 식당 매니저는 예약손님을 우선하거나 손님의 요청사항 변경 등에 대처하여 순서를 결정

<br>

### 1-2. 스케줄링 단계
- 스케줄링의 단계는 고수준 스케줄링, 중간 수준 스케줄링, 저수준 스케줄링이 존재
- CPU 스케줄링을 고수준 스케줄링 또는 장기 스케줄링, 작업 스케줄링이라고 함
- 고수준 스케줄링의 경우는 많은 작업을 동시에 하면 시스템에 과부하가 걸려 작업이 원할하게 이루어지지 않아 시스템 내의 전체 작업 수를 조절하는 것을 의미
- 고수준 스케줄링 단계에서는 어떤 작업을 시스템이 받아들일지 또는 거부할지 결정
    - 일단 작업이 시작하면 기존 작업에 영향을 끼침
    - 운영체제에서 가장 다루는 일의 큰 단위인 프로세스를 단위로 이루어짐
- 저수준 스케줄링의 경우는 CPU 스케줄러 입장에서 어떤 프로세스에 CPU를 할당할지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정
- 중간 수준 스케줄링은 고수준 스케줄링과 저수준 스케줄링 사이에 일어나며 프로세스가 과부하가 걸리는 경우를 중지와 활성화로 전체 시스템의 활성화된 프로세스를 조절하여 과부하를 막음
    - 이는 프로세스의 상태 중 보류 상태에 해당하며 저수준 스케줄링이 원만하게 이루어지도록 완충하는 역할을 함

<br>

![SchedulingLevel1](./img/SchedulingLevel.png)

<br>

![SchedulingLevel2](./img/SchedulingLevel2.png)

<br>

### 1-3. 스케줄링의 목적
- CPU 스케줄링의 원래 목적은 모든 프로세스가 공평하게 작업하도록 하는 것으로 목적들은 다음과 같음
    - 공평성 : 모든 프로세스가 자원을 공평하게 배정받아야 하며 자원 배정 과정에서 특정 프로세스가 배제되어서는 안된다
    - 효율성 : 시스템 자원이 유휴 시간 없이 사용되도록 스케줄링을 하고 유휴 자원을 사용하려는 프로세스에는 우선권을 주어야 함
    - 안정성 : 우선순위를 사용하여 중요 프로세스가 먼저 작동학도록 배정함으로써 시스템 자원을 점유하거나 파괴하는 프로세스로부터 자원을 보호해야 함
    - 확장성 : 프로세스가 증가해도 시스템이 안정적으로 작동하도록 조치해야함. 또한 시스템 자원이 늘어나는 경우 시스템에 반영되도록 해야함
    - 반응 시간 보장 : 응답이 없는 경우 사용자는 시스템이 멈춘 것으로 가정하기 때문에 시스템은 적절한 시간 안에 프로세스의 요구에 반응해야함
    - 무한 연기 방지 : 특정 프로세스의 작업이 무한히 연기되어서는 안됨
- 보통은 모든 프로세스가 공평하게 CPU를 할당받아야 하나 시스템의 안정성과 효율성을 높이기 위해 우선순위의 프로세스가 존재하므로 CPU 스케줄러는 일정 부분 공평성을 희생함
- 일반적으로 운영체제 프로세스는 일반 프로세스보다 우선순위가 높고 일반 프로세스 간에도 우선순위가 존재

<br>

## 2. 스케줄링 시 고려 사항
### 2-1. 선점형 스케줄링과 비선점형 스케줄링
- CPU 할당을 빼앗을 수 있는 선점형과 뺏을 수 없는 비선점형 스케줄링이 존재
    - 선점형 스케줄링 : 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링 방식
    - 비선점형 스케줄링 : 어떤 프로세스가 CPU를 점유하면 다른 프로세스가 이를 빼앗을 수 없는 스케줄링 방식
- 선점형 스케줄링은 하나의 프로세스가 CPU를 독점할 수 없어 빠른 응답 시간을 요구하는 대화형 시스템이나 시분할 시스템에 적합하며 대부분의 저수준 스케줄러는 선점형 스케줄링 방식을 사용
- 선점형 스케줄링은 문맥 교환(Context Swiching)같은 부가적인 작업으로 낭비가 생기는 것이 단점
- 비선점형 스케줄링은 문맥 교환이 없어 작업량이 적고 낭비가 적다
- 비선점형 스케줄링은 사용시간이 긴 프로세스의 경우 짧은 여러 프로세스들이 기다리게 되어 전체 시스템의 처리율이 떨어지게되어 과거 일괄 작업 시스템에 사용하던 방식임

<br>

### 2-2. 프로세스 우선순위
- 프로세스간 중요도를 구분하기 위해 우선순위를 정하게되고 프로세스는 크게 커널 프로세스와 일반 프로세스로 나뉨
- 커널 프로세스는 일반 프로세스보다 우선순위가 높아 커널에 관련된 중요한 프로세스 작업을 처리함
- 우선순위가 높다는 것은 더 빨리 자주 실행된다는 의미로 일반 프로세스 또한 중요도가 다르기 때문에 우선순위가 존재
- 우선순위가 적당하지 못하고 지나치게 높다면 다른 프로세스보다 먼저 실행해야 하기 때문에 다른 프로세스의 실행속도에도 영향을 끼쳐 작업이 원할하게 이루어지지 않음

<br>

### 2-3. CPU 집중 프로세스와 입출력 집중 프로세스
- 프로세스는 생성 된 후 준비, 실행, 대기 상태를 거쳐 실행되는데 준비상태는 CPU를 할당받기 위해 기다리는 상태이므로 실제 작업이 일어나는 것은 실행 상태와 대기상태가 됨
- 실행 상태와 대기 상태 사이에서 CPU를 받아 실행하는 것을 CPU 버스트, 입출력 작업을 입출력 버스트라고 함
- 위의 작업 형태에 따라 CPU 집중 프로세스와 입출력 집중 프로세스로 나뉘게 됨
    - CPU 집중 프로세스 : 수학 연산과 같이 CPU를 많이 사용하는 프로세스. 즉 CPU 버스트가 많은 프로세스
    - 입출력 집중 프로세스 : 저장장치에서 데이터를 복사하는 일과 같이 입출력을 많이 사용하는 프로세스. 즉 입출력 버스트가 많은 프로세스
- 주로 해당 프로세스가 동시에 있을 경우 입출력 집중 프로세스를 먼저 실행 상태로 옮기는 것이 효율적인데 입출력 요구에 의해 대기 상태로 옮겨지므로 다른 프로세스가 CPU를 사용할 수 있기 때문
- 만약 CPU 집중 프로세스가 먼저 들어간다면 타임 슬라이스를 다 쓸 때까지 다른 프로세스가 실행되지 못함
- 그렇기 때문에 입출력 집중 프로세스가 우선순위가 높게하는 것이 좋고 해당 프로세스가 CPU 집중 프로세스보다 실행 상태에 먼저 들어가는 경우를 사이클 훔치기라고 함

<br>

### 2-4. 전면 프로세스와 후면 프로세스
- 주로 사용자의 입력같이 상호작용이 필요한 전면 프로세스와 입력이 필요없는 후면 프로세스로 구분된다
    - 전면 프로세스 : GUI를 사용하는 운영체제에서 화면의 맨 앞에 놓인 프로세스. 현재 입력과 출력을 사용하는 프로세스로 사용자와 상호작용이 가능하여 상호작용 프로세스라고도 함
    - 후면 프로세스 : 사용자와 상호작용이 없는 프로세스. 압축 프로그램처럼 사용자의 입력 없이 작동하기 때문에 일괄 작업 프로세스라고도 함
- 전면 프로세스는 사용자의 요구에 즉각 반응해야하지만 후면 프로세스는 상호작용이 없어 전면 프로세스의 우선순위가 더 높음

<br>

### 정리

|우선순위 높음|우선순위 낮음|
|:---:|:---:|
|커널 프로세스|일반 프로세스|
|전면 프로세스|후면 프로세스|
|대화형 프로세스|일괄 처리 프로세스|
|입출력 집중 프로세스|CPU 집중 프로세스|

<br>

## 3. 다중 큐

<br>

## 4. 스케줄링 알고리즘

<br>



<br>

### 면접 문제

1. 중간 수준 스케줄러와 저수준 스케줄러에서 실제로 작업이 일어나는 이유

2. 스케줄링 알고리즘에서 구분하는 방법을 주로 평균 대기 시간으로 보는 이유

3. 동기적 인터럽트와 비동기적 인터럽트의 주요 차이점

<br>