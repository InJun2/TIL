# 5. 트랜잭션과 잠금

### 독서 중 궁금해지는 내용
- MySQL 테이블 생성시 기본 사용 엔진
    - 5.5 부터 기본 스트리지 엔진이 InnoDB
- 네임드락은 Redis의 분산 락과 비슷한 기능을 제공한다고 생각이 드는 것 같음
    - 분산된 환경에서 동일한 락을 사용하여 동기화를 구현한 방법이 유사
    - Redis 외에도 Zookeeper, Hazelcast 등 외부 시스템을 사용하여 분산환경에서 분산락을 구현이 가능
- DML에서 네임드 락은 어떻게 사용하여 DML을 사용하는지
    - 네임드 락은 트랜잭션에서 사용되어 락을 얻었을 경우 DML 작업을 수행
- 자동증가 락 대신 가벼운 래치(뮤텍스)를 이용해 처리할 수도 있다는데 여기서 래치란?
    - 래치란 특정 조건이 충족될 때까지 다른 스레드를 대기시키는 동기화 기법
    - 자바에서는 초기값이 설정되고 해당 값이 0이 될 때까지 기다리는 카운트다운 매커니즘의 CountDownLatch 구현체가 존재
- auto_increment 잠금이 걸고 트랜잭션 롤백으로 레코드가 삽입되지 않으면 다음번 레코드는 다다음 인덱스를 가짐
    - auto_increment은 증가만 하기때문에 실제로 삽입된 레코드의 수와 auto_increment 값이 일치하지 않더라도 auto_increment 값은 변경되지 않음
- MySQL에서 B+ 트리를 사용하므로 인덱스의 잠금이 사용되는 쉬운 것 같음

<br>

### 간단정리
- DBMS에서는 생성, 수정, 삭제되는 레코드에 있어서 트랜잭션이 필요
    - ACID 속성을 제공해야함
        - 원자성(Atomicity) : 트랜잭션의 모든 연산이 일부가 성공하고 일부가 실패하는 것이 아니라, 모두 성공하거나 모두 실패해야 함을 의미
        - 일관성(Consistency) : 트랜잭션이 실행 전과 실행 후에 데이터베이스의 일관성이 유지되어야 함을 의미
        - 고립성(Isolaction) : 하나의 트랜잭션이 다른 트랜잭션으로부터 영향을 받지 않고 독립적으로 실행되어야 함
        - 지속성(Durability) : 트랜잭션이 성공적으로 완료된 후에 그 결과가 영구적으로 저장되어야 함을 의미
- MySQL 엔진 잠금
    - MySQL 엔진 잠금은 모든 스토리지 엔진에 영향을 끼침
    - MySQL 엔진에서는 테이블 락과 메타데이터락, 네임드 락이 존재
- 스토리지 엔진 잠금
    - 각 스토리지 엔진 간 상호 영향을 미치지 않음
- InnoDB의 레코드락은 실질적으로 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리됨
    - 인덱스가 존재하지 않아도 자동 생성된 클러스터 인덱스를 생성하여 잠금
- 트랜잭션 격리수준
    - READ UNCOMMITTED : 미확정 읽기, 가장 낮은 격리수준으로, 다른 트랜잭션이 커밋되지 않은 데이터를 읽을 수 있음 (DIRTY, NON-REPEATABLE READ 발생)
    - READ COMMITTED : 확정 읽기, 한 트랜잭션이 커밋된 데이터만 읽을 수 있어 DIRTY READ를 방지하나 같은 쿼리를 실행할 때 결과가 달라질 수 있음 (NON-REPEATABLE READ 발생)
    - REPEATABLE READ : 반복 가능 읽기, 한 트랜잭션이 읽은 데이터는 다른 트랜잭션이 수정할 수 없음. 한 번 읽은 데이터는 여러 번 읽어도 같은 결과지만 PHANTOM READ 발생
    - SERIALIZABLE : 직렬화 가능, 가장 높은 격리 수준으로 한 트랜잭션이 실행 중에 다른 트랜잭션의 작업에 영향을 받지 않음. DIRTY, NON-REPEATABLE, PHANTOM READ 발생하지 않으나 높은 격리수준으로 동시성이 낮아짐

<br>

## 연습문제
### 1. DBMS에서의 테이블 락과 자바의 객체 락의 공통점과 차이점은 무엇이 있을지?

<details>
<summary>정답</summary>

#### 공통점
- 자바에서 모든 객체는 내부적으로 모니터를 가지고 있고 모니터 내부적으로 락이 존재
    - 명시적으로 생성하거나 관리할 필요가 없어 암시적인 락이라고도 불리며 이는 모니터를 사용한 모니터 락임
    - Object 클래스의 wait(), notify(), notifyAll() 등의 동기화 관련 메서드를 통해 모니터를 사용
- 테이블 락도 마찬가지로 개별 테이블마다 묵시적으로 락을 가지고 있고 나아가서 InnoDB는 레코드 기반 잠금이 존재
- 위의 기능 모두 객체나 데이터에 대해 일관성과 무결성을 유지하기 위한 방법

<br>

#### 테이블 락
- 테이블 락은 테이블이나 레코드 단위로 적용되며, 트랜잭션 간의 동기화를 위해 사용
- 데이터베이스 락은 디스크에 저장된 데이터를 보호하기 위함
- 주로 읽기 락과 쓰기 락으로 구분되어 특정 트랜잭션이 데이터를 수정할 때 일관성과 무관성을 유지

<br>

#### 자바 모니터 락
- 자바의 모니터 락은 객체 단위로 적용되며, 스레드 간의 동기화를 위해 사용
- 자바 모니터 락은 주로 메모리 내에서 작동
- 객체의 동기화 영역에 대한 락을 설정하므로 여러 스레드가 해당 객체의 영역에 접근하는 것을 제어

</details>

<br>

<br>

### 2. InnoDB 테이블 락에서는 레코드 기반 잠금을 제공하는데 인덱스로 잠그는 이유

<details>
<summary>정답</summary>

#### 인덱스 잠금 이유
- 테이블 락보다 레코드로 잠그는 이유는 트랜잭션의 범위가 줄어들어 동시성이 향상됨
- 더 작은 범위의 잠금이 가능
    - A 테이블 내에서 1~5 레코드가 있다고 할때 1레코드가 테이블 락으로 잠근다면 다른 레코드에서 테이블 락을 사용할 수 없음
    - 레코드 락은 해당 레코드 접근에만 락을 사용하므로 다른 레코드를 동시에 사용하기 용이
- 인덱스 잠금을 통한 쿼리 성능 향상
    - 인덱스를 사용한 레코드 잠금은 특정 레코드를 잠그는데 있어 특정 단어로 검색한다면 모든 레코드를 조회하는 풀 스캔 검색이 필요한데 이는 매우 큰 비용 발생
    - 인덱스가 있다면 해당 인덱스가 설정된 테이블에서 조회하므로 빠르게 검색이 가능
    - 인덱스가 없어도 InnoDB 스토리지 엔진은 데이터 저장 관리에 B+ 트리 구조를 사용하므로 실제 데이터는 리프 노드에 저장되고 설정됨. 즉 리프 노드에 대해 레코드 락이 설정됨 (기존 구조에 락을 적용)
- 인덱스 잠금으로 레코드에 대한 모든 접근이 일관성을 유지
    - 인덱스를 사용하여 레코드를 식별하고 락을 사용하다면 해당 레코드에 대한 모든 작업은 동일한 락을 획득하게 되어 일관성이 유지됨

</details>

<br>

### 스터디를 진행하면서
- [Spring Transactional 황하림님 정리](https://magnetic-crow-9f1.notion.site/DB-cf3899644db848b4b466f8de7159ad06?pvs=4)

<br>