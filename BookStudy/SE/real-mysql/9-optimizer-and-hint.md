# 옵티마이저와 힌트

### 1주차 생각해볼만한 부분
- InnoDB 스토리지 엔진의 백그라운드 스레드가 연속된 페이지를 읽는 리드 어헤드 (Read ahead) 작업
  - 어떤 영역의 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB의 버퍼 풀에 가져다 두는 것
  - innodb_read_ahead_threshold 시스템 변수를 이용해 InnoDB 스토리지 엔진이 언제 어헤드를 시작할지 임계값을 설정할 수 있음 ( 시스템 변수에 설정된 개수만큼 연속된 페이지가 읽히면 버퍼 풀에 적재 )
- InnoDB는 테이블 풀 스캔을 진행할 때 디스크로부터 페이지를 여러개 읽어온다
  - 테이블 풀 스캔이 실행되면 처음 몇 개의 데이터 페이지는 포그라운드 스레드가 페이지 읽기를 실행하지만 특정 시점부터는 읽기 작업을 백그라운드 스레드로 넘김
  - 하지만 몇개를 읽을지 설정하는 시스템 변수는 없고 백그라운드 스레드가 읽기를 넘겨받는 시점부터 한 번에 4개 또는 8개씩 읽으면서 계속 그 수를 증가시켜 최대 64개의 데이터 페이지까지 읽어 버퍼 풀에 저장함
  - 포그라운드 스레드는 해당 버퍼 풀에 준비된 데이터를 가져다 사용하기만 하면되므로 상당히 빨리 처리됨
- select count(*) from employees; 처럼 테이블의 레코드 건수를 조회하면 풀 테이블 스캔 대신 풀 인덱스 스캔을 하게될 가능성이 높음
- 원 패스, 투 패스 정렬 방식이란?
- 네스티드-루프 조인 방식이란?
  - 한 테이블의 각 행을 다른 테이블의 각 행과 비교하여 조인 조건을 만족하는지 확인하는 방식
- 정렬 처리 방식
  - 스트리밍 방식 : 쿼리를 처리하는 동안 실시간으로 레코드를 사용자에게 전송
  - 버퍼링 방식 : ORDER BY, GROUP BY 를 사용한 쿼리는 조건에 일치하는 모든 레코드를 가져온 후 정렬하거나 그루핑해서 차례대로 보내야하므로 결과를 모았다가 사용자에게 전송
- 드라이빙 테이블과 드리븐 테이블이란 및 임시 테이블이란?

<br>

### 1주차 생각해볼만한 부분
- 해시조인과 네스티드 루프 조인 동작 차이 및 각각 어떤 경우에 사용하는지



<br>

### 세미조인
세미 조인이란 다른 테이블에서 조건이 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리
- 세미 쿼리 최적화 방법은 세미 조인 형태의 쿼리와 안티 세미 조인 형태의 쿼리에 차이가 존재
  - 해당 책에서는 최근 도입된 세미 조인 최적화에서만 살펴보았음
- 세미 조인 쿼리 최적화 방법
  - 세미 조인 최적화
  - IN-to-EXISTS 최적화
  - MATERIALIZATION 최적화
- 안티 세미 조인 쿼리 최적화
  - IN-to-EXISTS 최적화
  - MATERIALIZATION 최적화
- 이 중 세미 조인 최적화는 아래 최적화 전략들을 모아 세미 조인 최적화라고 부름
  - Table Pull-out
  - Duplicate Weed-out : materialization 옵티마이저 옵션으로 사용 여부 결정
  - First Match : firstmatch 옵티마이저 옵션으로 사용 여부 결정
  - Loose Scan : loose scan 옵티마이저 옵션으로 사용 여부 결정
  - Materialization : materialization 옵티마이저 옵션으로 사용 여부 결정

```sql
-- 세미 조인 최적화 차이
SELECT *
FROM employees e
WHERE e.emp_no IN
  (SELECT de.emp_no FROM dept_emp de WHERE de.from_date='1995-01-01');
-- 해당 경우 세미조인이 최적화 되어있지 않다면 mysql에서는 employ를 풀 테이블 스캔하면서 서브쿼리가 일치하는 경우를 비교하므로 매우 낮은 성능
-- 세미 조인 최적화의 경우 서브쿼리를 먼저 가져오고 가져온 데이터에서 쿼리 처리 진행
```

<br>

### 테이블 풀-아웃 (Table Pull-out)
- 세미 조인의 서브쿼리에 사용된 테이블을 아우터 쿼리로 끄집어낸 후에 쿼리 를 조인 쿼리로 재작성하는 형태
- 사용 가능하면 항상 세미 조인보다 좋은 성능을 내어 별도 제어하는 옵티 마이저 옵션을 제공하지 않음
- 실행 계획에서 가장 중요한 부분은 id 칼럼의 값이 1이라는 것
- 해당 최적화가 되었는지 확인하는 가장 간단한 방법은 EXPLAIN 명령을 실행한 직후 SHOW WARNINGS 명령으로 업티마이저가 재작성한 쿼리를 살펴보는 것
  - IN(subquery) 형태가 사라지고 JOIN으로 쿼리가 재작성 되어 있음
- 테이블 풀-아웃 최적화의 몇 가지 제한 사항과 특성은 다음과 같음
  - Table pullout 최적화는 세미 조인 서브쿼리에서만 사용 가능
  - Table pullout 최적화는 서브쿼리 부분이 UNIQUE 인덱스나 프라이머리 키 룩업으로 결과가 1건인 경우에만 사용 가능
  - Table pullout 이 적용된다고 하더라도 기존 쿼리에서 가능했던 최적화 방법이 사용 불가능한 것은 아니므로 MySQL에서는 가능하다면 Table pullout 최적화를 최대한 적용함
  - Table pullout 최적화는 서브쿼리의 테이블을 아우터 쿼리로 가져와서 조인으로 풀어쓰는 최적화를 수행하는데, 만약 서브쿼리의 모든 테이블이 아우터 쿼리로 끄집어 낼 수 있다면 서브쿼리 자체는 없어짐
  - MySQL에서는 "최대한 서브쿼리를 조인으로 풀어서 사용해라"라는 튜닝가이드가 많은데 Table pullout 최적화는 이 가이드를 그대로 실행하는 것

```sql
EXPLAIN
SELECT * FROM employees e
WHERE e.emp_no IN (SELECT de.emp_no FROM dept_emp de WHERE de.dept_no='d009');
```

<br>

### 중복 제거

<br>

### 퍼스트 매치
- In(subquery) 형태의 세미 조인을 EXIST(subquery) 형태로 튜닝한 것과 비슷한 방법으로 실행됨
- 마찬가지로 눈여겨봐야할 부분은 실행 계획에서 id 칼럼의 값이 1이라는 것
  - 또한 Extra 칼럼에는 "FirstMatch(e)"라는 문구가 출력됨


<br>

### 루스 스캔

<br>

### 구체화

<br>

### 스토리지 엔진이 MEMORY에서 TempTable로 변경된 이유
- 이전 버전의 MySQL 서버에서는 메모리에 생성되는 임시테이블은 MEMORY 스토리지 엔진을 사용했으나 가변 길이 칼럼을 지원하지 않아 메모리를 과도하게 사용하는 문제점이 있었고 MyISAM 스토리지 엔진은 트랜잭션을 지원하지 않는 문제 발생
- 8.0 버전 이후는 메모리에 생성되는 임시 테이블을 위해 TempTable 이라는 새로운 스토리지 엔진이 도입됬고 임시 테이블에 대해서는 InnoDB 스토리지 엔진이 사용되도록 개성됨
  - 메모리에 만들어지는 임시 테이블은 가변 길이 칼럼을 지원하고 디스크 임시 테이블도 트랜잭션을 지원하고 MyISAM 보다 더 나은 성능으로 처리 가능

<br>

### 세미조인 방식 표

| 방식                     | 설명                                                                          | 옵티마이저 옵션                     | 임시 테이블 생성 여부                   |
|--------------------------|-------------------------------------------------------------------------------|------------------------------------|-----------------------------------------|
| **Table Pull-out**       | 서브쿼리를 상위 쿼리로 변환하여 직접 조인                                      | 없음                               | 필요에 따라 임시 테이블 생성 가능        |
| **Duplicate Weed-out**   | 조인 후 중복된 결과를 제거하여 최적화                                          | `materialization`                  | 중복 제거를 위해 임시 테이블 생성 가능   |
| **First Match**          | 조인 조건을 만족하는 첫 번째 행을 찾으면 더 이상 검색하지 않음                 | `firstmatch`                       | 필요 없음                               |
| **Loose Scan**           | 조인 조건을 효율적으로 스캔하여 부분 범위 검색                                  | `loosescan`                        | 필요 없음                               |
| **Materialization**      | 서브쿼리를 실행하여 결과를 임시 테이블에 저장하고, 이를 기반으로 조인           | `materialization`                  | 임시 테이블 생성                        |

<br>

### 기타 최적화 기술

| 기술                      | 설명                                                                                      |
|---------------------------|-------------------------------------------------------------------------------------------|
| **컨디션 팬아웃 (Condition Fanout)** | 복잡한 쿼리 조건을 간단한 여러 조건으로 분할하여 개별적으로 처리하고, 그 결과를 결합하여 최적화 |
| **파생 테이블 머지 (Derived Table Merge)** | 서브쿼리를 상위 쿼리와 병합하여 최적화, 필요에 따라 임시 테이블을 생성할 수 있음              |
| **인비저블 인덱스 (Invisible Index)** | 인덱스를 비활성화하여 옵티마이저가 인덱스를 무시하게 하고, 필요한 경우 다시 활성화하여 사용  |

<br>

### Materialization vs 파생 테이블 머지(Derived Table Merge) 차이

| 기준                      | Materialization                                                  | 파생 테이블 머지 (Derived Table Merge)         |
|---------------------------|------------------------------------------------------------------|------------------------------------------------|
| **설명**                  | 서브쿼리 결과를 임시 테이블에 저장하여 최적화                    | 서브쿼리를 상위 쿼리와 병합하여 최적화         |
| **임시 테이블 생성 여부** | 임시 테이블 생성                                                | 필요에 따라 임시 테이블 생성 가능              |
| **사용 사례**             | 서브쿼리 결과를 여러 번 사용할 때 효율적                        | 서브쿼리가 상위 쿼리로 쉽게 병합될 수 있을 때  |
| **예제**                  | `SELECT * FROM (SELECT dept_id FROM departments) AS dept_ids;`  | `SELECT emp.* FROM employees emp WHERE emp.dept_id IN (SELECT dept_id FROM departments WHERE location = 'New York');` |

<br>

## 연습문제

### 1. 드라이빙 테이블과 드리븐 테이블이란?

<details>
<summary>정답</summary>

- 드라이빙 테이블과 드리븐 테이블이란 용어는 조인 연산의 실행 계획과 관련이 있는데 주로 쿼리 최적화와 실행 계획을 이해할 때 사용됨
- 드라이빙 테이블과 드리븐 테이블을 결정하는 조건은 데이터베이스 옵티마이저가 쿼리 실행계획을 세우는 과정에서 사용되며 기준은 다음과 같음
  - 테이블 크기 : 일반적으로 작은 테이블이 드라이빙 테이블로 선택됨. 이후에 조인 연산에서 더 작은 데이터 세트를 기반으로 하여 처리하여 성능이 향상
  - 인덱스 사용 가능성 : 해당 쿼리의 조건에 적절한 인덱스를 가지고 있는 테이블로 선택될 가능성이 높으며 인덱스를 사용하여 특정 행을 빠르게 찾을 수 있어 성능이 향상
  - 조건 필터링 : 필터링 조건이 많은 행을 제외할 수 있는 테이블이 드라이빙 테이블로 선택됨. 이는 드라이빙 테이블이 작은 결과 세트를 생성하여 드리븐 테이블과의 조인 작업을 최적화에 도움을 줌
  - 그 외에는 조인의 유형과 순서, 통계 정보를 통해 드라이빙 테이블을 선택할지 결정함. 해당 조건은 위의 조건들을 포함하였을 때 조인의 유형과 순서, 통계에 따라 추가적으로 드라이빙 테이블을 선택하는 요인이 됨

#### 드라이빙 테이블 (Driving Table)
- 조인 연산에서 먼저 접근하는 테이블
- 주로 더 작은 테이블이나 조건에 맞는 인덱스를 사용하는 테이블이 선택됨
- 쿼리 실행 시 가장 먼저 처리되며 다른 테이블과의 조인 시 기준이 됨

<br>

#### 드리븐 테이블(Driven Table)
- 드라이빙 테이블과 조인되는 테이블
- 드라이빙 테이블의 결과와 결합되어야 하며, 더 큰 테이블이 선택되는 경우가 많음
- 드라이빙 테이블에서 검색된 각 행에 대해 반복적으로 접근됨

</details>

<br>

### 2. 임시 테이블이란?

<details>
<summary>정답</summary>

- 데이터베이스에서 쿼리 실행 중에 일시적으로 데이터를 저장하고 조작하기 위해 사용되는 테이블
- 드라이빙 테이블과 드리븐 테이블의 조인 과정에서도 임시 테이블이 생성될 수 있음

#### 임시 테이블의 역할
- 중간 결과 저장
  - 복잡한 쿼리의 중간 결과를 저장하기 위해 임시 테이블을 사용하여 여러번의 동일한 계산 방지
- 성능 최적화
  - 복잡한 조인이나 서브쿼리의 결과를 임시 테이블에 저장한 후, 이를 기반으로 추가 연산을 수행하면 성능이 향상될 수 있음
- 스코프 제한
  - 임시 테이블은 세션 단위로 생성되며, 세션이 종료되면 자동으로 삭제되므로 다른 세션이나 사용자에게 영향을 미치지 않음

<br>

#### 임시 테이블 사용 예시
- 큰 테이블의 데이터를 부분적으로 조작할 때
- 서브쿼리 결과를 저장하고 이를 재사용할 때
- 집계 함수 결과를 임시 저장하고 후속 처리할 때

<br>

#### 임시 테이블이 필요한 쿼리
- ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
- ORDER BY나 GROUP BY에 명시된 칼럼이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
- DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
- UNION이나 UNION DISTINCT가 사용된 쿼리
- 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리

<br>

#### 메모리 임시테이블과 디스크 임시 테이블
- 메모리 임시테이블은 메모리에 저장되어 작동하므로 매우 빠른 읽기/쓰기 성능을 제공
- 디스크 임시테이블은 시스템의 디스크에 저장되어 디스크 I/O에 의존하므로 느리지만 대용량의 데이터 세트를 처리할 때 사용됨

</details>

<br>

### 3. 해시조인과 네스티드 루프 조인 동작 차이 및 각각 어떤 경우에 사용하는지

<details>
<summary>정답</summary>

- 모두 조인을 최적화하는 중요한 역할을 하며 상황에 따라 적절한 방법을 선택할 수 있음

### 해시 조인
- 해시 조인은 해시 테이블을 사용하여 두 테이블을 조인하는 방법 ( 시간 복잡도 O(N + M) )
- 보통 네스티드 루프 조인보다 응답속도가 부족하지만 최종 레코드를 찾는 데까지는 시간이 많이 걸리지 않음
  - 최고 스루풋 전략에 적합
- 동작 방식
  1. 빌드 단계 : 작은 테이블(일반적으로 왼쪽 테이블)의 각 행에 대해 해시 테이블(=빌드테이블)을 생성. 조인 키를 해싱하여 해시 테이블에 저장
  2. 프로브 단계 : 큰 테이블(일반적으로 오른쪽 테이블)의 각 행에 대해 해시 테이블을 탐색(probe)하여 조인 조건을 만족하는지 확인
  3. 조인 : 해시 테이블에서 일치하는 행들을 결합

#### 주요 사용 예시
- 조인 조건이 동일한 키를 사용하는 경우
- 조인 키에 인덱스가 없는 경우
- 두 테이블이 모두 큰 경우, 특히 인덱스가 없는 경우

<br>

### 네스티드 루프 조인
- 두 테이블을 조인할 때 사용하는 기본적인 방법 ( 시간 복잡도O(N * M) )
- 보통 해시 조인보다 응답속도가 빠르지만 최종 레코드를 찾는 데까지는 시간이 더 걸림
  - 최고 응답 속도 전략 적합 ( 주로 웹서비스 온라인 트랜잭션 )
- 동작 방식
  1. 외부 루프 : 하나의 테이블(외부 테이블)의 각 행에 대해 반복
  2. 내부 루프 : 외부 테이블의 각 행에 대해, 다른 테이블(내부 테이블)의 모든 행과 비교하여 조인 조건을 만족하는지 확인
  3. 조인 : 조인 조건을 만족하는 행들을 결합

#### 주요 사용 예시
- 두 테이블 중 하나 또는 둘 다 매우 작은 경우
- 해시 조인이나 소트 머지 조인으로 처리하기 어려운 복잡한 조인 조건이 있는 경우
- 내부 테이블에 조인 키에 대한 인덱스가 있는 경우 성능이 향상될 수 있음

</details>

<br>

### 4. 쿼리 힌트란 무엇이고 주로 어떤 것을 사용하는지, 그 이유는 무엇인지?

<details>
<summary>정답</summary>

- 쿼리 힌트란 MySQL 서버가 부족한 실행계획을 수립할 경우 SQL 쿼리에서 데이터베이스 옵티마이저에게 특정 방식으로 쿼리를 실행하도록 지시하는 방법
- MySQL 서버에서 사용 가능한 쿼리 힌트는 다음과 같음
  - 인덱스 힌트
  - 옵티마이저 힌트
- 주로 옵티마이저 힌트를 사용하며 이유는 다음과 같음
  - 기존 인덱스 힌트는 MySQL 서버에 옵티마이저 힌트가 도입되기 전에 사용되던 기능 들으로 모두 SQL 문법에 맞게 사용해야하는데 사용하면 ANSI-SQL 표준 문법을 준수하지 못하게됨
  - 5.6 버전부터 가능해진 옵티마이저 힌트는 MySQL 서버를 제외한 다른 RDBMS는 주석으로 해석하여 ANSI-SQL 표준을 준수하기 때문
  - 또한 인덱스 힌트는 SELECT 명령과 UPDATE 명령만 할 수 있는데 반해 옵티마이저 힌트는 조인 방식, 조인 순서, 병렬 처리 등 더 광범위한 실행 계획 요소를 제어할 수 있어, 더 세밀하고 다양한 최적화가 가능함

| 기준                  | 인덱스 힌트                                                              | 옵티마이저 힌트                                                            |
|-----------------------|--------------------------------------------------------------------------|---------------------------------------------------------------------------|
| **목적**              | 조인 순서 변경 및 특정 인덱스를 사용하거나 무시하도록 옵티마이저에게 지시                  | 조인 방식, 조인 순서, 병렬 처리 등 다양한 실행 계획 요소를 제어            |
| **사용 사례**         | - 특정 인덱스 사용 강제 - 인덱스 무시 - 복합 인덱스 선택         | - 조인 방식 지정 - 조인 순서 강제 - 병렬 처리 제어 - 비용 모델 조정 |
| **제어 범위**         | 주로 인덱스 선택에 집중                                                  | 인덱스 선택을 포함한 실행 계획의 여러 요소를 제어                          |
| **예제**              | `/*+ INDEX(emp emp_idx) */` `/*+ IGNORE INDEX(emp emp_idx) */`       | `/*+ USE_NL(emp dept) */` `/*+ PARALLEL(emp 4) */`                   |
| **주요 이점**         | - 인덱스를 강제로 사용하여 성능 최적화 가능 - 잘못된 인덱스 선택 방지 | - 더 세밀한 제어 가능 - 다양한 최적화 옵션 제공                       |
| **한계**              | - 인덱스 사용에만 국한됨 - 인덱스가 없으면 효과 없음                 | - 잘못된 힌트 사용 시 성능 저하 가능 - 인덱스 사용 강제는 간접적       |
| **추가 정보**         | 기존 인덱스 힌트는 MySQL 서버에 옵티마이저 힌트가 도입되기 전에 사용되던 기능으로 모두 SQL 문법에 맞게 사용해야하며, 사용하면 ANSI-SQL 표준 문법을 준수하지 못하게 됨 | 5.6 버전부터 가능해진 옵티마이저 힌트는 MySQL 서버를 제외한 다른 RDBMS는 주석으로 해석하여 ANSI-SQL 표준을 준수하기 때문 |


<br>

### 옵티마이저 힌트 기능
1. 잘못된 실행 계획 수정
  - 옵티마이저가 통계 정보나 히스토그램 등의 이유로 비효율적인 실행 계획을 선택할 때, 힌트를 사용하여 더 나은 실행 계획을 강제
  - 인덱스를 사용하지 않거나, 적절한 조인 순서를 선택하지 않는 경우 힌트를 통해 이를 수정할 수 있음 (조인 순서 강제)
2. 특정 인덱스 사용 강제
  - 특정 인덱스를 사용하여 쿼리 성능을 향상시킬 수 있는 경우, 해당 인덱스를 사용하도록 옵티마이저에게 지시 가능
  - 이는 특히 인덱스가 많거나, 옵티마이저가 기본적으로 선택하지 않는 인덱스를 사용하고자 할 때 유용
3. 조인 방식 지정
  - 특정 조인 방식을 사용하도록 옵티마이저에게 지시 가능
  - 해시 조인, 네스티드 루프 조인, 소트 머지 조인 등을 명시적으로 지정할 수 있음
4. 병렬 처리 제어
  - 대용량 데이터 집합을 처리할 때, 병렬 처리를 사용하여 쿼리 성능을 향상 가능
  - 힌트를 사용하여 병렬 처리의 정도를 조절할 수 있음
5. 캐시 제어
  - 쿼리 실행 시 특정 테이블이나 인덱스를 캐시에서 읽도록 강제하거나, 반대로 캐시를 사용하지 않도록 지시할 수 있음
  - 특정 쿼리의 성능을 최적화하거나, 시스템 리소스를 효율적으로 사용하기 위해 사용될 수 있음

</details>

