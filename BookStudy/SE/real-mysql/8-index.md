# 8. 인덱스

### 독서 중 궁금해지는 내용
- 인덱스 키는 그럼 자주 검색되는 속성으로 지정해야한다?
    - InnoDB 스토리지 엔진 테이블에서는 프라이머리 키가 ROWID 역할을 한다?
    - MyISAM 테이블은 세컨더리 인덱스가 물리적인 주소를 가지지만 InnoDB 테이블은 프라이머리 키를 주소처럼 사용하여 논리적인 주소를 가진다고 볼 수 있음
- 테이블의 레코드를 저장하거나 변경하는 경우 인덱스 키 추가나 삭제 작업이 발생한다는데 변경에서는 왜 인덱스 키에 관련이 있는지?
    - 삭제는 기존 인덱스 키 공간을 마킹만하고 그대로 방치할 수도 있고 삭제하여 재사용할 수 있음
    - 인덱스 키 값에 따라 리프노드의 위치가 결정되므로 키 값이 변경된다면 먼저 키를 삭제한 후 다시 새로운 키 값을 추가하는 형태로 처리됨
- 새로운 레코드 키 추가로 리프노드가 꽉차서 리프노드가 분리(split) 되어 처리되는 과정
1. 리프 노드 오버플로우 확인
    - 새로운 레코드 키가 리프 노드에 추가되어 노드가 가득 차면, 노드 오버플로우(overflow)가 발생. 이는 해당 노드에 추가할 수 있는 최대 키의 개수를 초과하는 경우
2. 분할(Division) 작업
    - 노드 오버플로우가 발생하면, 해당 노드를 분할하여 두 개의 새로운 노드로 나눔. 이 과정이 분할
    - 분할은 오버플로우가 발생한 노드에서 중간값(Median)을 찾아 이를 기준으로 두 개의 새로운 노드로 나누는 과정임
3. 중간값 추출
    - 분할을 위해 오버플로우 노드에서 중간값을 추출. 이 중간값은 새로운 노드를 나누는 기준이 됨
4. 새로운 노드 생성
    - 중간값을 기준으로 새로운 두 개의 노드를 생성
    - 중간값보다 작은 키들은 하나의 노드에, 중간값보다 큰 키들은 다른 하나의 노드에 배치
5. 부모 노드 갱신:
    - 분할로 생성된 두 개의 새로운 노드를 부모 노드에 연결
    - 만약 부모 노드가 없는 경우(루트 노드인 경우), 새로운 루트 노드를 생성하고 분할로 생성된 두 개의 노드를 자식 노드로 설정
    - 부모 노드가 있을 경우, 새로운 노드들을 부모 노드에 연결하고 중간값을 부모 노드에 추가
6. 재귀적인 처리
    - 부모 노드에 새로운 노드들이 추가되면, 부모 노드도 오버플로우가 발생할 수 있음. 이 경우에도 분할 작업이 수행되어야 하며, 이는 부모 노드에 대해서 재귀적으로 처리
- 체인지 버퍼는 디스크에 있는 실제 인덱스 페이지를 즉시 업데이트하는 대신, 변경 내용을 임시로 버퍼에 저장하고 나중에 필요한 시점에 일괄적으로 디스크에 적용하는 방법으로 DB 쓰기 성능을 향상하고 인덱스 페이지의 변경 작업을 효율적으로 처리
- 프라이머리키가 아닌 WHERE 절 검색은 어떻게 동작하는지?
    - 플 테이블 스캔
- 인덱스를 사용하기 좋은 기준은 풀 테이블 스캔보다 읽어야할 레코드 수(옵티마이저가 판단한 예상 건 수) 보다 20~25% 적어야하는 이유
    - 문제로 출제
- B-Tree 인덱스 사용에 영향을 미치는 요소는 인덱스를 구성하는 칼럼의 크기와 레코드의 건수, 유니크한 인덱스 키 값의 개수
    - 인덱스를 구성하는 칼럼의 크기
        - 칼럼의 크기가 클수록 인덱스 키의 크기가 커지며 한 노드에 저장할 수 있는 인덱스 키의 개수를 감소시킴
        - 인덱스 키의 크기가 클수록 B-Tree의 높이가 증가하게 되고 인덱스를 탐색하는데 걸리는 시간이 증가됨
    - 레코드의 건수
        - 레코드의 건수가 많을수록 인덱스의 높이가 증가하고 인덱스를 탐색하는데 걸리는 시간이 증가됨
        - 하지만 B-트리는 평균적으로 높이가 낮고 균형 잡혀있으므로 성능저하가 극심하게 발생하지 않음
    - 유니크한 인덱스 키 값의 개수
        - 인덱스 키 값의 유니크한 개수가 적으면 각 노드에 포함되는 키 값의 개수가 많아질 수 있음
        - 유니크한 키 값의 개수가 많을수록 인덱스의 중복도가 낮아지기 때문에 불필요한 데이터를 찾는 양이 적어지고 효율적인 탐색을 가능하게함
- 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느린 이유
    - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
        - 대부분의 DB 시스템은 페이지 수준의 잠금을 사용하는데 인덱스는 일반적으로 키 순서대로 정렬되어 있어 역순의 경우 페이지 잠금을 역순으로 획득하고 해제하는데 복잡성을 증가됨
    - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조
        - 인덱스의 레코드는 보통 단방향 연결리스트로 구성되는데 역순 스캔은 뒤로 거슬로 올라가야 하므로 각 레코드의 이전 레코드를 가리키는 포인터를 찾아야함
- 다중 컬럼 인덱스는 먼저 정렬하는 인덱스 컬럼에 따라 찾아야하는 레코드 양이 달라지므로 순서가 중요함
    - 공식적인 명칭은 아니지만 해당 경우와 같이 작업의 범위를 결정하는 조건을 '작업 범위 결정 조건'이라고 함


<br>

### 1. 디스크 읽기 방식
- SSD는 기존 하드디스크 드라이브에서 데이터 저장용 플래터(원판)을 제거하고 플래시 메모리를 장착하여 물리적 동작이 없어 훨씬 빠름
    - 플래시 메모리 : 전원이 끊겨도 데이터를 유지할 수 있는 비휘발성 메모리의 일종 (종류로는 NAND, NOR 플래시 메모리가 존재)
- 데이터 성능 튜닝은 대부분 디스크 I/O를 줄이는 방향으로 이루어짐. 쿼리튜닝의 주요 목표는 랜덤 I/O를 줄이는 것으로 보통은 순차 I/O로 바꾸는 것
    - 랜덤 I/O : 데이터가 저장 장치의 임의의 위치에 접근하는 것을 의미하며 주로 작은 랜덤 데이터를 읽고 쓰는 작업에 유용
    - 순차 I/O : 데이터가 저장 장치의 연속된 위치에 접근하는 것을 의미하며 주로 디스크의 헤더를 움직이지 않고 한번에 많은 데이터를 읽는 작업에 유용
    - 데이터베이스는 보통 랜덤 I/O가 빈번하여 MySQL 서버에는 그룹 커밋이나 바이너리 로그 버퍼 또는 InnoDB 로그 버퍼 등의 기능이 내장되어 있음
    - 순차 I/O와 랜덤I/O 모두 파일 쓰기 실행 시 동기화가 필요하여 파일 동기화가 빈번하다면 비효율적인 형태로 처리될 때도 많을 수 있음 (해당 경우 RAID 컨트롤러의 캐시 메모리가 중요한 역할을 함)
- 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 I/O를 사용하고 풀 테이블 스캔은 순차 I/O를 사용

<br>

### 2. 인덱스란?
- 

<br>

## 연습문제

### 1. 인덱스를 사용하기 좋은 기준은 풀 테이블 스캔보다 읽어야할 레코드 수(옵티마이저가 판단한 예상 건 수) 보다 20~25% 적어야하는 이유

<details>
<summary>정답</summary>

- 랜덤 I/O 오버헤드
    - 인덱스 레인지 스캔에서 인덱스 키를 기준으로 레인지 스캔을 진행하여 정렬되어 있는 리프노드의 인덱스 키를 순차적으로 처리할 수는 있으나 해당 인덱스 키의 프라이머리 키를 통해 데이터에 하나하나 랜덤 I/O를 발생하기 때문
- 순차 I/O 효율성
    - 풀 테이블 스캔의 경우 모든 데이터를 순차적으로 읽기 때문에 순차 I/O 이며 연속된 디스크 블록을 읽어 매우 빠르기 때문
    - 인덱스를 사용하면 인덱스를 정렬해야하는 유지보수로 인해 오버헤드가 발생해 추가적인 비용이 발생함
- 데이터 테이블 캐시
    - 풀 테이블 스캔의 경우 연속된 블록으로 캐시 히트률이 높고 버퍼 풀에 캐싱되기 좋음
    - 인덱스 스캔은 랜덤 I/O로 인해 다양한 위치의 데이터 페이지를 읽어 캐시 효율이 떨어질 수 있음

- 결론
    - 인덱스 스캔의 효율성 : 인덱스 스캔은 특정 레코드나 소수의 레코드를 찾을 때 매우 효율적. 특히, 인덱스 유일 스캔은 특정 키를 빠르게 찾는 데 매우 유용
    - 풀 테이블 스캔의 효율성 : 풀 테이블 스캔은 많은 레코드를 읽어야 할 때 효율적. 이는 시퀀셜 I/O와 높은 캐시 효율성 덕분
    - 적절한 사용 기준 : 검색해야 할 레코드 수가 전체 테이블의 20~25% 이하일 때 인덱스를 사용하는 것이 효율적. 이를 초과하면 풀 테이블 스캔이 더 나은 성능을 보일 수 있음

</details>

<br>

### 2. 인덱스 풀 스캔은 리프노드의 인덱스 키를 순차적으로 조회하지만 결국 하나하나 랜덤 I/O가 발생하는데 이를 최적화하는 방법

<details>
<summary>정답</summary>

1. 인덱스 캐싱
- 자주 사용되는 인덱스를 메모리에 캐시하여 빠른 액세스를 지원하여 랜덤 I/O를 줄이고 성능을 향상함

2. I/O 연산 최적화
- DBMS에서 디스크 액세스를 최적화하는 다양한 기술을 사용함
- 인접한 블록을 함께 읽는 프리페칭(pre-fetching) 기술이나 쓰기 연산을 배치 처리하는 방법들이 존재

3. 인덱스 정렬 및 구조 최적화
- 인덱스의 물리적인 구조를 최적화하여 랜덤 I/O를 줄이는 방법이 있음
- 예를들면 클러스터드 인덱스(Clustered Index)는 데이터 행과 인덱스 키를 동시에 정렬하여 랜덤 I/O를 최소화할 수 있음

4. 압축 기술
- 압축을 통해 인덱스의 크기를 줄이고 압축된 작은 인덱스는 메모리에 더 많은 데이터를 캐시할 수 있음

</details>

