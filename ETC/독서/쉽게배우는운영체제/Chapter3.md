# CHAPTER3 프로세스와 스레드

## 1. 프로세스의 개요
```
프로그램 : 하드디스크 같은 저장 장치에 보관되어 있는 파일들의 집합. 프로그램이란 어떤 데이터를 사용하여 어떤 작업을 할지 그 절차를 적어놓은 것
프로세스 : 해당 프로그램이 메모리에 올라와서 작업이 시작된 프로그램. 프로그램이 작업을 진행하기 위해 메모리에 올라온 상태로 실행하는 것. 프로세스는 컴퓨터 작업 단위로 테스크(task)라고도 부름
```

### 운영체제의 프로세스는 요리사 모형에 비유
- 운영체제에서 각 프로세스는 여러 상태를 가지는데 요리사 모형으로 보면 해당 단계로 나눔
    - 재료를 준비하고 다듬는 단계
    - 재료를 볶거나 튀기는 등 조리를 하는 단계
    - 완성된 음식을 그릇에 담는 단계

#### 일괄처리 방식의 요리
- 한번에 하나의 요리만 처리하므로 레스토랑에 테이블이 하나 있는 것이나 다름없음
- 손님이 식사를 마치고 나간후에야 다음 손님을 받을 수 있음
- 한번에 한가지 요리만 만들면 되기 때문에 요리 제공 순서가 단순하고, 손님이 식사하는 동안 다음 손님을 받을 수 없어 작업 효율 떨어짐
- 일괄 처리 방식에서 주문서가 도착한 순서대로 요리를 하기 위한 '주문 목록'을 받아 처리한다고 가정
    - 여기서 주문 목록은 'Queue'로 처리

<br>

#### 시분할 방식의 요리
- 테이블이 여러 개 있는 레스토랑에서 일괄 작업 방식으로 요리를 하면 비효율적
- 시분할 방식으로 손님이 식사하는 동안 다른 손님의 요리를 만들어 처리
    - 요리사는 1명이지만 시간을 적당히 배분하여 여러 가지 요리를 동시에 하는 시분할 방식은 효율적
    - 요리사가 여러명 있는 것처럼 요리 제공이 가능, 이는 CPU가 1개인 컴퓨터에서 여러 프로세스를 동시에 실행하는 것과 같은 원리
- 주문서는 아주 중요한 역할. 손님에게 모든 요리가 제공될 때까지 주문서에는 손님의 요구 사항, 현재 상황 등이 나타나 있음
    - 주문서가 주문 목록에 올라온다는 것은 요리의 시작을 의미
    - 주문서는 코스요리 중 어떤 요리가 손님에게 제공되었고 앞으로 어떤 요리를 만들어야하는지가 표기
    - 요리하는 동안 주문서는 주문 목록에서 대기하거나 요리사가 요리하는 상태를 왕복
    - 모든 요리가 제공되면 주문서는 주문 목록에서 삭제

#### 시분할 방식의 예상치 못한 상황 처리
- 손님의 주문을 처리하다 보면 예상치 못한 상황에 처하게 됨
- 예시 : 새우튀김을 해야하는데 새우가 아직 손질되지 않았음
    - 요리사는 보조 요리사에게 새우를 손질하라고 지시하고, 순서를 중요시하는 요리사는 새우 손질이 끝날때 까지 다른 요리를 하지 않고 기다림
    - 바쁜 와중 요리사가 아무것도 하지않고 기다리는 것은 비효율적, 현명한 요리사는 그 주문서를 주방 한쪽의 '대기 목록'으로 옮기고 주문 목록에 있는 다른 주문서를 가져와서 요리하여 작업의 효율성을 높임
    - 새우 손질이 끝났을 때 요리사가 요리를 하고 있다면, 해당 요리를 하다말고 다시 새우요리를 하는 것은 비효율적. 작업중인 요리를 끝내고 새우튀김을 만드는 것이 좋음
    - 즉, 따라서 새우 손질이 완료된 주문서는 대기 목록에서 주문 목록으로 이동하여 다음 순서를 기다림
- 예시 : 손님이 급한 볼일을 보느라 음식을 천천히 달라고 하는 경우. 이 경우 손님의 지연 요청은 언제 끝날지 알 수 없고, 또한 손님이 식사를 포기할 수도 있음
    - 이와 같이 언제 다시 시작될지 모르는 주문서는 '보류 목록'으로 옮기고 손님이 음식을 달라고 하면 보류 목록에 있는 주문서를 주문 목록으로 보냄
    - 만약 손님이 사정이 생겨서 식사를 중단하면 주문서를 폐기. 보류 목록의 작업은 언제 다시 시작될지 모르거나 중간에 그만둘지 모른느 것으로 대기 목록에 있는 작업과 구분
- 시분할 방식을 처리한 요리는 여러 목록을 옮겨 가면서 진행되는데 운영체제에서 프로세스 처리도 이와 유사
- 현대의 운영체제는 시분할 방식을 기본으로 사용하기 때문에 프로세스가 여러 상태를 오가며 실행됨

<br>

### 프로그램에서 프로세스로의 전환
- 운영체제는 프로그램을 메모리의 적당한 위치로 가져오고 그와 동시에 주문서에 해당하는 작업 지시서를 만드는데 이 작업 지시서가 프로세스 제어 블록(Process Control Block)
- 주문서에는 어떤 테이블에서 어떤 요리를 주문했는지, 손님의 특별 주문 사항은 무엇인지, 현재 어떤 단품 요리까지 제공되었는지 등과 같은 정보가 담겨 있음. 해당 지시서가 프로세스 제어 블록
- 프로세스 제어 블록에는 프로세스를 처리하는데 필요한 다양한 정보가 들어있음
- 프로세스 제어 블록의 다양한 정보중 대표적인 세가지는 다음과 같음
    - 프로세스 구분자
        - 메모리에는 여러 개의 프로세스가 존재하므로 각 프로세스를 구분하는 구분자 (IDentification ID) 가 필요
    - 메모리 관련 정보
        - CPU를 실행하려는 프로세스가 메모리의 어디에 저장되어 있는지 알아야 작업을 할 수 있음
        - 이를 위해 프로세스 제어 블록에는 프로세스의 메모리 위치 정보가 담겨 있음
        - 또한 메모리 보호를 위한 경계 레지스터와 한계 레지스터도 포함되어 있음
    - 각종 중간값
        - 프로세스 제어 블로겡는 프로세스가 사용했던 중간값이 저장되는데 이는 현재 어떤 단품요리 까지 손님에게 제공되었는지 주문서에 표시하는 것과 유사
        - 시분할 시스템에서는 여러 프로세스가 번갈아가며 실행되기 때문에 각 프로세스는 일정 시간 적업을 한 후 다른 프로세스에게 CPU를 넘겨줌
        - 예를 들면 한 프로세스가 103번 행까지 작업 후 다른 프로세스에게 CPU를 넘겨주고 다시 받았을 때 104번 행부터 작업을 시작해야 하는데 이를 위해 프로세스 제어 블록에는 다음에 작업해야할 코드의 위치가 담긴 레지스터인 프로그램 카운터가 저장됨
        - 또한 작업의 중간값을 보관중인 다른 레지스터도 같이 저장됨
- 주문서가 없으면 요리가 진행되지 않듯이 프로세스 제어 블록이 없으면 프로그램이 프로세스로 전환되지 못함
    - 즉 어떤 프로그램이 프로세스가 되었다는 것은 운영체제로부터 프로세스 제어 블록을 받았다는 의미 -> 프로그램이 프로세스가 된다는 것은 운영체제로부터 프로세스 제어 블록을 얻는다는 것
    - 프로세스가 종료되면 프로세스가 메모리에서 삭제되고 프로세스 제어 블록도 마찬가지로 폐기됨 -> 프로세스가 종료된다는 것은 프로세스 제어 블록이 폐기된다는 것
- 프로세스 제어 블록은 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조 이므로 운영체제 영역에 만들어짐
- 강조하고 싶은 점은 컴퓨터 내에는 사용자가 실행한 프로세스가 있는 것만이 아닌 운영체제 프로세스도 존재
    - 컴퓨터에는 일반 사용자의 사용자 프로세스(user process)와 운영체제의 커널 프로세스(kernel process)가 섞여서 실행됨

> 프로세스 : 프로그램 + 프로세스 제어 블록
> 프로그램 : 프로세스 + 프로세스 제어 블록

<br>

### 프로세스의 상태
- 운영체제에서도 여러가지 이유로 프로세스 상태(process status)가 변환됨
- 일괄 작업 시스템에서의 프로세스의 상태는 생성, 실행, 완료
- 시분할 시스템의 프로세스는 더욱 복잡. CPU를 얻어 실행중인 프로세스가 중간에 다른 프로세스에게 CPU를 넘겨주는 일이 빈번하기 때문
- 프로세스의 상태는 생성 상태 -> 준비 상태 -> 실행 상태 -> (대기 상태 -> 준비 상태 -> 실행 상태)  -> 완료 상태 로 구성
    - 생성 상태(create status)
        - 프로세스가 메모리에 올라와 실행 준비를 완료한 상태
        - 프로세스를 관리하는데 필요한 프로세스 제어 블록이 생성됨
    - 준비 상태(create status)
        - 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태
        - 컴퓨터에서는 한번에 하나의 프로세스만 실행할 수 있기 때문에 자기 실행 순서가 될 때까지 준비 상태에서 기다려야 함
        - 준비 상태에 있는 여러 프로세스 중 다음에 실행할 프로세스를 선정하는 일은 CPU 스케줄러가 담당
            - CPU 스케줄러는 준비 상태의 맨 앞에서 기다리고 있는 프로세스 제어 블록을 CPU에 전달해서 작업이 이루어지게 함
            - 준비 상태의 프로세스 중 하나를 골라 실행 상태로 바꾸는 CPU 작업을 디스패치(dispatch)라고 함
    - 실행 상태(running status)
        - 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태
        - 'execute status' 라고 표현하기도 함
        - 실행 상태에 들어간 프로세스는 일정 시간동안 CPU를 사용할 권리를 갖음
        - 만약 주어진 시간을 다 사용하고도 작업이 끝나지 않았다면 프로세스는 준비 상태로 돌아와 다음 차례를 기다림 
    - 완료 상태(terminate status)
        - 실행 상태의 프로세스가 주어진 시간동안 작업을 마치면 완료 상태로 진입
        - 완료 상태는 프로세스 제어 블록이 사라진 상태를 의미
    - 대기 상태(blocking status)
        - 이전에는 프로세스 단계에 대기 상태는 존재하지 않았으나 오늘날 운영체제의 효율성을 고려하여 만듦
        - 입출력을 요구한 프로세스가 입출력이 완료될 때까지 기다리는 상태
        - 작업의 효율성을 위해 입출력을 요청한 프로세스를 실행 상태에 두지 않고 대기 상태로 옮기는 것
        - 입출력을 요청한 프로세스가 대기 상태로 옮겨지면 CPU 스케줄러는 준비 상태에 있는 프로세스 중 하나를 가져다 실행 상태로 만듬 -> 효율성을 향상시킴

```
CPU 스케줄러
- 준비 상태의 맨 앞에서 기다리고 있는 프로세스 제어 블록을 CPU에 전달해서 작업이 이루어지게 함
- CPU 스케줄러에 의해 선택된 프로세스는 실행 상태에서 일정 시간 동안 작업을 하는데 프로세스에 배당된 작업 시간을 타임 슬라이스 또는 타임 퀀텀이라고 부름
- 프로세스가 자신에게 주어진 하나의 타임 슬라이스동안 작업을 끝내지 못했다면 다시 준비 상태로 돌아가는데 이것을 타임 아웃(time out)이라고 함
- CPU 스케줄러의 자세한 일은 4장에서 다룸

프로세스 작업
- dispatch(PID) : 준비 -> 실행
- timeout(PID) : 실행 -> 준비
- exit(PID) : 실행 -> 완료
- block(PID) : 실행 -> 대기
- wakeup(PID) : 대기 -> 준비

+ 상태
- 위의 프로세스 상태는 활성 상태(active status)라고 하는데 활성 상태 외에 휴식 상태, 보류 상태가 존재
- 휴식 상태(pause status)
    - 프로세스가 작업을 일시적으로 쉬고 있는 상태
    - 프로세스가 메모리에 있으나 멈춘 상태
    - 유닉스에서 프로그램을 실행하는 도중 ctrl + z 키를 누르면 볼 수 있음. 프로세스의 상태는 '정지'
- 보류 상태(suspend status)
    - 프로세스가 메모리에서 잠시 쫓겨난 상태로 '일시 정지 상태'
    - 보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 스왑 영역(swap status)로 임시로 보관됨
    - 프로세스가 메모리 밖 스왑 영역에 있는 상태
    - 보류 상태는 다음과 같음
        - 메모리가 꽉 차서 일부 프로세스를 메모리 밖으로 보낼 때
        - 프로그램에 오류가 있어서 실행을 미루어야 할 때
        - 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
        - 매우 긴 주기로 반복되는 프로세스라 메모리 밖으로 쫓아내도 큰 문제가 없을 때
```

## 2. 프로세스 제어 블록과 문맥 교환
- 프로세스 제어 블록은 프로세스를 실행 하는데 가장 필요한 중요한 정보를 보관하는 자료 구조
- 모든 프로세스는 고유의 프로세스 제어 블록을 가지며 프로세스 생성시 만들어지고 프로세스 실행 완료시 폐기됨

### 프로세스 제어 블록의 구성 (차례대로 구성)
- 포인터
    - 준비 상태나 대기 상태는 큐로 운영되는데 프로세스 제어 블록을 연결하여 준비 상태나 대기 상태의 큐를 구현할 때 포인터를 사용
    - 입출력이 완료되기를 기다리는 프로세스는 대기 상태로 모이는데 시스템 내에는 다양한 종류의 입출력장치가 있기 때문에 대기 상태로 모이는 프로세스도 다양한데 모든 프로세스를 뒤지지 않도록 대기 상태에는 같은 입출력을 요구한 프로세스끼리 모아놓음
- 프로세스 상태
    - 프로세스 상태에는 생성, 준비, 실행, 대기, 보류 준비, 보류 대기 등이 있음
    - 이는 프로세스가 현재 어떤 상태에 있는지를 나타냄
- 프로세스 구분자
    - 운영체제 내에 있는 여러 프로세스를 구별하기 위한 구분자를 저장
- 프로세스 카운터
    - 다음에 실행될 명령어의 위치를 가리키는 프로그램 카운터의 값을 저장
- 프로세스 우선순위
    - 프로세스의 중요도가 각각 다름
    - 사용자 프로세스보다 커널 프로세스는 우선순위가 높고 사용자 프로세스끼리도 우선순위가 다름
    - 다양한 우선순위 프로세스가 대기 상태로 들어오기 때문에 대기 상태의 큐도 우선순위 별로 따로 운영됨
    - CPU 스케줄러가 준비 상태에 있는 프로세스 중 실행 상태로 옮겨야 할 프로세스를 선택할 때는 프로세스 우선순위를 기준으로 삼음
    - 높은 우선 순위의 프로세스가 낮은 우선순위의 프로세스보다 먼저 실행되고 더 자주 실행됨
- 각종 레지스터 정보
    - 프로세스 제어 블록에는 프로세스가 실행되는 중에 사용하던 레지스터인 누산기, 색인 레지스터, 스택 포인터와 같은 레지스터의 값이 저장됨
    - 이전에 실행할 때 사용한 레지스터의 값을 보관해야 다음에 실행할 수 있기 때문에 자신이 사용하던 레지스터의 중간값을 보관함
- 메모리 관리 정보
    - 프로세스 제어 블록에는 메모리의 어디 있는지 나타내는 메모리 위치 정보, 메모리 보호를 위해 사용하는 경계 레지스터 값과 한계 레지스터 값 등이 저장됨
    - 그 외에 세크먼테이션 테이블, 페이지 테이블 등의 정보도 보관하는데 이는 8장에서 설명
- 할당된 자원 정보
    - 프로세스를 실행하기 위해 사용하는 입출력이나 오픈 파일 등에 대한 정보
    - 오떤 프로세스가 하드디스크에 저장된 파일을 열어서 작업하거나, 음악을 출력하기 위해 사운드 카드에 접근하고 있다면 파일이나 사운트카드에 대한 정보가 필요한데 이러한 정보를 저장
- 계정 정보
    - 계정 번호, CPU 할당 시간, CPU 사용 시간 등으로 이러한 정보를 저장
- 부모 프로세스 구분자와 자식 프로세스 구분자
    - 프로세스 제어 블록에는 부모 프로세스인 PPID(Parent PID)와 자식 프로세스를 가르키는 CPID(Child PID)정보도 저장
    - 프로세스를 이해하는데 매우 중요한 열쇠인 부모-자식 프로레스 관계는 밑에서 설명

<br>

### 문맥 교환(context switching)
- 요리사가 여러 주문서를 처리할 때 13번의 주문서의 새우 튀김을 만든 다음 14번의 등심 요리를 하는 과정으로 요리 작업의 전환 과정은 2개의 주문서를 교환(switching)함으로써 이루어짐
- 요리 작업을 전환할 때 주문서를 교환하는 것만이 아닌 해당 재료와 도구를 치우고 새로운 재료와 도구를 가져와야 함. 즉 전환 과정은 주문서를 바꾸는 것과 동시에 작업 환경을 바꾸는 것임
- 문맥 교환은 이처럼 CPU를 처리하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업을 말하는데 이때 두 프로세스 제어 블록의 내용이 변경됨
- 실행 상태에서 나가는 프로세스 제어 블록에는 지금까지의 작업 내용을 저장하고, 반대로 실행 상태에서 들어오는 프로세스 제어 블록의 내용으로 CPU가 다시 세팅됨
- 문맥 교환이 되는 경우는 매우 다양한데 이는 다음과 같음
    - 일반적으로는 한 프로세스가 자신에게 주어진 시간을 다 사용하면 발생
    - 인터럽트가 걸렸을 경우 발생
        - 예를 들어 어떤 프로세스가 자신에게 주어진 메모리 공간을 넘어가려 한다면 이는 경계 레지스터의 범위를 벗어나는 것인데 이때 인터럽트가 발생하여 현재 실행 중인 프로세스의 제어 블록을 저장한 후 인터럽트 관리 프로세스를 실행 상태로 만듬
        - 인터럽트 관리 프로세스는 메모리 범위를 넘어선 프로세스를 강제로 종료하고 인터럽트 처리를 마치는데 이와 같이 인터럽트 처리를 할 때도 문맥 교환이 일어남

<br>

#### 문백 교환의 절차
1. 실행 상태에 있는 P1이 자신에게 주어진 시간을 다 사용하여 타임아웃이 발생
2. P1의 프로세스 제어 블록에 현재까지의 작업 결과가 저장되고 P1은 준비 상태로 쫓겨남
3. 준비 상태에 있던 프로세스 P2가 실행 상태로 가면(dispatch) CPU의 레지스터가 P2의 프로세스 제어 블록 값으로 채워져 다음 작업을 하게됨

<br>

## 3. 프로세스의 연산

### 프로세스의 구조
- 프로세스는 코드영역, 데이터 영역(일반 데이터 영역, 힙 영역), 스택 영역으로 구성됨
- 코드 영역(code area)
    - 프로그램의 본문이 기술된 곳으로 텍스트 영역(text area)라고도 함
    - 프로그래머가 작성한 프로그램은 코드 영역에 탑재되며 탑재된 코드는 읽기 전용으로 처리됨. 자기 자신을 수정하는 프로그램은 존재하지 않기 때문
- 데이터 영역(data area)
    - 코드가 실행되면서 사용하는 변수나 파일 등의 각종 데이터를 모아 놓은 곳
    - 데이터는 변하는 값이기 때문에 이곳의 내용은 기본적으로 읽기와 쓰기가 가능
    - 상수로 선언된 변수는 읽기 전용이지만 대부분의 변수는 읽기와 쓰기가 가능
- 스택 영역(stack area)
    - 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳
    - 프로세스 내에서 함수를 호출하면 함수를 수행하고 원래 프로그램으로 되돌아올 위치를 이 영역에 저장
    - 스택 영역은 운영체제가 사용자의 프로세스를 작동하기 위해서 유지하는 영역이므로 사용자에게는 보이지 않음(숨김 영역)

### 프로세스의 생성과 복사
- 프로세스는 프로그램을 실행할 때 새로 생성됨
- 사용자가 프로그램을 실행하면 운영체제는 프로그램을 메모리로 가져와 코드 영역에 넣고 프로세스 제어 블록을 생성함
- 그리고 메모리에 데이터 영역과 스택 영역을 확보한 후 프로세스를 실행
- 프로세스를 새로 생성하는 방법 뿐만 아니라 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 방법도 존재함

#### fork() 시스템 호출
- fork() 시스템 호출은 실행 중인 프로세스 로부터 새로운 프로세스를 복사하는 함수
- 커널에서 제공하는 이 함수는 프로세스를 복사하는 일종의 시스템 호출
- fork() 시스템 호출을 사용하면 실행 중인 프로세스와 똑같은 프로세스가 하나 더 만들어 짐
- 이렇게 기존 프로세스를 복사하면 처음 프로그램을 실행하는 속도보다 훨씬 빠름
- 여기서 기존 프로세스는 부모 프로세스가 되고 새로 생긴 프로세스는 자식 프로세스가 되며 두 프로세스는 부모-자식 관계로 연결됨

#### fork() 시스템 호출시 프로세스 제어 블록 변경
- fork() 호출을 하면 프로세스 제어 블록을 포함한 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 만들어지는데 프로세스 제어 블록의 내용 중 일부가 변경됨
- 변경되는 부분은 다음과 같음
    - 프로세스 구분자(PID)
        - 이는 부모와 자식의 주민번호가 다른 것과 마찬가지
    - 메모리 관련 정보
        - 부모 프로세스와 자식 프로세스가 차지하고 있는 메모리의 위치가 다르므로 메모리 관련 정보가 바뀜
    - 부모 프로세스 구분자(PPID)와 자식 프로세스 구분자가 바뀜(CPID)
        - 부모 프로세스의 부모 프로세스 구분자 값은 부모의 프로세스 그대로, 자식 프로세스 구분자 값이 변경됨
        - 자식 프로세스의 부모 프로세스 구분자 값은 부모 프로세스 구분자 값이, 자식 프로세스는 없으므로 자식 프로세스 구분자 값은 -1이 됨

#### fork() 시스템 호출의 장점
- 프로세스의 생성 속도가 빠름
    - 하드디스크로부터 프로그램을 새로 가져오지 않고 기존 메모리에서 복사하기 때문에 프로세스의 생성속도가 빠름
- 추가 작업없이 자원을 상속할 수 있음
    - 부모 프로세서가 사용하던 모든 자원을 추가 작업 없이 자식 프로세스에 상속할 수 있음
- 시스템 관리를 효율적으로 할 수 있음
    - 부모 프로세스와 자식 프로세스가 자식 프로세스 구분자와 부모 프로세스 구분자로 연결되어 있기 때문에, 자식 프로세스를 종료하면 자식이 사용하던 자원을 부모 프로세스가 정리 할 수 있음
    - 프로세스를 종료하면 프로세스가 사용하던 메모리 영역, 파일, 하드웨어를 잘 정리해야 하는데 이러한 정리를 부모 프로세스에 맡김으로써 시스템이 효율적으로 관리됨

<br>

## 4. 스레드

<br>

## 5. 동적 할당 영역과 시스템 호출

