# CHAPTER5 프로세스 동기화

## 1. 프로세스 간 통신
### 프로세스 통신의 개념
- 프로세스는 시스템 내에서 독립적으로 실행되기도 하고 데이터를 주고 받으며 협업하기도 함
- 프로세스가 다른 프로세스와 데이터를 주고 받는 프로세스 간 통신(IPC)에는 컴퓨터 내에 있는 프로세스뿐만 아니라 네트워크로 연결된 다른 컴퓨터에 있는 프로세스와의 통신도 포함됨
- 프로세스간 통신의 종류
    - 프로세스 내 데이터 통신 : 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우의 통신. 프로세스 내부의 스레드는 전역변수나 파일을 이용하여 데이터를 주고받음
    - 프로세스 간 데이터 통신 : 같은 컴퓨터에 있는 여러 프로세스끼리 통신하는 경우로 공용 파일 또는 운영체제가 제공하는 파이프를 사용하여 통신
    - 네트워크를 이용한 데이터 통신 : 여러 컴퓨터가 네트워크로 연결되어 있을 때도 가능한데 이 경우 프로세스는 소켓을 이용하여 데이터를 주고 받음. 소켓을 이용한 프로세스간의 통신을 네트워킹이라하고 소켓을 사용하는 것은 많은 전처리가 있어 다른 프로세스간 통신보다 느림

<br>

### 프로세스 통신의 분류
- 통신 방향의 분류
    - 양방향 통신 : 데이터를 동시에 양쪽방향으로 전송할 수 있는 구조로 일반적인 통신. 프로세스 간 통신에서는 소켓통신이 양방향 통신에 해당
    - 반 양방향 통신 : 데이터를 양쪽 방향으로 전송할 수 있지만, 동시 전송은 불가능하고 특정 시점에 한쪽 방향으로만 전송할 수 있는 구조. 예시에는 무전기가 있음
    - 단방향 통신 : 모스 신호처럼 한쪽 방향으로만 전송할 수 있는 구조. 프로세스 간 통신에서는 전역 변수와 파이프가 단방향 통신에 해당됨
- 통신 구현 방식에 따른 분류
    ```
    전역 변수를 사용하는 통신 방법의 가장 큰 문제는 언제 데이터를 보낼지 데이터를 받는 쪽에서는 모른다는것
    그러므로 데이터를 받는 쪽에서는 전역 변수의 값을 점검하는 수 밖에 없음. 상태 변화를 수시로 살펴보기위해 반복문을 무한 실행하며 기다리는 것을 바쁜 대기(busy waiting)이라고 함.
    바쁜 대기는 시스템 차원에서 자원낭비가 심해 좋지 않은 프로그램의 전형적인 예시
    바쁜 대기 문제를 해결하기 위해 데이터가 도착했음을 알려주는 동기화(synchronization)를 사용함
    ```
    - 대기가 있는 통신, 동기화 통신 : 동기화를 지원하는 통신. 데이터를 받는 쪽은 데이터가 도착할 때 까지 자동으로 대기 상태에 머물러 있음
    - 대기가 없는 통신, 비동기화 통신 : 동기화를 지원하지 않는 통신 방식. 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인함

<br>

### 프로세스 간 통신의 종류
- 프로세스간 통신은 데이터를 주거나 받는 동작으로 이루어지며 이는 쓰기 연산과 읽기 연산으로 간소화할 수 있음
- 전역 변수 GV를 이용하여 send는 쓰기연산으로, receive는 읽기 연산으로 변경한 것임
```
send -> write(GV, message)
receive -> read(GV, message)
```
<br>

#### 1. 전역 변수를 이용한 통신
- 공동으로 관리하는 메모리를 사용하여 데이터를 주고 받는 것
- 데이터를 보내는 쪽에서는 전역변수나 파일에 값을 쓰고, 데이터를 받는 쪽에서는 전역 변수의 값을 읽음
- 전역 변수를 이용한 통신 방식은 주로 직접적으로 관련이 있는 프로세스간에 사용
- 예시로는 부모 프로세스가 전역 변수를 선언한 후 자식 프로세스를 만들면 두 프로세스는 통신을 할 수 있음
- 그러나 해당 통신 방식에는 동기화 문제가 있어 바쁜 대기를 돌면서 계속 주시해야 함

#### 2. 파일을 이용한 통신
- 저장장치에 파일을 읽고 쓰는 방식으로 통신
- 크게 파일을 열고(open), 쓰기(write), 읽기(read) 연산을 한 후 파일을 닫음(close)
- 쓰기 연산은 하드디스크에 데이터를 전송하는 명령, 읽기 연산은 하드디스크로 데이터를 가져오는 명령이라고 할 수 있으므로 파일 입출력도 통신.
- 파일을 이용한 통신은 부모-자식 관계 프로세스 간 통신에 많이 사용되며 운영체제가 프로세스 동기화를 제공하지 않아 wait()함수를 이용하여 자식 프로세스의 작업이 끝날 때 까지 기다렸다 작업을 시작
- fd는 어떤 파일에 접근할 수 있는 권한으로, 파일 기술자(file descriptor)라고 부름
- 파일 열기 : open() 함수는 정상적으로 파일을 사용할 수 있다면 fd를 반환함. fd는 해당 파일에 접근할 수 있는 일종의 열쇠로 파일 쓰기나 읽기 연산을 하려면 먼저 fd를 얻어야 함
    - open("com.txt", O_RDWR) : com.txt 파일을 읽기와 쓰기 작업을 하겠다는 의미로 읽기 전용(read only)로 파일을 열려면 O_RDONLY를 사용함
- 읽기 또는 쓰기 연산 : fd가 필요
    - write(fd, "Test", 5) : com.txt 파일에 Test라는 문자열을 쓰라는 뜻. Test의 크기가 5B이므로 5라고 명시했음(문자열의 끝을 알리는 특수 부호인 null을 포함하여 5B)
    - read(fd, buf, 5) : com.txt 파일에서 5B를 읽어 변수 buf에 저장하라는 뜻
- 파일 닫기 : fd가 가르키는 파일을 닫음
    - close(fd) : fd가 가리키는 파일. 즉 com.txt 파일을 닫음

#### 3. 파이프를 이용한 통신
- 프로세스 동기화문제를 해결하는 방법
- 파이프는 운영체제가 제공하는 동기화 통신 방법으로 파일 입출력과 같이 open()함수로 기술자를 얻고 작업을 한 후 close()함수로 마무리
- 파이프를 이용한 통신은 전역변수를 이용한 통신과 마찬가지로 단방향 통신으로 파이프로 양방향 통신을 하려면 파이프 2개를 사용해야함
- 프로세스 A가 파이프1에 대해 읽기 연산을 수행했는데 프로세스 B가 아직 쓰기 연산을 하지 않았다면 프로세스 B는 대기 상태가 되고 이러한 대기 상태는 프로세스 A에 데이터를 쓰는 순간 자동으로 풀려 동기화가 이루어짐. 프로세스 B는 바쁜 대기를 하지 않아도 됨
- 파이프는 이름 없는 파이프와 이름 있는 파이프로 나뉨
    - 이름 없는 파이프(anonymous pipe) : 일반적인 파이프. 부모와 자식 프로세스 혹은 같은 부모를 가진 자식 프로세스와 같이 서로 관련있는 프로세스 간 통신에 사용
    - 이름 있는 파이프(named pipe) : FIFO라 불리는 특수 파일을 이용하며 서로 관련 없는 프로세스 간 통신에 사용됨

#### 4. 소켓을 이용한 통신
- 네트워킹 상황에서의 통신은 원격 프로시저 호출이나 소켓을 이용함
    - 원격 프로시저 통신 : 다른 컴퓨터에 있는 함수를 호출하는 것으로 자바 같은 객체지향 언어에서 다른 컴퓨터에 있는 객체의 메소드를 불러와 사용하는 것은 모두 원격 프로시저 호출임
- 일반적으로 원격 프로시저 통신은 소켓을 이용하여 구현
- 다른 컴퓨터에 있는 프로세스와 통신을 하려면 그 컴퓨터의 위치를 파악하고 원격지의 시스템 내 여러 프로세스 중 어떤 프로세스와 통신을 할지도 결정해야함
- 이때 통신하고자 하는 프로세스는 자신의 소켓과 상대 소켓을 연결하는데 소켓을 매개로 한 쪽에 있는 프로세스가 반대쪽의 프로세스를 연결하는 작업을 바인딩(binding)이라고 함. 시스템에 있는 프로세스가 소켓을 바인딩한 후 소켓에 쓰기 연산을 하면 데이터가 전송되고, 읽기 연산을 하면 데이터를 받게 됨
- 소켓은 프로세스 동기화를 지원하므로 데이터를 받는 쪽의 프로세스가 바쁜대기를 하지 않아도 되고, 소켓은 하나만 사용해도 양방향 통신이 가능함

<br>

#### 정리

|종류|운영체제 동기화 지원|open()/close() 사용|
|:---:|:---:|:---:|
|전역변수|X(바쁜대기)|X|
|파일|X(wait() 함수 이용)|O|
|파이프|O|O|
|소켓|O|O|

<br><br>

## 공유 자원과 임계 구역
### 공유 자원의 접근
- 공유 자원(shared resource)는 여러 프로세스가 공동으로 이용하는 변수, 메모리, 파일 등을 말함
- 공유 자원은 공동으로 이용되기 때문에 누가 언제 데이터를 읽거나 쓰느냐에 따라 그 결과가 달라질 수 있음
- 따라서 프로세스들의 공유 자원 접근 순서를 정하여 예상치 못한 문제가 발생하지 않도록 해야함
- 2개 이상의 프로세스가 공유 자원을 병행적으로 읽거나 쓰는 상황을 경쟁 조건(race condition)이 발생했다 말하고 경쟁 조건이 발생하면 공유 자원 접근 순서에 따라 실행 결과가 달라질 수 있음

<br>

### 임계구역(critical section)
- 공유 자원 접근 순서에 따라 실행 결과가 달라지는 프로그램의 영역
- 임계구역에서는 프로세스들이 동시에 작업하면 안되며 어떤 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역 밖에서 기다려야 하며 임계구역의 프로세스가 나와야 들어갈 수 있음
- 임계구역은 전역 변수 뿐만아니라 하드웨어 자원을 사용할 때도 적용되는 개념

<br>

### 생산자-소비자 문제 (producer-consumer problem)
- 임계구역에 관련된 대표적인 문제로는 생산자-소비자 문제가 있음
- 생산자 프로세스가 서로 독립적으로 작업을 함
- 생산자는 계속 물건을 생성해서 버퍼에 넣고 소비자는 계속 버페에서 문제를 가져오는데 버퍼는 작업을 계속하기 위해 원형 버퍼(circular buffer)를 사용
- 또한 버퍼가 비었는지 가득 찼는지를 확인하기 위해 sum이라는 전역 변수를 사용
- 생산자-소비자 알고리즘에서 문제는 동시에 실행되면 문제가 발생함. 생산자와 소비자가 전역 변수 sum에 접근하는 타이밍을 서로 맞추지 않았기에 발생하는 문제임
    - 동시에 실행되어 생산자가 물건을 생성했지만 동시에 소비자가 물건을 가져와 같은 시간에 접근하여 실행하려 하면 그중 미세한 시간차를 두고 늦게 실행된 내용에 따라 전역변수가 적용됨

<br>

### 임계구역 해결 조건
- 상호 배제(mutual exclusion)
    - 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없음
    - 이것이 지켜지지 않으면 임계구역을 설정한 의미가 없음
- 한정 대기(bounded waiting)
    - 어떤 프로세스도 무한 대기(infinite postpone)하지 않아야 함
    - 특정 프로세스가 임계구역에 진입하지 못하면 안됨
- 진행의 융통성(progress flexibility)
    - 한 프로세스가 다른 프로세스의 진행을 방해해서는 안됨

<br>

### 임계 구역 해결 방법
- 임계 구역의 문제를 해결하는 단순한 방법은 잠금(lock)을 이용하는 것

### 상호 배제 문제
- 잠겨있으면 다른 프로세스가 작업하고 있다는 뜻이므로 무한 루프를 돌면서 기다림
- 임계 구역에 진입하는 프로세스는 잠금을 걸고 작업을 하며 작업을 마치면 다른 프로세스가 사용할 수 있도록 잠금을 해제함
- 프로세스 P1은 while(lock==true) 문을 실행하고 나서 곧바로 lock=true 문을 실행해야 다른 프로세스가 임계구역에 들어오는 것을 막을 수 있음
- 그러나 P1이 lock==true 문을 실행하기 전에 프로세스 P2가 while(lock==true)문을 실행하면 둘 다 임계구역에 접근하지 못하게 됨. 결국 상호 배제 문제를 보장하지 못함
- 또한 무한루프를 돌면서 바쁜 대기를 하여 시스템 자원에 낭비 존재

<br>

### 한정 대기 문제
- 상호 배제 문제롤 보완하여 전역변수로 lock1, lock2를 사용하고 초깃값은 둘다 false
- 프로세스 P1은 임계구역에 진입하기 전에 먼저 잠금을 설정하고(lock1=true) 프로세스 P2가 잠금을 설정했는지 확인 while(lock2==true)
- 만약 잠금을 설정하지 않았다면 임계구역에 접근하여 작업을 마친 후 잡근을 해제 (lock1=false). 프로세스 P2도 같은 방식으로 임계구역에 진입
- 우선 잠금을 하고 다른 프로세스가 잠겼는지 확인하므로 두 프로세스의 상호 배제가 보장되지만 두 프로세스가 모두 임계구역에 진입하지 못하는 무한 대기 현상이 일어남
    - P1이 lock1을 잠구고 타임아웃으로 문맥 변경 -> P2도 lock2을 잠구고 타임아웃 -> P1은 lock2가 잠겨있어 무한루프 -> P2는 lock1이 잠겨있어 무한루프
- 이렇게 P1과 P2 둘다 while 문을 빠져나오지 못하고 무한 루프에 빠져서 임계구역에 진입하지 못하는 교착 상태(deadlock) 상황이 되어 버림

<br>

### 진행의 융통성 문제
- lock 값이 1이면 프로세스 P1이 임계구역을 사용한다는 뜻이고, lock 값이 2면 프로페스 P2가 임계구역을 사용한다는 뜻
- 공유 변수 lock의 값을 통해 다른 프로세스가 임계구역에 있는지 확인하고 없으면 진입
- 프로세스 P1이 임계구역에 접근하면 lock=1이고 임계구역을 빠져나올 때 lock=2로 바꿈
- 상호 배제와 한정 대기를 보장하지만 서로 번갈아가면서 실행되는 것이 문제. 한 프로세스가 두 번 연달아 임계구역에 진입하고 싶어도 불가능해짐
- 이렇게 프로세스의 진행이 다른 프로세스로 인해 방해받는 현상을 경직된 동기화(lockstep synchronization)라고 함

<br>

### 하드웨어적인 해결 방법
- 잠금이 걸렸는지 검사하는 코드와 잠금 설정을 하는 코드가 분리되어 실행되면 문제가 발생하는데 하드웨어 적인 임계구역 문제를 쉽게 해결 가능
- '검사와 지정(test-and-set)'이라는 코드로 하드웨어의 지원을 받아 검사와 잠금을 함번에 실행하여 명령어 실행 중간에 타임아웃이 걸려 임계구역을 보호하지 못하는 문제가 발생하지 않도록함
- 매우 편리하지만 바쁜 대기를 사용하여 자원의 낭비가 존재

<br>

### 피터슨 알고리즘 (Peterson)
- 변수 turn은 두 프로세스가 동시에 lock을 설정하여 임계구역에 못들어가는 상황에 대비하는 장치
- 두 프로세스가 동시에 lock을 설정해도 turn을 이용하여 다른 프로세스에게 양보
- 임계구역 해결의 세 가지 조건을 모두 만족
- 프로세스 수가 늘어나면 변수도 늘어나고 전체적인 알고리즘도 복잡해짐
- 바쁜 대기를 사용하여 자원을 낭비

<br>

### 데커 알고리즘 (Dekker)
- 하드웨어 도움없이 임계구역 문제를 해결 가능
- 임계구역 해결의 세 가지 조건을 모두 만족
- 프로세스 수가 늘어나면 변수도 늘어나고 전체적인 알고리즘도 복잡해짐
- 바쁜 대기를 사용하여 자원을 낭비

<br>

### 세마포어 알고리즘
- 앞의 알고리즘에 비해 간단하고 사용이 쉬우며 wake up 신호를 사용하여 바쁜 대기를 하지 않아도 됨
- P()와 V()의 내부 코드는 검사와 지정을 사용하여 분리 실행하지 않고 완전히 실행되게 해야함 -> 한정 대기 조건을 위해서
- 직접 변수를 조작하여 위험하고 사용자가 실수로 잘못된 사용으로 인해 임계 구역이 보호받지 못할 수 있음
```
Semaphore(n) : 전역 변수 RS를 n으로 초기화함. RS는 현재 사용 가능한 자원의 수가 저장됨
P() : 잠금을 수행하는 코드로 RS가 0보다 크면(사용가능한 자원이 있으면) 1만큼 감소시키고, 임계 구역에 진입. 만약 RS가 0보다 작으면(사용가능한 자원이 없다면) 0보다 커질 때 까지 기다림
V() : 잠금 해제와 동기화를 같이 수행하는 코드로 RS값을 1증가 시키고 세마포어에서 기다리는 프로세스에게 임계구역에 진입해도 좋다는 wake_up 신호를 보냄
```

<br>

### 모니터
- 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공하여 자원 보호, 프로세스간의 동기화
- 시스템 호출과 같은 개념
- 사용자 입장에서는 복잡한 코드를 실행하지 않아서 좋고, 시스템 입장에서는 임계구역 보호가 가능
- 임계 구역으로 지정된 변수나 자원에 접근하고자 하는 프로세스는 직접 P()나 V()를 사용하지 않고 모니터에 작업 요청
- 모니터는 임계구역 보호황 동기화를 위해 내부적으로 상태 변수(condition variable) 사용
```
wait() : 모니터 큐에서 자신의 차례가 올 때 까지 기다림. 세마포어의 P()에 해당
signal() : 모니터 큐에서 기다리는 다음 프로세스에 순서를 넘겨줌. 세마포어의 V()에 해당
```

<br>