# 면접 대비 정리

## JAVA & Spring

<br><br>

### 절차지향 프로그래밍 vs 객체 지향 프로그래밍
- 둘다 명령형 프로그래밍으로 선언형 프로그래밍과 구분되는 프로그래밍 패러다임임
- 명령형 프로그래밍은 무엇을 할 것인지보다 어떻게 할 것인지를 설명하는 방식
- 절차지향 프로그래밍 : 수행되어야 할 순차적인 처리과정을 포함하는 방식. 유지보수가 어렵고 코드의 순서가 바뀌면 동일한 결과를 보장하기 어려움
- 객체지향 프로그래밍 : 객체들의 집합으로 프로그램의 상호작용을 포함. 코드를 재사용하고 신뢰성 있는 소프트웨어를 쉽게 작성 가능하지만 속도가 느리고 설계에 많은 시간 소요

<br>

### 함수형 프로그래밍
- 선언형 프로그래밍으로 어떻게 할건지를 나타내기보다는 무엇을 할 것인지 설명하는 방식
- 함수형 프로그래밍 : 순수 함수를 조합하고 소프트웨어를 만드는 방식
- 함수형 프로그래밍은 대입문이 없는 프로그래밍으로 작은 문제를 해결하기 위한 함수를 작성
- 함수형 프로그래밍은 명령형 프로그래밍 기반 개발에는 소프트웨어 크기가 커짐에 따른 스파게티 코드를 유지보수하는 것이 힘들어 해당 프로그래밍 패러다임에 관심을 가지게 됨

<br>

### OOP?
- 객체지향 프로그래밍으로 기존의 내용을 재사용 가능하고 유지보수성이 높음
- 프로그램을 독립된 단위인 객체들의 모임으로 보고 각각의 객체즌 메시지를 주고 받고 데이터를 처리함

<br>

### OOP의 특징 4가지
- 추상화 : 핵심 코드만 노출
    - 불필요한 부분을 숨기고 인터페이스와 구현을 분리
    - 구현객체에 의존하지 않고 추상객체인 인터페이스에 의존
- 캡슐화 : 데이터 보호
    - 필드와 메서드를 하나로 묶는 것
    - 객체의 세부 내용이 외부에 드러나지 않아 외부에서 데이터를 직접 접근하는 것을 방지
- 상속 : 코드 재사용
    - 자식 클래스가 부모클래스의 특징과 기능을 물려받는 것
    - 클래스를 상속받아 수정하여 사용하기 때문에 중복 코드 줄일 수 있음
    - 부모 클래스의 수정은 모든 자식클래스들도 수정
- 다형성 : 객체 변경 용이
    - 어떤 변수, 메소드가 상황에 따라 다른 결과를 내는 것
    - 오버라이딩(Overriding) : 부모클래스 메서드를 자식클래스에서 재정의 하는 것
    - 오버로딩(Overloading) : 한 클래스에서 메서드 이름은 같지만 파라미터 개수나 자료형이 다르면 서로 다르게 동작

<br>

### SOLID
- 객체지향은 캡슐화, 상속, 추상화, 다형성의 특성을 가지고 설계 원칙에 따라서 설계를 진행하여야 하는데 이를 올바르게 설계할 수 있도록 정의해둔 원칙
- SRP ( Single Responsibility Principle : 단일책임의 원칙 )
    - 한 클래스는 하나의 책임만 가져야 한다. 변경이 있을 경우 파급 효과가 적으면 해당 원칙을 잘 따른 것
    - ‘어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다’
- OCP ( Open Close Principle : 개방폐쇄의 원칙 )
    - 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다. 주로 확장에는 다형성을 활용하여 기존코드는 건드리지 않고 확장
    - ‘소프트웨어 엔티티는 확장에 대해서는 열려 있어야하지만 변경에 대해서는 닫혀 있어야 한다’
- LSP ( The Liskov Substitution Principle : 리스코브 치환의 원칙 )
    - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.
    - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야하며, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면 해당 원칙이 필요
    - ‘서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다’
- ISP ( Interface Segregation Principle : 인터페이스 분리의 원칙 )
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 좋음
    - 기능에 따라 접근하는 클라이언트 인터페이스를 분리하여 하나의 인터페이스가 변해도 다른 인터페이스에는 영향을 주지 않으며 인터페이스가 명확해지고 대체 가능성이 높아짐
    - ‘ 결론적으로 단일책임원칙과 인터페이스 분리 원칙은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다. 하지만 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이라고 할 수 있다.’
- DIP ( Dependency Inversion Principle : 의존성 역전의 원칙 )
    - 프로그래머는 구체화보다 추상화에 의존한다. 의존성 주입은 이 원칙을 따르는 방법 중 하나 임
    - 구현 클래스에 의존하지 않고 추상클래스(인터페이스)에 의존
    - 상위 클래스, 인터페이스 일수록 변하지 않을 가능성이 높으며 역할과 구현이 철저하게 구분이 되어있어야 함
    - ‘고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야한다. 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다. 자주 변경되는 구체 클래스에 의존하지 마라’

<br>

### JVM, JDK, JRE
- JVM(Java Virtual Machine) : 자바 가상 머신으로 바이너리 코드 읽기/검증/실행. 실행 환경(Runtime Environment)의 규격을 제공
- JRE(Java Runtime Environment) : 자바 실행환경으로 JVM이 자바 프로그램을 동작 시킬 때 필요한 라이브러리 파일과 기타 파일들을 가지고 있음. JRE는 JVM의 실행 환경을 구현한 것
- JDK(Java Development Kit) : 자바 개발 도구로 JRE + 개발을 위해 필요한 도구(javac, java)들을 포함함

<br>

### 자바의 버전별 차이 (Long Term Support)
- JDK8
    - 람다 표현식 : 별도의 익명 클래스를 만들어서 선언하던 방식을 람다를 통해 대폭 간소화 및 함수형 프로그래밍, 스트림 API 그리고 컬렉션 프레임워크의 개선 등에 영향을 줌
    - 함수형 인터페이스 : 람다 표현식을 사용할 때 만들어야 하는 하나의 메서드를 가진 인터페이스 생성을 줄여줌. 람다 표현식을 사용하기 위한 표준 가이드
    - 메서드 참조 : 특정 메서드를 메서드의 인자로 전달이 가능해짐
    - 스트림 API : 람다 표현식, 함수형 인터페이스, 메서드 참조를 이용한 최종 산출물. 코드를 간결하게 처리 가능
    - Optioanl : NullPointerException 발생하는 것 방지. null이 허용되어 값을 확인하고 관리할 수 있는 기능
    - 인터페이스 개선 : interface 내부에서 default 메서드 선언 가능
    - CompletableFuture : 멀티 스레드 프로그래밍 시 중요한 기능인 CompletableFuture는 기존 Future 인터페이스에서 제공하는 기능 개선
    - 날짜와 시간 API : 기존 Date와 Calendar 클래스의 문제 해결
- JDK11
    - Http 클라이언트 : HTTP 클라이언트 API 포함. HTTP 2.0을 지원하여 웹 소캣 기능 포함
    - ToArray : 컬렉션 인터페이스에 ToArray 메서드가 추가. 이 메서드를 통해서 컬렉션 객체를 배열로 변환하면 별도의 반복문을 작성하지 않고 메서드 호출만으로 처리
    - var키워드 지원 확대 : JDK10에서 타입 추론으로 객체를 생성하는 var 키워드의 기능 추가. 람다 표현식에도 var를 사용해서 변수 선언 가능
    - String 클래스 기능 추가 : 문자열을 표현하는 String 클래스에 편리하게 사용할 수 있는 메서드 추가 (isBlank, Lines, strip, stripLeading, stripTrailing)
- JDK17
    - Pattern Matching for switch : Switch문에서 입력을 객체를 전달하여 기능을 전환하고 특정 유형을 확인 가능
    - Sealed Classes : 상속 가능한 클래스를 지정할 수 있는 봉인 클래스 제공. 상속가능한 대상은 상위 클래스 또는 인터페이스 패키지 내에 속해 있어야 하며 해당 기능은 JDK15에 처음 제공하고 JDK17 에서 기능 완료
    - Foreign Function & Memory API : Java Native Interface를 대체. 기본 함수를 호출하고 JVM 외부의 메모리에 엑세스 가능
    - Deprecating the Security Manager : 보안 관리자 제거
    - 기능 보다는 가장 최신 LTS로 가장 오랜 지원 기간 보유 및 이후 신규 버전과 다음 세대 플랫폼을 위해 준비

<br>

### JVM 구조 및 실행 과정
- 1. 소스 코드(java 파일)를 Java Compiler를 통해 바이트 코드(class 파일)로 변환
- 2. 바이트 코드를 Class Loader에 보냄. 클래스 로더는 클래스 파일을 불러와 메모리에 저장함
- 3. Execution Engine는 Class Loader에 저장된 Byte Code를 명령어 단위로 분류하여 하나씩 실행하게 해주는 엔진
- 4. Garbage Collector는 사용하지 않거나 필요없는 객체들을 메모리에서 수멸시키는 역할
- 5. RuntimeData Area(Memory Area)는 JVM이 프로그램을 수행하기 위해 운영체제로부터 할당받은 메모리 공간임

<br>

### 자바 메모리 구조
- 위에서의 자바 메모리 영역 구조(RuntimeData Area, Memory Area)는 다음과 같음
    - Method Area
        - JVM이 실행되면서 생기는 공간
        - Class 정보, 전역 변수, Static 변수 정보가 저장되는 공간
        - 해당 영역 안에는 Runtime Constant Pool이 존재하고 해당 영역에는 '상수' 정보가 저장됨
        - 모든 스레드가 공유하는 메모리 영역
    - Heap
        - new 연산자로 생성된 객체, Array와 같은 동적으로 생성된 데이터가 저장되는 공간
        - Heap에 저장된 데이터는 Garbage Collector가 처리하지 않는 한 소멸되지 않음
        - Reference Type의 데이터가 저장되는 공간
        - 모든 스레드가 공유하는 메모리 영역
    - Stack
        - 지역변수, 메소드의 매개변수와 같이 잠시 사용되고 필요가 없어지는 데이터가 저장되는 공간
        - Last In First Out으로 나중에 들어온 데이터가 먼저 나감
        - 지역변수이지만 Reference Type일 경우 Heap에 저장된 데이터 주소값을 Stack에 저장해서 사용하게 됨
        - 스레드마다 하나씩 존재
    - PC Register
        - 스레드가 생성된면서 생기는 공간
        - 스레드가 어느 명령어를 처리하고 있는지 그 주소를 등록 
        - JVM이 실행하고 있는 현재 위치를 저장하는 역할
    - Native Method Stack
        - Java가 아닌 다른 언어로 구성된 메소드를 실행이 필요할 때 사용되는 공간

<br>

### 기본형 타입 (Primitive type)
- 실제 값을 저장하는 공간으로 Stack 메모리에 저장됨
- 논리형 : boolean
- 정수형 : byte, short, int, long
- 실수형 : float, double
- 문자형 : char

<br>

### 참조형 타입 (Reference type)
- 기본형 타입을 제외한 타입들이 모두 참조형 타입
- 빈 객체를 의미하는 Null이 존재하며 값이 저장되어 있는 곳의 주소값을 저장하는 공간으로 Heap 메모리에 저장됨
- 배열, 열거, 클래스, 인터페이스 등이 포함됨

<br>

### 일급 객체(First Class Object)
- 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가르킴
- 일급 객체 조건
    - 변수나 데이터에 담을 수 있어야 함
    - 다른 함수를 파라미터로 전달 할 수 있어야함
    - 다른 함수의 결과로서 리턴될 수 있어야 함

<br>

### 일급 컬렉션 (First Class Collection)
- 일급 컬렉션(First Class Collection)은 Collection을 Wrapping 하면서 그 외의 다른 멤벼 변수가 없는 상태를 일급 컬렉션이라고 함
- 일급 컬렉션의 이점은 다음과 같음
    - 비지니스에 종속적인 자료구조 : 서비스 메서드에서 구현을 한다면 해당 객체가 들어간 모든 장소에서 유효성 검증이 필요한 문제점이 발생하는데 생성자로 생성시 유효성 검사를 진행해 쉽게 해결
    - Collection의 불변성을 보장 : final은 재할당만을 금지하는데 final로 만들 수 없는 불변 객체는 일급 컬렉션과 래퍼 클래스의 방법으로 해결해야 함
    - 상태와 행위를 한 곳에서 관리 : 메서드들을 일급컬렉션 내에 만들어 두어 외부에서는 호출만 하고 상태와 행위를 한곳에서 관리 가능. 일급 컬렉션은 값과 로직이 함께 존재하여 외부에서 중복된 메서드의 생성과 같은 문제를 해결해줌
    - 이름이 있는 컬렉션 : 해당 객체들을 변수명으로만 검색하는것은 어렵고 단순히 변수명에 불과하여 의미 부여가 어려운데 특정 컬렉션을 사용해서 구분

<br>

### static, final
- static
    - "고정된" 이라는 의미로 객체 생성 없이 사용할 수 있는 필드와 메소드를 생성하고자 할 때 사용하며 "클래스이름.필드"로 객체 인스턴스 생성없이 사용
    - 공용데이터나 인스턴스 필드를 포함하지 않는 메소드를 선언하고자 할 때 이용
    - 정적 메소드는 객체 참조 없이 바로 사용할 수 있는 특징 때문에 인스턴스 필드나 메소드, 그리고 this 키워드를 사용할 수 없음
- final
    - "최종적인" 이라는 의미로 해당 변수는 값이 저장되면 최종적인 값이 되므로 수정이 불가능하다는 의미
    - 변수를 처음 초기화하여 값을 할당해준 이후 변경이 불가능함

<br>

###  클래스, 객체, 인스턴스
- 클래스(Class) : 객체를 만들어 내기 위한 설계도 혹은 틀. 연관되어 있는 변수와 메서드의 집합
- 객체(Object) : 소프트웨어 세계에 구현할 대상. 클래스에 선언된 모양에 맞게 만들 실체
- 인스턴스(Instacne) : 설계도를 바탕으로 소프트세계에 구현된 구체적인 실체. 객체를 소프트웨어에 실체화 하면 그것을 '인스턴스'라고 하며 실체화된 인스턴스는 메모리에 할당됨. 인스턴스는 객체에 포함된다고 볼 수 있음

<br>

### Enum
- 관련이 있는 상수들의 집합
- 자바에서는 final 키워드로 기본 자료형의 값을 고정가능하며 이렇게 고정된 값을 상수라고 함
- 파일을 Class로 선언하지 않고 Enum 타입으로 선언하여도 됨

<br>

### Annotation
- 사전적인 의미로는 '주석'이라는 의미
- 자바에서 어노테이션은 코드 사이에 주석처럼 쓰이며 특별한 의미, 기능을 수행하도록 하는 기술로 프로그램에게 추가적인 정보를 제공해주는 메타데이터라고 볼수 있음
- 어노테이션 사용순서는 다음과 같음
    1. 어노테이션 정의
    2. 클래스에 어노테이션을 배치
    3. 코드가 실행되는 중에 Reflection을 이용하여 추가 정보를 획득하여 기능을 실시

<br>

### Stream
- JDK8 버전 이후 지원하는 함수형 프로그래밍을 위한 API
- Stream의 특징은 다음과 같음
    - 원본의 데이터를 변경하지 않음
    - 일회용으로 사용
    - 내부 반복으로 작업을 처리
- Stream 사용방법
    - 스트림생성 -> 중간연산 -> 최종연산
    - Stream 연결이 연결되어 있는 모양이 파이프 같아 보여 파이프라이닝이라고 부르기도 함
    - 스트림생성 : Stream 객체를 생성하여 스트림 생성
    - 중간 연산 : 스트림 객체가 뽑아내는 데이터들에 대해 작업을 하기 위한 방법. 특정 데이터들만 걸러내거나 데이터에 대해 가공이 가능
        - Filter : 조건에 맞는 데이터만을 정제하여 더 작은 컬렉션을 만들어내는 연산
        - Map : map 메소드는 값을 변환해주는 람다식을 인자로 받아 스트림에서 뽑아져 나오는 데이터에 변경을 가해줌
        - FlatMap : map 메소드와 비슷한 역할로 flatMap 메소드의 인자로 받는 람다는 리턴 타입이 Stream, 즉 새로운 스트림을 생성해서 리턴하는 람다를 인자로 받음
        - Sorted : 스트림 데이터들을 정렬하고자 할 때 사용
        - Distinct : Stream의 요소들에 중복된 데이터가 존재하는 경우, 중복을 제거하기 위해 distinct를 사용
        - Peek : 스트림 내 엘리먼트들을 대상으로 map() 메소드처럼 연산을 수행. 그러나 map과 다른점은 Stream의 요소들을 대상으로 Stream에 영향을 주지 않고 특정 연산만을 수행하기 위한 함수
        - mapToObject, mapToInteger.. : 일반적인 Stream 객체를 원시 Stream 으로 바꾸거나 그 반대로 하는 작업이 필요한 경우 사용하는 연산
    - 최종 연산 : 중간 연산을 통해 생성된 Stream을 바탕으로 이제 결과를 만들기 위한 연산. 최종 연산은 결과를 특정짓기 때문에 하나만 존재 가능
        - Max/Min/Sum/Average/Count : 각각 최댓값/최솟값/총합/평균/갯수를 구하기 위한 최종 연산
        - Collect : Stream의 요소들을 List나 Set, Map 등 다른 종류의 결과로 수집하고 싶은 경우 collect 함수를 이용 가능
        - Match : Stream의 모든 요소들이 특정한 조건을 충족하는지 검사하고 싶은 경우 사용하고 검사결과는 boolean으로 반환. Match 함수는 anyMatch, allMatch, nonMatch가 존재
        - Find : 스트림에서 찾은 요소를 리턴하는데 해당 조건에 맞는 요소를 리턴. findFirst()와 findAny() 존재
        - forEach : Stream의 요소들을 대상으로 어떤 특정한 연산을 수행하고 싶은 경우. peek과 유사하나 forEach는 최종 연산으로 실제 요소들에 영향을 줄 수 있으며 반환값이 존재하지 않음. 예를 들면 요소를 출력하기 위해 사용
        - Reduce : Stream의 데이터를 변환하지 않고 더하거나 빼는 등의 연산을 수행하여 하나의 값을 만듬. 누산기(Accumulator)와 연산(Operation)으로 컬렉션에 있는 값을 처리하여 더 작은 컬렉션이나 단일 값을 만드는 작업으로 Accuumulator, Identity, Combiner 까지 최대 3가지의 매개변수를 받을 수 있음

<br>

### Reflection
- 객체를 통해 클래스의 정보를 분색해내는 프로그램 기법
- 구체적인 클래스 타입을 알지 못하더라도 그 클래스의 메서드, 타입, 변수들에 접근할 수 있돌고 해주는 자바 API
- 컴파일 시간이 아닌 실행 시간에 동적으로 특정 클래스의 정보를 추출할 수 있는 프로그래밍 기법이라 할 수 있음
- 스프링에서는 개발자가 등록한 빈을 애플리케이션에서 가져와 사용할 수 있게 됨. intelliJ 자동완성 기능과 스프링의 어노테이션이 리플렉션을 이용한 기술
- 리플렉션 기능은 Class<T> API를 사용하게 되는데, 클래스에 있는 필드, 인터페이스, 메서드 목록등에 접근할 수 있음

<br>

### 싱글톤이란? 장단점
- 객체의 인스턴스를 한개만 생성되게 하는 패턴
- 프로그램 내에서 하나로 공유를 해야하는 객체가 존재할 때 해당 객체를 싱글톤으로 구현하여 모든 유저 또는 프로그램이 해당 객체를 공유하며 사용하도록 할 때 사용
- 싱글톤을 사용의 장점은 다음과 같음
    - 메모리 측명의 이점
    - 속도 측면의 이점
    - 데이터 공유가 쉬움

<br>

### 싱글톤 vs 프로토타입
- 싱글톤은 조회할 때 마다 클라이언트에게 같은 객체를 반환하는 것을 보장
- 프로토타입은 조회할 때마다 새로운 인스턴스를 생성해서 반환해줌

<br>

### 스프링 vs 스프링부트
- 스프링은 JAVA의 웹 프레임워크로 다양한 어플리케이션을 만들기 위한 프로그래밍 툴
- 스프링부트는 스프링 부트는 스프링으로 애플리케이션을 만들 때에 필요한 설정을 간편하게 처리해주는 별도의 프레임워크
- 스프링은 JAVA를 이용한 웹 프로젝트를 쉽게 구현하게 해주기 위해 나왔지만 버전관리 혹은 설정 등 개발자가 여전히 해주어야 할 내용이 많았고 스프링부트는 난잡한 설정이나 버전관리 등 Spring을 좀 더 쉽게 사용 가능해짐

<br>

### 스프링의 특징
1. IoC (Inversion of Control, 제어 반전)
    - 개발자는 JAVA 코딩 시 new 연산자, 인터페이스 호출, 데이터 클래스 호출 방식으로 객체를 생성, 소멸 시키는데 여기서 IoC는 객체의 생명주기를 개발자가 아닌 프레임워크가 관리하여 제어가 반전됨을 의미
    - 
2. DI(Dependency Injection, 의존성 주입)
    - 프로그램에서 구성 요소의 의존 관계가 소스내부가 아닌 외부의 설정 파일을 통해 정의되는 방식
    - 필요로 하는 오브젝트를 직접 생성하는 것이 아닌 외부로부터 주입받는 기법을 의미
    - 코드 간의 재사용을 높이고 소스코드를 다양한 곳에 사용하며 모듈간의 결합도를 낮출 수 있음
3. AOP(Aspect Object Programming, 관점 지향 프로그래밍)
    - 로깅, 트랜잭션, 보안 등 여러 모듈에서 공통적으로 사용하는 기능을 분리하여 관리 할 수 있음
    - 비즈니스로직이 아닌 공통 로직을 공통으로 사용하여 효율성이 높음
4. POJO(Plain Old Java Object) 방식
    - 플랫폼에 종속되어 있는 무거운 객체들을 만드는 것에 반발하여 나타난 용어로 getter/setter를 가진 단순한 자바 오브젝트를 의미
    - 별도의 프레임워크 없이 직접 구현하거나 상속받을 필요가 없어 기존 라이브러리를 지원하기 용이하고 객체가 가벼움

<br>

### 스프링 빈 및 등록 방법
- 스프링 빈이란 스프링 IoC 컨테이너가 관리하는 자바 객체
- ApplicationContext.getBean()과 같은 메서드를 이용하여 직접 호출 가능
- 스프링 IoC 컨테이너에 등록된 Bean들은 의존성 관리가 수월해지고 스프링 IoC 컨테이너에 등록된 Bean들은 싱글톤의 형태이다
- 빈을 등록하는 방법은 다음과 같음
    - Component Scan : @Component 어노테이션을 사용하여 빈으로 등록
    - Java 코드로 등록: @Configuration과 @Bean 어노테이션 사용. @Bean은 메소드나 어노테이션에만 붙이는 것이 가능

```
@Bean
- 개발자가 컨트롤이 불가능한 외부 라이브러리들을 Bean으로 등록하고 싶은 경우에 사용된다.
- 메소드 또는 어노테이션 단위에 붙일 수 있다.
@Component
- 개발자가 직접 컨트롤이 가능한 클래스들의 경우에 사용된다.
- 클래스 또는 인터페이스 단위에 붙일 수 있다.
@Configuration
- @Bean에 추가 설정을 줘서 싱글톤으로 만들지 않는 이상 무조건 빈에 대해 싱글톤을 보장한다.
- 클래스의 바이트 코드를 조작하는 라이브러리인 CGLIB를 사용하여 싱글톤을 보장한다.
- CGLIB는 프록시 객체의 일종으로 AppConfig가 빈으로 등록될 때, AppConfig 대신 AppConfig를 상속 받은 AppConfig$CGLIB 형태로 프록시 객체가 등록된다.
```

<br>

### 스프링 빈 생명주기
- 스프링 IoC 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 메소드 호출 → 사용 → 소멸 전 콜백 메소드 호출 → 스프링 종료
- 콜백이란 주로 콜백함수를 부를 때 사용되는 용어이며 콜백함수를 등록하면 특정 이벤트가 발생했을 때 해당 메소드가 호출되는데, 조건에 따라 실행될 수도 실행되지 않을 수도 있는 개념

<br>

### 스프링에서 생성자 주입을 권장하는 이유 
- 주입 방법은 생성자 주입(constructor), 수정자 주입(getter/setter), 필드 주입, 일반 메소드 주입이 존재
- 생성자 주입을 사용하는 이유는 다음과 같음
    - 객체의 불변성 확보 : 생성자 주입을 통해 변경의 가능성을 배제하고 불변성을 보장
    - 테스트 코드의 작성 : 생성자 주입이 아닌 다른 주입으로 작성된 코드는 순수한 자바 코드로 단위 테스트를 작성하는 것이 어려움
    - final 키워드 작성 및 Lombok과의 결합 : 생성자 주입을 사용하면 필드 객체에 final 키워드를 사용할 수 있으며, 컴파일 시점에 누락된 의존성을 확인할 수 있지만 반면에 다른 주입 방법들은 객체의 생성(생성자 호출) 이후에 호출되므로 final 키워드를 사용할 수 없음
    - 스프링에 비침투적인 코드 작성 : 필드 주입을 사용하려면 @Autowired를 이용해야 하는데, 이것은 스프링이 제공하는 어노테이션이므로 @Autowired를 사용하면 다음과 같이 UserService에 스프링 의존성이 침투
    - 순환 참조 에러 방지 : 생성자 주입을 사용하면 애플리케이션 구동 시점(객체의 생성 시점)에 파악하여 순환 참조 에러를 예방가능

<br>

### Spring 생성자 주입 외 의존성 주입 방법
- 수정자 주입 : getter/setter를 이용한 주입. 객체의 불변성을 해하고 테스트 코드 작성이 어려움
- 필드 주입 : @Autowired를 이용한 필드 주입. DI 프레임워크에 종속적이고 테스트코드 작성이 어려워지며 순환참조가 될수 있음

<br>

### 순환참조란? 
- A 클래스가 B 클래스의 Bean 을 주입받고, B 클래스가 A 클래스의 Bean 을 주입받는 상황처럼 서로 순환되어 참조해야하는 경우 발생하는 문제
- 순환참조는 DI 상황에서 스프링이 어느 스프링 빈을 먼저 생성할지 결정하지 못하기 때문에 발생할 수 있음 (A 빈을 생성하는 데 B 클래스가 필요해 B 빈을 생성하려는데 A클래스가 필요해 해당 상태 반복)

<br>

### 스프링 컨테이너
- 스프링 컨테이너는 서블릿 컨테이너 안에 존재하며 Bean 생명 주기를 관리
- Bean을 관리하기 위해 IoC가 이용되며 BeanFactor 객체가 바로 IoC 컨테이너(=DI 컨테이너, 스프링 컨테이너)에 해당되며, 이 IoC 컨테이너를 상속하면서 부가 기능을 추가한 것이 ApplicationContext
- Spring MVC 역시 서블릿 컨테이너가 관리하고 있는 거대한 서블릿으로 비즈니스 로직을 스프링을 통해 처리하는 것이지 서블릿을 사용하지 않는 것이 아님ㅠㅜ
    - 스프링 컨테이너는 서블릿 컨테이너 안에 존재함
    - 서블릿 컨테이너가 스프링 빈에 접근하려면 스프링 컨테이너를 거쳐야 함

<br>

### 스프링 동작 과정
1. 클라이언트의 모든 요청은 DispatcherServlet이 받음
2. DispatcherServlet은 HandlerMapping을 통해 해당 URL에 매핑된 Controller를 검색
3. 주입된 @Bean 객체를 가지고 HandlerMapping에 매핑되어 있는 Controller 호출
4. Controller는 적절한 서비스 객체 호출
5. Service는 DB 처리를 위해 DAO를 이용하여 데이터를 요청
6. DAO는 Mapping을 이용한 DB 처리 실행 ( 이전 : MyBatis -> 최근 : JPA 을 주로 이용하여 매핑 )
7. 처리한 데이터의 결과가 Mapper -> DAO -> Service -> Controller 로 전달
8. Controller는 전달된 결과를 ViewResolver에서 prefix 경로의 viewName.suffix 형식이 있는지 확인
9. 해당하는 View가 있다면 View에 처리한 데이터의 결과를 전달
10. View는 전달받은 결과를 다시 DispatcherServlet에 전달
11. DispatcherServlet은 전달받은 결과를 클라이언트에게 전달
12. 최종 결과를 클라이언트에서 출력

<br>

### DAO, DTO, VO, Entity
- DAO : 데이터베이스의 data에 접근하기 위한 객체입니다. DataBase에 접근 하기 위한 로직 & 비지니스 로직을 분리하기 위해 사용
- DTO : 계층 간 데이터 교환을 하기 위해 사용하는 객체로, DTO는 로직을 가지지 않는 순수한 데이터 객체(getter & setter 만 가진 클래스)
- VO : 값 오브젝트로써 값을 위해 쓰입니다. read-Only 특징(사용하는 도중에 변경 불가능하며 오직 읽기만 가능)을 가짐
- Entity : Entity 클래스는 실제 DataBase의 테이블과 1 : 1로 매핑 되는 클래스로, DB의 테이블내에 존재하는 컬럼만을 속성(필드)으로 가져야 함. Entity 클래스는 상속을 받거나 구현체여서는 안됨

<br>

### @requiredArgsConstructor 사용이유 
- 클래스에 선언된 final 변수들, 필드들을 매개변수로 하는 생성자를 자동으로 생성해주는 어노테이션
- 생성자 주입을 어노테이션으로 간단하게 사용하기 위해서
- 해당 어노테이션은 Lombok에서 제공

<br>

### JDBC vs JPA
- JDBC(Java Database Connectivity)는 DB에 접근(Connectivity)할 수 있도록 Java에서 제공하는 API로 SQL Mapper를 사용함
- Spring JDBC는 JDBC에서 DriveManager가 하는 일들을 JdbcTemplate에게 맡기고 개발자는 메서드에 쿼리를 직접 매핑
- JDBC는 SQL Mapper를 사용하고 SQL Mapper는 말 그대로 SQL구문을 매핑시켜서 데이터베이스에 질의하는 것이다. 즉, 우리는 직접 SQL 구문을 작성해야 한다. 대신, 이렇게 받아온 질의 결과를 바로 객체 형태로 받아올 수 있음
- JPA(Java Persistence API)는 객체와 데이터베이스 스키마를 매핑시켜 객체지향과 데이터 지향 간의 혼동되는 패러다임의 불일치를 해소하기 위해 객체지향 프로그래밍을 지향하기 위해 개발됨
- JPA는 Persistence Framework에 속하는데 데이터베이스에 접근하여 조작하는 과정을 도와주는 프레임워크이며 ORM의 표준 규약에 해당됨

<br>

### ORM이란
- ORM은 우리가 직접 SQL 구문을 사용하지 않고, 객체와 데이터베이스의 스키마를 매핑시킨다. 이를 통해 우리는 어플리케이션 개발 언어로 ORM에서 제공하는 메소드를 적절히 조합하여 데이터베이스를 조작할 수 있음

<br>

### @Transactional 이란
- 해당 어노테이션은 메서드가 포함하고 있는 작업 중에 하나라도 실패할 경우 전체 작업을 취소함
- class레벨의 어노테이션은 선언된 클래스와 그의 서브클래스 내부에 있는 모든 메소드에 적용됨
- 트랜잭션은 기본적으로 RuntimeException과 Error가 발생했을시 롤백
- 동작 과정은 다음과 같음
    1. 스프링은 해당 메소드를 감싼 프록시 객체를 생성
    2. 메소드 앞뒤에 트랜잭션 로직을 삽입(begin-commit/rollback)
    3. public method에만 프록시 객체 생성

<br>

### @Transactional(readOnly = true)
- 트랜잭션을 읽기 전용으로 설정하는 어노테이션입니다. 이 설정은 해당 트랜잭션에서 데이터베이스를 변경하지 않고 읽기만 하는 경우에 유용
- 읽기 전용 트랜잭션에서는 프록시 객체를 만들지 않고, 필요한 데이터를 가져올 때에만 데이터베이스에서 로딩하므로 이는 쓰기 작업이 없으므로 영속성 컨텍스트(Persistence Context)에 캐싱된 내용을 변경할 필요가 없기 때문에 프록시 객체를 생성하지 않고 성능을 최적화 함
- 만약 읽기 전용으로 받아온 entity가 변경될 경우 프록시 객체가 생성됨. 읽기 기능만 사용한다면 상관 없음

<br>

### JPA를 사용해도 네이티브 쿼리 많이 쓴다면 jpa를 쓰는 의미가 있는지
- 네이티브 쿼리를 자주 사용한다면 JPA를 사용하는 이점이 상대적으로 줄어들 수 있으나 주된 이유는 SQL 쿼리를 직접 작성하는 것이 아니라 객체 지향적인 방식으로 데이터베이스를 다루는 것이 목적
- 또한 JPA는 객체 지향적인 코드 작성을 통해 데이터베이스와의 상호작용을 추상화하여 개발자가 데이터베이스 스키마를 신경쓰지 않고도 쉽게 작업할 수 있게함
-  영속성 컨텍스트를 통해 객체의 상태를 추적하고 관리하여 객체 그래프를 편리하게 다룰 수 있음

```java
// 네이티브 쿼리 예시
public class NativeQueryExample {
    @PersistenceContext
    private EntityManager entityManager;

    public List<Object[]> executeNativeQueryExample() {
        // 네이티브 SQL 쿼리 작성
        String nativeQuery = "SELECT * FROM table_name WHERE column = :param";

        // 네이티브 쿼리 생성
        Query query = entityManager.createNativeQuery(nativeQuery);

        // 파라미터 설정 (옵션)
        query.setParameter("param", "some_value");

        // 네이티브 쿼리 실행 및 결과 조회
        List<Object[]> resultList = query.getResultList();
        return resultList;
    }
}
```

<br>

### JPA queryDSL
- 데이터를 조회하는 데 기능이 특화되어 있는 JPQL(JPA Query Language) 또는 Criteria API와 비슷한 형태의 쿼리를 생성하는 자바 라이브러리
- 자바 코드로 쿼리를 작성할 수 있는 도구로, SQL과는 달리 컴파일 시점에서 타입 안전성을 보장하면서 쿼리를 작성할 수 있도록 도와줍니다. 객체지향적인 방식으로 쿼리를 표현할 수 있어, 쿼리 작성 시 문법 오류를 줄이고 가독성을 높일 수 있음
```java
public void queryDSL() {
    EntityManager em = emf.createEntityManager();

    JPAQuery query = new JPAQuery(em);
    QMember qMember = new QMember("m");
    List<Member> members = 
        query.from(qMember)
            .where(qMember.name.eq("회원1"))
            .orderBy(qMember.name.desc())
            .list(qMember);
}
```

<br>

### JPA N+1 문제를 해결하는 방법 
- 데이터베이스에서 데이터를 조회할 때 발생하는 쿼리 실행 횟수가 불필요하게 많아져서 발생하는데 JPA에서 연관된 엔티티를 로딩할 때 발생하는 현상
- 1번 조회해야할 것을 N개 종류의 데이터 각각을 추가로 조회하게 되서 총 N+1번 DB조회를 하게 되는 문제로 JPA의 Entity 조회시 Query 한번 내부에 존재하는 다른 연관관계에 접근할 때 또 다시 한번 쿼리가 발생하는 비효율적인 상황
- fetchjoin 사용하여 DB에서 데이터를 가져올때 처음부터 연관된 엔티티나 컬렉션을 한번에 같이 조회하는 방법을 사용하여 해결
- @EntityGraph 어노테이션을 사용하여 JPA에서는 쿼리 실행 시 관련된 엔티티들을 함께 로딩하는데, 이때 필요한 연관 엔티티들을 명시적으로 지정할 수 있음
```java
@Entity
@EntityGraph(attributePaths = "roles") // roles 엔티티를 함께 로딩
public class User {
    @Id
    private Long id;
    
    private String username;

    @OneToMany(mappedBy = "user")
    private List<Role> roles;
}
```

<br>

### JPA fetchjoin 이란? 
- SQL에서 사용하는 조인의 종류는 아니고 JPQL에서 성능 최적화를 위해 제공하는 기능으로 연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능
- fetchjoin을 사용해서 회원 엔티티를 조회하면서 연관된 팀 엔티티도 함께 조회하며 페치 조인은 글로벌 로딩 전략(fetch = FetchType.LAZY)보다 우선하여 SQL 한 번으로 연관된 엔티티들을 함께 조회할 수 있어서 SQL 호출 횟수를 줄여 성능을 최적화
- 즉시 로딩에 해당하는 개념

```
지연 로딩(Lazy Loading)
- JPA에서 FetchType이 LAZY로 설정되어 있으면, 연관된 엔티티들은 프록시 객체로 로딩되어 해당 엔티티를 실제로 사용할 때 데이터베이스에서 필요한 시점에 초기화되어 가져오게 됨

즉시 로딩(Eager Loading)
- 반면에 FetchType이 EAGER로 설정되어 있다면, 해당 엔티티를 즉시 로딩하여 연관된 엔티티를 함께 가져옴. 이 때 프록시 객체가 아닌 실제 엔티티가 로딩됨


JPA에서 FetchType을 명시하지 않았을 때의 기본 값
- 일대다(N:1), 다대일(1:N), 일대일(1:1) 관계에서는 LAZY Loading
- 다대다(N:M) 관계에서는 EAGER Loading
```

<br>

### functional interface가 무엇인지 및 예시함수

<br>

### Filter, Interceptor, AOP
- 세가지 모두 공통로직을 관리하기 위해 존재
- Filter 
    - 스프링 컨테이너가 아닌 톰캣과 같은 웹 컨테이너에서 관리가 되는 것이고 디스패처 서블릿 전/후에 처리하는 것임
    - javax.servlet의 Filter 인터페이스를 구현해야함. (현재는 jakarta로 명칭 변경됨)
    - init, doFilter, destroy 메소드 존재
- Interceptor
    - Spring이 제공하는 기술로 디스패처 서블릿이 컨트롤러를 호출하기 전과 후에 요청과 응답을 참조하거나 가공할 수 있는 기능으로 스프링 컨텍스트에서 동작을 함
    - org.springframework.web.servlet의 HandlerInterceptor 인터페이스를 구현해야함
    - preHandle, postHandle, afterCompletion 메소드 존재
- AOP
    - 객체 지향 프로그래밍 시 중복을 줄일 수 없는 부분을 줄이기 위해 관점에서 보고 처리
    - 주로 로깅, 트랜잭션, 에러처리 등의 비즈니스단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용
    - Filter와 Interceptor와는 달리 메소드 전후의 지점에 자유롭게 설정 가능 -> Interceptor나 Filter는 주소로 대상을 구분하지만 AOP는 주소, 파라미터, 어노테이션 등 다양한 방법으로 대상 지정 가능
    - AspectJ 라이브러리를 이용하여 사용

<br>

### Webflux
- 비동기 및 반응형 프로그래밍을 지원하는 모듈
- 적은 양의 스레드와 최소한의 하드웨어 자원으로 동시성을 핸들링하기 위해 만들어짐
- netty와 같은 잘 만들어진 async, non-blocking 서버를 사용. 하지만 논 블로킹을 일부 지원
- 사실 동기프로그래밍이 코드를 작성하거나 디버깅하는 데에 더 쉽기 때문에, 동일한 말로 생산성이 높다고 표현할 수 있다.
- 비동기 프로그래밍 중에, 동기화되는 부분의 코드가 있다면 그 나머지 비동기 코드로 작성된 건 무의미해질 수 있다. 동기화되는 부분에서 결국 블락킹이 되기 때문인 것 같다
- Java에서 DB connection 쪽이 논블로킹 라이브러리가 잘 사용되지 않는다고 한다. R2DBC처럼 개발이 진행 중인 라이브러리, 최근에 release된 jasync sql, MongoDB, Redis 등의 NoSQL은 지원중
- webflux는 마이크로서비스 아키텍처에 적합한 모듈. 그리고 RestTemplate과 같이 service콜을 하는 모듈이 Blocking I/O일 때의 한계점도 여실히! asyncRestTemplate을 사용해서 Blocking I/O의 한계를 조금은 보완하고 하긴 했으나, 확실히 서비스를 잘게 쪼갠 상태의 아키텍처에는 Non-Blocking I/O는 필요

### Spring Batch
- 

<br><br>

---

<br><br>

## OS

<br><br>

### 프로세스와 스레드의 차이
### 임계구역 (Critical Section)
- 공유 변수 영역이라고도 하며, 병렬프로그래밍에서 둘 이상의 프로세스가 동시에 접근해서는 안되는 공유자원 영역
- 공유 자원 접근 순서에 따라서 실행 결과가 달라지는 프로그램의 영역
- 임계구역에서는 프로세스들이 동시에 작업하면 안됨
- 임계 구역 해결 조건
    - 상호 배제(Mutual Exclusion) : 한 프로세스가 임계구역에 들어가면 다른 프로세스는 임계구역에 들어갈 수 없음
    - 한정 대기(Bounded Waiting) : 어떤 프로세스도 무한대기하지 않아야함. 특정 프로세스가 임계구역에 진입하지 못하면 안됨
    - 진행의 융통성(Progress Flexibility) : 한 프로세스가 다른 프로세스의 진행을 방해해서는 안됨

<br>

### 경쟁 상태 (Race Condition)
- 두 개 이상의 동시성이 있는 프로세스나 스레드들이 동기화 없이 공유된 자원에 접근하려는 현상
- 두 개 이상의 프로세스가 하나의 자원을 놓고 서로 이용하려고 경쟁하는 상황을 의미

<br>

### 세마포어, 뮤텍스
- 동기화를 제공하는 방법임
- 뮤텍스(Mutex) : 이진 세마포어(Binary Semaphore)로 세마포어의 일종. 가장 큰 차이점으로는 뮤텍스는 오직 1개의 프로세스 혹은 스레드만이 공유 자원에 접근할 수 있고, 세마포어는 지정된 변수의 값만큼 접근할 수 있음
- 세마포어(Semaphore) : 운영체제 혹은 커널 단위에서 해당 리소스 변수가 관리되어 현재 공유 자원을 사용 중인 대상뿐만 아니라 다른 프로세스 및 스레드도 잠금 상태를 해제할 수 있지만 뮤텍스는 프로세스 단에서 관리되고 해당 변수(Lock)을 가지고 있기 때문에 Lock을 가지고 있는 변수만이 Unlock을 할 수 있음
- 뮤텍스는 열쇠가 있는 화장실이 하나있고 세마포어는 여러 화장실이 존재하는데 비어 있는 화장실의 개수를 보여주는 카운터 변수를 사용한다고 생각하면 됨

<br>

### 교착상태 (Deadlock)
- 상호 배제에 의해 나타나는 문제점으로 둘 이상으 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고있는 자원을 요구하며 무한정 기다리는 현상
- 교착 상태의 필요 충분 조건은 다음과 같음
    - 상호배제(Mutual Exclusion) : 한번의 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 함
    - 점유와 대기(Hold and Wait) : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야함
    - 비선점(Non-preemption) : 다른 프로세스에 할당된 자원은 사용이 끝날때까지 강제로 빼앗을 수 없어야 함
    - 순환대기(Circular Wait) : 공유자원과 공유자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구

<br>

### 교착상태를 해결하기 위한 은행원 알고리즘
- 교착 상태에 빠질 가능성이 있는지 판단하기 위해 상태를 안전 상태와 불안전 상태로 나누고, 안전 상태를 유지할 수 있는 요구만을 수락하고, 불안전 상태를 초래할 수 있는 사용자의 요구는 만족될 수 있을 때까지 계속해서 거절하는 방법
- 안전 상태는 시스템이 교착 상태를 일으키지 않고, 각 프로세스가 요구한 양 만큼 자원을 할당해줄 수 있는 상태로, 안전 순서열이 존재하는 상태
- 불안전 상태는 안전 순서 열이 존재하지 않는 상태, 즉 아무런 방법이 없는 상태이다. 교착 상태는 불안전 상태일 때만 발생하고, 불안전 상태라고 해서 무조건 교착 상태인 것은 아님
- 안전 상태는 은행으로 치면 돈을 빌려줄 수 있고, 다시 돈을 돌려 받을 수 있는 상태를 의미
- 은행원 알고리즘이 수행되기 위해서는 다음 3가지가 필요
    - MAX : 각 고객들이 얼마나 최대로 돈을 요구할지 = 각 프로세스가 자원을 최대로 얼마까지 요청할 수 있는지
    - Allocated : 각 고객들이 현재 빌린 돈이 얼마인지 = 각 프로세스가 현재 보유하고 있는 자원이 얼마인지
    - Available : 은행이 보유하고, 빌려줄 수 있는 돈은 얼마인지 = 시스템이 자원을 얼마나 보유하고 있는지


<br>

### 스케줄링
- 

<br>

### 동시성, 병렬처리
- 동시성(Concurrency)
    - 동시성은 빠르게 전환하며 여러 작업을 수행하여 동시에 여러 작업이 실행되는 것 처럼 보이는 것
    - 한개의 코어에서도 여러 작업을 Concurrent 하게 실행할 수 있고, 작업 간에는 context switch 가 일어남
    - 싱글코어에서 멀티 쓰레드를 동작시키기 위한 방식
- 병렬처리(Parallelism)
    - 여러 코어에서 여러 작업을 동시에 수항하는 것으로 코어가 하나밖에 없다면 병렬적으로 프로그램 실행이 불가능
    - CPU는 싱글코어의 성능을 올리는데 한계를 느끼고 멀티코어 체제로 넘어가 여러 코어에서 여러 작업을 동시에 수행하면서 성능을 올리려 함
    - 멀티코어에서 멀티 쓰레드를 동작 시키기 위한 방식
    - 여러 작업을 동시에 수행하니 racd condition(경쟁 상태) 혹은 동기화 문제 발생 가능해짐

<br>

### 동기, 비동기
- 동기(Synchronous)
    - 동기는 데이터의 요청과 결과가 한 자리에서 동시에 일어나는 것을 말함
    - 요청을 하면 시간이 얼마나 걸리던지 요청한 자리에서 결과가 주어져야 함
    - 작업 완료 여부를 계속해서 확인
    - 사용자가 데이터를 서버에게 요청한다면 그 서버가 데이터 요청에 따른 응답을 사용자에게 다시 리턴해주기 전까지 사용자는 다른 활동을 할 수 없으며 기다려야 함
    - 순서에 맞춰 진행되지만, 여러 가지 요청을 동시에 처리할 수 없음
- 비동기(Asynchronous)
    - 비동기는 동시에 일어나지 않음을 의미
    - 요청과 결과가 동시에 일어나지 않는다. 즉 하나의 요청에 따른 응답을 즉시 처리하지 않아도그 대기 시간동안 또 다른 요청에 대해 처리가 가능한 방식
    - 작업 완료 여부를 확인하지 않음
    - 서버에게 데이터를 요청한 후 요청에 따른 응답을 계속 기다리지 않아도 되며 다른 외부 활동을 수행하여도되고 서버에게 다른 요청사항을 보내도 상관없음.
    - 작업 완료 여부를 확인하지 않아 다른 함수를 호출할때 콜백 함수를 함께 전달하여 호출한 함수의 작업이 완료되면 보낸 콜백 함수 실행
    - 여러 개의 요청을 동시에 처리할 수 있는 장점이 있지만 동기 방식보다 속도가 떨어질 수도 있음
    - 동기보다 복잡하지만 결과가 주어지는데 시간이 걸리더라도 그 시간 동안 작업을 할 수 있으므로 자원을 효율적으로 사용할 수 있는 장점이 있음

<br>

### 블로킹, 논블로킹
- 블로킹(Blocking)
    - 제어권이 호출된 함수에게 넘어가서 호출된 함수 내에서 작업이 모두 끝난 후 호출한 함수에게 다시 제어권이 넘어옴. 작업이 완료된 후 새로운 작업을 수행할 수 있음
- 논블로킹(Non-Blocking)
    - 제어권이 계속 호출한 함수에 있기 때문에 작업의 완료여부와 관계없이 새로운 작업을 수행할 수 있음

<br>

### 쿠키, 캐시, 세션
- 쿠키와 세션은 HTTP 프로토콜의 특징이자 약점을 보완하기 위해서 사용함
- 쿠키(Cookie) : HTTP의 일종으로 사용자가 어떠한 웹 사이트를 방문할 경우, 그 사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일이다
- 캐시(Cache) : 자주 사용하는 데이터나 값을 미리 복사해 놓는 임시 장소로 CPU 칩 내부나 바로 옆에 탑재하는 메모리
- 세션(Session) : 웹 사이트의 여러 페이지에 걸쳐 사용되는 사용자 정보를 저장하는 방법. 일정 시간 동안 같은 사용자(브라우저)로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지시키는 기술

<br>

### 동기화 (Synchronization)
- 프로세스 또는 스레드들이 수행되는 시점을 조절하여 서로가 알고 있는 정보가 일치하는 것
- 동기화룰 제공하는 방법은 lock, 세마포어-뮤텍스, 모니터 방법이 존재. 모니터는 공유자원을 내부적으로 가지고 있어 외부에 공개하지 않고 한번에 한개의 프로세스만 입장 가능함

<br>

### 분산락, 스핀락
- 분산락 : 분산 시스템에서 여러 프로세스 또는 스레드가 공유 자원에 접근하는 것을 제어하기 위해 사용. 다수의 서버 또는 노드 간에 공유 자원을 동시에 접근하는 것을 조절하고 여러 프로세스 또는 서버 간에 공유된 자원에 대한 접근을 동기화하여, 한 번에 하나의 프로세스 또는 스레드만 해당 자원을 사용할 수 있도록 함
- 스핀락 : 멀티 스레드 환경에서 공유 자원에 대한 접근을 제어하기 위한 락 방식 중 하나. 스핀락은 다른 스레드가 락을 헤제할 때까지 해당 자원을 점유하고 있으면서 반복적으로 락을 확인하는데 이를 위해 스레드가 자원을 사용할 수 있을 때까지 계속해서 루프를 돌며 확인하는 방식. 스핀락은 락을 기다리는 동안 계속 CPU를 사용하므로, 다른 락 방식과 비교하여 자원을 비효율적으로 사용할 수 있습니다. 특히 락이 길게 유지되거나 빠른 락 해제가 보장되지 않는 경우에는 성능에 영향을 줌

<br>

### 메시지큐
- 프로세스 또는 프로그램 간에 데이터를 교환할 때 사용하는 통신 방법 중에 하나
- 메세지 지향 미들웨어(Message Oriented Middleware, MOM)를 구현한 시스템을 의미
- 부가적인 서비스를 행할때 던져놓고 되길 기다리며 다른작업을 하기 위해 사용. 당장 실행해서 값을 얻어야하는 서비스들 보다는 부가적인 서비스를 제공할때 쓰임
- 장점은 비동기, 낮은 결합도, 확장성, 보장성 등이 있음
- 구현을 위해 RabbitMQ, Kafka, Redis를 사용

<br>

### Redisson
- Java용 Redis Client로 분산락을 구현하기 위한 다양한 구현체를 제공
- pub/sub 방식으로 락이 해제될 때마다 subscribe 중인 클라이언트들에게 '락 획득을 시도해도 된다.'는 알림을 보내기 때문에 클라이언트 측에서는 락 획득에 실패했을 때, redis에 계속 락 획득 요청을 하는 과정이 사라지게 됨

### Kafka
- pub/sub방식은 생산자 중심적인 설계로 구성. 생성자가 원하는 각 메시지를 게시할 수 있도록 하는 메시지 배포 패턴으로 진행
- 카프카는 큐를 구현하지 않고 토픽이라는 카테고리에 데이터 집합을 저장. 하나의 토픽에 여러개의 파티션을 가질 수도 있음. 각 파티션은 메세지가 지속적으로 추가되며 데이터 순서가 정해져있고, 내용이 바뀌지 않음

### RabbitMQ
- 메시지브로커방식은 브로커 중심적인 설계로 구성. 지정된 수신인에게 메시지를 확인, 라우팅, 저장 및 배달하는 역할을 수행하며 보장되는 메시지 전달에 초점
    - Message Broker(메시지 브로커)는 Publisher(송신자)로부터 전달받은 메시지를 Subscriber(수신자)로 전달해주는 중간 역할으로 송신자가 보낸 메시지를 메시지 큐에 적재하고 이를 수신자가 받아서 사용하는 구조
- 역할은 다음과 같음
    - publisher: 메시지를 보내는 쪽
    - consumer: 메시지를 받는 쪽
    - exchange: publisher가 전달한 메시지를 queue에 전달하는 역할
    - queue: 메시지를 저장하는 버퍼

<br>

### Pub/Sub
- 메시지 큐 시스템, 메세징 패턴 중 하나로 pub(publisher)가 topic에 메시지를 보내면 해당 topic를 구독해놓은 sub(subscriber) 모두 메세지가 전송되면서 데이터 교환이 이루어지는 방법
- Kafka와 Redis가 존재

<br>



<br><br>

---

<br><br>

## DB

<br><br>

### Index
- 데이터베이스에서 검색 속도를 향상시키기 위해 사용되는 데이터 구조. 인덱스는 특정 열(또는 여러 열)에 대한 정렬된 데이터 구조로, 데이터베이스 내에서 레코드의 위치를 빠르게 찾을 수 있도록 도와줌
- 인덱스에 주로 사용되는 효율적인 자료구조인 B+트리로 구성되어 브랜치 노드에는 Key만 두고 data는 담아두지 않음. 오직 리프 노드에만 Key와 data를 저장하여 하나의 노드에 더 많은 키값을 담을 수 있어 트리의 높이가 낮아져 탐색 속도가 빠름
- 인덱스를 생성하면 검색 속도가 향상되지만, 인덱스 자체도 디스크 공간을 차지하고 유지 관리되어야 하기 때문에 모든 열에 인덱스를 생성하는 것은 권장되지 않음
- 크기가 충분히 큰 테이블에 사용하고 Insert, Delete, Update가 자주 발생하지 않는 컬럼이여야 함
- Join, where Order by(Index가 정렬되어 있기 때문에 성능이 향상될 수 있습니다.)를 자주 사용하는 칼럼에 좋음
- 한 칼럼이 가지고 있는 데이터의 중복성이 낮은 칼럼(PK는 고윳값이므로 사용해도 무방)


### isolation 레벨
### 트랜잭션에 대해


### 스트림과

### 디비 인덱싱이 뭔지, 컬럼 선정 기준 

### 멀티 인덱싱하려면 인덱스 컬럼 기준은?


<br><br>

---

<br><br>

## Server

<br><br>

### 트래픽
- 트래픽은 인터넷상에서 송수신 되는 모든 통신의 양

<br>

### 스케일 업, 스케일 아웃
- 대규모 트래픽을 감당하기 위한 확장 방식
- Scale Up : 고성능 CPU, 메모리 확장, SSD 등 서버의 스펙을 높이는 수직 확장 방식. 비용이 많이 들고 용량, 성능 확장에 제한이 있음
- Scale Out : 비슷한 스펙의 서버를 여러대로 증설하여 로드밸런싱을 통한 병렬처리가 가능한 수평 스케일업 아키텍처. 저렴하고 분산처리로 인해 장애 가능성이 낮아지지만 설계가 복잡하고 관리비용이 늘으며 모든 서버의 데이터 일관성을 유지해야함

<br>

### CICD 
### EC2, RDS
### 모놀리틱으로 구현한 이유
- 지금까지 구현한 서비스 규모가 작아 모놀리틱으로 구성하는 것이 문제가 발생하지 않을 것이라고 판단했고 관리가 간편해서. MSA는 오버엔지니어링이라고 판단해서 사용하지 않았음
- 대신 도메인 별로 디렉토리를 구분해두어 특정 도메인이 문제가 발생했을 때 쉽게 유지보수를 진행할 수 있었음

### Jmeter Nglinder

<br><br>

---

<br><br>

## Network

<br><br>

### HTTP 버전

<br>

### 라이트렉트

<br><br>

---

<br><br>

## ETC

### 취미나 특기
```
- 취미는 학창시절에는 배드민턴이나 농구를 주로 했었고 이후에는 게임이나 여행, 만화나 보드게임, 음주나 노래방같은 사람들과 함께하는 활동 전반적인 부분을 좋아합니다
- 특기는 취미도 이렇고 사람을 만나는 행위를 좋아하다보니 계속 강조하는 소통부분인 상담이라고 생각합니다. 제가 저의 이야기를 하는것도 좋아하고 상대방의 이야기를 듣는것도 좋아하는데 제가 남에게 의지하다보니 상대방에게 고맙고 제가 의지된다는 부분도 좋아하는것 같습니다.
```

<br>

### 회사에 궁금한 부분이 있나요?
```
- 만약 입사를 한다면 공부를 해야하는 기술이나 방향이 있나요?
- 협업은 어떤식으로 이루어지는지 궁금합니다.
- 팀에서 갈등이 존재한다면 보통 해결하는 방법은 어떤가요?
```

<br><br>

### DDD, TDD
### 쓰기지연, 게으른 로딩

### REST API
- 웹의 장점을 최대한 활용할 수 있는 아키텍처로 HTTP 아래에서 동작
- REST API는 자원, 행위, 표현으로 이루어져 있음
- REST API 특징은 다음과 같음
    - 유니폼 인터페이스(Uniform Interface) : URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일
    - 무상태성(Stateless) : 작업을 위한 상태정보를 따로 저장하고 관리하지 않음
    - 캐시 가능(Cacheeable) : HTTP 기존 웹표준을 그대로 사용하여 웹에서 사용하는 기존 인프라를 그대로 사용 가능
    - 자체 표현 구조(Self-descriptiveness) : REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조
    - Client-Server 구조 : 각각의 역할이 확실히 구분되어 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어듬
    - 계층형 구조 : REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 중간매체를 사용할 수 있게함

<br>

### 협업 방식 
### 코드리뷰 방식

<br>

### Back Office
- 고객과 무관하게 회사 내부적인 비즈니스 운영을 위한 관리도구
- 전사적인 관점에서 맞는 방향인지, 구현이 가능한지, 구체적인 각 팀의 니즈를 이해한 위에 더 좋은 대안이 있는지 검토하고 최종적으로 개발하는 것은 시스템 전문가인 백오피스 팀이 결정해야함
- 백오피스의 특성상 타 팀에서 의사결정이 내려온다거나 타 팀의 주도로 무언가 해야하는 상황이 빈번
```
백오피스를 지원하는 이유?
- 백오피스는 어드민페이지로 회사내의 여러 인원이 부서별로 사용하는 부분이고 해당 부분을 부서마다 조율하면서 즉각적인 피드백을 받으며 개발이 진행이 가능해서 사실상 회사내의 유저서비스라고 생각하였습니다.
- 아직 네트워크나 트래픽관리부분은 미흡하다보니 현재 백오피스 개발은 좀더 코드를 짜는데 있어 더 기여를 할 수 있을것이라고 생각하였습니다.
```

<br>

### PG (Payments Gateway)
- 결제를 위한 관문이라는 뜻으로 온라인 결제의 핵심으로 신용카드사와 직접적으로 계약을 하기 힘든 온라인 플랫폼 또는 쇼핑몰을 대신해서 결제와 관련된 업무를 대신하는 역할
- 흔히 쇼핑몰이나 앱에서 결제하기 버튼을 누르면 나오는 결제창 또는 결제 모듈이 PG임
- 이런 PG 결제 모듈을 안정적으로 제공하고 BACK 단에서 결제가 안정적으로 될 수 있도록 하는곳이 PG사이며 대표적인 PG 사는 나이스, 토스, 페이먼츠, 이니시스 등이 있음
- 이들 PG사는 쇼핑몰이나 플랫폼, APP을 대신하여 카드사와 직접 결제 제약을 맺어 시중에서 사용 가능한 신용카드, 간편 결제, 계좌이체, 무통장입금, 휴대폰 결제 등 대부분의 결제 수단을 PG 모델에 지원함

<br>

### VAN (Value Added Network)
- PG 서비스는 온라인 결제라면 VAN 서비스는 오프라인 결제를 할 수 있도록 하여 카드사와 상점의 통신을 연결하는 부가가치통신망 역할
- 회선을 소유하는 사업자로부터 통신회선을 빌려 독자적인 통신망을 구성하고 거기에 어떤 가치를 부가한 통신망으로 네트워크를 구축한 다음 이 통신망 이용을 제 3자에게 판매하는 네트워크를 의미
- 즉 VAN은 각각의 카드사와 전용선으로 연결되어 있고 이 통신망을 사용할 수 있도록 중계해주는 것이 핵심
- 오프라인의 각 가맹점에서 실물 결제를 중계하는 역할로 각 카드사와 가맹점의 결제망을 제공하는 것. 포스기나 카드단말기, 키오스크 등 결제를 할 수 있는 모든 수단이 VAN서비스를 통해 결제가 일어나는 것
- VAN사는 본인들의 고객인 오프라인 가맹점의 결제가 원활하게 진행될 수 있도록 결제망을 관리하고 9개 카드사에 결제 정보를 넘기거나 결제 사고를 처리하는 역할 담당
- 카드사는 고객에게 받는 카드 수수료의 일부를 VAN사에게 VAN 전산망 사용료로 지급합니다. 카드사가 진행해야 하는 결제망 유지보수를 VAN사가 진행
- 수수료가 없어 고정비를 줄일 수 있으나 데이터를 안전하고 정확하게 연결해주는 역할만 하며, 매출 정산 등의 추가 서비스는 제공해주지 않는다. 그렇기 때문에 만약 매출 장부 서비스 등을 이용하기 위해선 업주님이 직접 챙겨야 하는 단점이 있다.

<br>

### 내가 진행한 문제 해결 및 개선 사항
- 문제해결 : 스터디를 통한 처음 프로젝트인 경매 프로젝트를 진행할 때 경매 진행을 담당하게 되었는데 경매 진행이나 상품 정보에 동시에 접근하는 상황에 대해 이야기되었습니다. 해당 사항을 막기위해 Redisson을 사용하여 분산락을 사용하였습니다. 해당 방법을 통해 동시성문제를 해결하여 데이터의 일관성을 보장하였습니다.
- 개선사항 : 유리병편지 프로젝트를 진행하면서 기존에는 로그 파일을 통해 로그를 모두 파일로 관리를 진행했는데 매번 EC2에서 확인하는 방법이 불편하여 웹훅과 슬랙 어펜더를 이용하여 슬랙으로 모니터링을 구현하였습니다.
- 개선사항 : 슬랙 로그 전송을 위해 RestTemplate를 사용했는데 해당 프로젝트에서는 24시간 마다 서비스기능에 대한 메시지 전송과 1시간마다 Spring Actuator를 사용해 서버상태의 로그를 전송해주고 있습니다. 해당 사항에 대해 비동기로 실행할 필요가 없다고 판단되어 WebFlux 대신 RestTemplate 를 사용했고 이후 성능 개선을 위해 빈으로 등록하여 싱글톤 패턴으로 변경하였습니다.
- 문제해결 : 유리병 편지의 경우 답변을 작성하는 중 편지 답장 기간인 하루가 만료되어 답변을 작성한 이후 작성을 못하는 경우가 존재할 것이라고 판단되었고 이를 해결하기 위해 java의 Timer 클래스를 사용하여 답변 진행시 30분 가량 상태를 변경하여 처리를 진행하였습니다.
- 문제해결 : 커뮤니티 사이트 프로젝트에서 로컬로그인 인증을 위해 Jwt 토큰을 Filter를 이용하여 처리하려 했으나 스프링 컨텍스트 내의 코드를 사용하지 못하는 문제가 발생하였고 이를 해결하기 위해 기존 아규먼트리조버에서 Jwt를 처리하였고 이후 문제가 해결되었습니다. 기존 스프링 시큐리티에 대한 좁은 이해로 유사한 방법으로 구현하려다 보니 발생한 문제였습니다.

<br>

### https://daiso.saramin.co.kr/_service/daiso/apply_site/apply/recruit_default.asp
### https://velog.io/@tololong001/JAVA### 기술### 면접### 질문
### https://blog.naver.com/businessinsight/222931817164