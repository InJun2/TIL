# 면접 대비 정리

## JAVA & Spring

<br><br>

### 절차지향 프로그래밍 vs 객체 지향 프로그래밍
- 둘다 명령형 프로그래밍으로 선언형 프로그래밍과 구분되는 프로그래밍 패러다임임
- 명령형 프로그래밍은 무엇을 할 것인지보다 어떻게 할 것인지를 설명하는 방식
- 절차지향 프로그래밍 : 수행되어야 할 순차적인 처리과정을 포함하는 방식. 유지보수가 어렵고 코드의 순서가 바뀌면 동일한 결과를 보장하기 어려움
- 객체지향 프로그래밍 : 객체들의 집합으로 프로그램의 상호작용을 포함. 코드를 재사용하고 신뢰성 있는 소프트웨어를 쉽게 작성 가능하지만 속도가 느리고 설계에 많은 시간 소요

<br>

### 함수형 프로그래밍
- 선언형 프로그래밍으로 어떻게 할건지를 나타내기보다는 무엇을 할 것인지 설명하는 방식
- 함수형 프로그래밍 : 순수 함수를 조합하고 소프트웨어를 만드는 방식
- 함수형 프로그래밍은 대입문이 없는 프로그래밍으로 작은 문제를 해결하기 위한 함수를 작성
- 함수형 프로그래밍은 명령형 프로그래밍 기반 개발에는 소프트웨어 크기가 커짐에 따른 스파게티 코드를 유지보수하는 것이 힘들어 해당 프로그래밍 패러다임에 관심을 가지게 됨

<br>

### OOP?
- 객체지향 프로그래밍으로 기존의 내용을 재사용 가능하고 유지보수성이 높음
- 프로그램을 독립된 단위인 객체들의 모임으로 보고 각각의 객체즌 메시지를 주고 받고 데이터를 처리함

<br>

### OOP의 특징 4가지
- 추상화 : 핵심 코드만 노출
    - 불필요한 부분을 숨기고 인터페이스와 구현을 분리
    - 구현객체에 의존하지 않고 추상객체인 인터페이스에 의존
캡슐화 : 데이터 보호
    - 필드와 메서드를 하나로 묶는 것
    - 객체의 세부 내용이 외부에 드러나지 않아 외부에서 데이터를 직접 접근하는 것을 방지
상속 : 코드 재사용
    - 자식 클래스가 부모클래스의 특징과 기능을 물려받는 것
    - 클래스를 상속받아 수정하여 사용하기 때문에 중복 코드 줄일 수 있음
    - 부모 클래스의 수정은 모든 자식클래스들도 수정
다형성 : 객체 변경 용이
    - 어떤 변수, 메소드가 상황에 따라 다른 결과를 내는 것
    - 오버라이딩(Overriding) : 부모클래스 메서드를 자식클래스에서 재정의 하는 것
    - 오버로딩(Overloading) : 한 클래스에서 메서드 이름은 같지만 파라미터 개수나 자료형이 다르면 서로 다르게 동작

<br>

### JVM, JDK, JRE
- JVM(Java Virtual Machine) : 자바 가상 머신으로 바이너리 코드 읽기/검증/실행. 실행 환경(Runtime Environment)의 규격을 제공
- JRE(Java Runtime Environment) : 자바 실행환경으로 JVM이 자바 프로그램을 동작 시킬 때 필요한 라이브러리 파일과 기타 파일들을 가지고 있음. JRE는 JVM의 실행 환경을 구현한 것
- JDK(Java Development Kit) : 자바 개발 도구로 JRE + 개발을 위해 필요한 도구(javac, java)들을 포함함

<br>

### 자바의 버전별 차이 (Long Term Support)
- JDK8
    - 람다 표현식 : 별도의 익명 클래스를 만들어서 선언하던 방식을 람다를 통해 대폭 간소화 및 함수형 프로그래밍, 스트림 API 그리고 컬렉션 프레임워크의 개선 등에 영향을 줌
    - 함수형 인터페이스 : 람다 표현식을 사용할 때 만들어야 하는 하나의 메서드를 가진 인터페이스 생성을 줄여줌. 람다 표현식을 사용하기 위한 표준 가이드
    - 메서드 참조 : 특정 메서드를 메서드의 인자로 전달이 가능해짐
    - 스트림 API : 람다 표현식, 함수형 인터페이스, 메서드 참조를 이용한 최종 산출물. 코드를 간결하게 처리 가능
    - Optioanl : NullPointerException 발생하는 것 방지. null이 허용되어 값을 확인하고 관리할 수 있는 기능
    - 인터페이스 개선 : interface 내부에서 default 메서드 선언 가능
    - CompletableFuture : 멀티 스레드 프로그래밍 시 중요한 기능인 CompletableFuture는 기존 Future 인터페이스에서 제공하는 기능 개선
    - 날짜와 시간 API : 기존 Date와 Calendar 클래스의 문제 해결
- JDK11
    - Http 클라이언트 : HTTP 클라이언트 API 포함. HTTP 2.0을 지원하여 웹 소캣 기능 포함
    - ToArray : 컬렉션 인터페이스에 ToArray 메서드가 추가. 이 메서드를 통해서 컬렉션 객체를 배열로 변환하면 별도의 반복문을 작성하지 않고 메서드 호출만으로 처리
    - var키워드 지원 확대 : JDK10에서 타입 추론으로 객체를 생성하는 var 키워드의 기능 추가. 람다 표현식에도 var를 사용해서 변수 선언 가능
    - String 클래스 기능 추가 : 문자열을 표현하는 String 클래스에 편리하게 사용할 수 있는 메서드 추가 (isBlank, Lines, strip, stripLeading, stripTrailing)
- JDK17
    - Pattern Matching for switch : Switch문에서 입력을 객체를 전달하여 기능을 전환하고 특정 유형을 확인 가능
    - Sealed Classes : 상속 가능한 클래스를 지정할 수 있는 봉인 클래스 제공. 상속가능한 대상은 상위 클래스 또는 인터페이스 패키지 내에 속해 있어야 하며 해당 기능은 JDK15에 처음 제공하고 JDK17 에서 기능 완료
    - Foreign Function & Memory API : Java Native Interface를 대체. 기본 함수를 호출하고 JVM 외부의 메모리에 엑세스 가능
    - Deprecating the Security Manager : 보안 관리자 제거
    - 기능 보다는 가장 최신 LTS로 가장 오랜 지원 기간 보유 및 이후 신규 버전과 다음 세대 플랫폼을 위해 준비

<br>

### JVM 구조 및 실행 과정
- 1. 소스 코드(java 파일)를 Java Compiler를 통해 바이트 코드(class 파일)로 변환
- 2. 바이트 코드를 Class Loader에 보냄. 클래스 로더는 클래스 파일을 불러와 메모리에 저장함
- 3. Execution Engine는 Class Loader에 저장된 Byte Code를 명령어 단위로 분류하여 하나씩 실행하게 해주는 엔진
- 4. Garbage Collector는 사용하지 않거나 필요없는 객체들을 메모리에서 수멸시키는 역할
- 5. RuntimeData Area(Memory Area)는 JVM이 프로그램을 수행하기 위해 운영체제로부터 할당받은 메모리 공간임

<br>

### 자바 메모리 구조
- 위에서의 자바 메모리 영역 구조(RuntimeData Area, Memory Area)는 다음과 같음
    - Method Area
        - JVM이 실행되면서 생기는 공간
        - Class 정보, 전역 변수, Static 변수 정보가 저장되는 공간
        - 해당 영역 안에는 Runtime Constant Pool이 존재하고 해당 영역에는 '상수' 정보가 저장됨
        - 모든 스레드가 공유하는 메모리 영역
    - Heap
        - new 연산자로 생성된 객체, Array와 같은 동적으로 생성된 데이터가 저장되는 공간
        - Heap에 저장된 데이터는 Garbage Collector가 처리하지 않는 한 소멸되지 않음
        - Reference Type의 데이터가 저장되는 공간
        - 모든 스레드가 공유하는 메모리 영역
    - Stack
        - 지역변수, 메소드의 매개변수와 같이 잠시 사용되고 필요가 없어지는 데이터가 저장되는 공간
        - Last In First Out으로 나중에 들어온 데이터가 먼저 나감
        - 지역변수이지만 Reference Type일 경우 Heap에 저장된 데이터 주소값을 Stack에 저장해서 사용하게 됨
        - 스레드마다 하나씩 존재
    - PC Register
        - 스레드가 생성된면서 생기는 공간
        - 스레드가 어느 명령어를 처리하고 있는지 그 주소를 등록 
        - JVM이 실행하고 있는 현재 위치를 저장하는 역할
    - Native Method Stack
        - Java가 아닌 다른 언어로 구성된 메소드를 실행이 필요할 때 사용되는 공간

<br>

### 기본형 타입 (Primitive type)
- 실제 값을 저장하는 공간으로 Stack 메모리에 저장됨
- 논리형 : boolean
- 정수형 : byte, short, int, long
- 실수형 : float, double
- 문자형 : char

<br>

### 참조형 타입 (Reference type)
- 기본형 타입을 제외한 타입들이 모두 참조형 타입
- 빈 객체를 의미하는 Null이 존재하며 값이 저장되어 있는 곳의 주소값을 저장하는 공간으로 Heap 메모리에 저장됨
- 배열, 열거, 클래스, 인터페이스 등이 포함됨

<br>

### 일급 객체(First Class Object)
- 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가르킴
- 일급 객체 조건
    - 변수나 데이터에 담을 수 있어야 함
    - 다른 함수를 파라미터로 전달 할 수 있어야함
    - 다른 함수의 결과로서 리턴될 수 있어야 함

<br>

### 일급 컬렉션 (First Class Collection)
- 일급 컬렉션(First Class Collection)은 Collection을 Wrapping 하면서 그 외의 다른 멤벼 변수가 없는 상태를 일급 컬렉션이라고 함
- 일급 컬렉션의 이점은 다음과 같음
    - 비지니스에 종속적인 자료구조 : 서비스 메서드에서 구현을 한다면 해당 객체가 들어간 모든 장소에서 유효성 검증이 필요한 문제점이 발생하는데 생성자로 생성시 유효성 검사를 진행해 쉽게 해결
    - Collection의 불변성을 보장 : final은 재할당만을 금지하는데 final로 만들 수 없는 불변 객체는 일급 컬렉션과 래퍼 클래스의 방법으로 해결해야 함
    - 상태와 행위를 한 곳에서 관리 : 메서드들을 일급컬렉션 내에 만들어 두어 외부에서는 호출만 하고 상태와 행위를 한곳에서 관리 가능. 일급 컬렉션은 값과 로직이 함께 존재하여 외부에서 중복된 메서드의 생성과 같은 문제를 해결해줌
    - 이름이 있는 컬렉션 : 해당 객체들을 변수명으로만 검색하는것은 어렵고 단순히 변수명에 불과하여 의미 부여가 어려운데 특정 컬렉션을 사용해서 구분

<br>

### static, final
- static
    - "고정된" 이라는 의미로 객체 생성 없이 사용할 수 있는 필드와 메소드를 생성하고자 할 때 사용하며 "클래스이름.필드"로 객체 인스턴스 생성없이 사용
    - 공용데이터나 인스턴스 필드를 포함하지 않는 메소드를 선언하고자 할 때 이용
    - 정적 메소드는 객체 참조 없이 바로 사용할 수 있는 특징 때문에 인스턴스 필드나 메소드, 그리고 this 키워드를 사용할 수 없음
- final
    - "최종적인" 이라는 의미로 해당 변수는 값이 저장되면 최종적인 값이 되므로 수정이 불가능하다는 의미
    - 변수를 처음 초기화하여 값을 할당해준 이후 변경이 불가능함

<br>

###  클래스, 객체, 인스턴스
- 클래스(Class) : 객체를 만들어 내기 위한 설계도 혹은 틀. 연관되어 있는 변수와 메서드의 집합
- 객체(Object) : 소프트웨어 세계에 구현할 대상. 클래스에 선언된 모양에 맞게 만들 실체
- 인스턴스(Instacne) : 설계도를 바탕으로 소프트세계에 구현된 구체적인 실체. 객체를 소프트웨어에 실체화 하면 그것을 '인스턴스'라고 하며 실체화된 인스턴스는 메모리에 할당됨. 인스턴스는 객체에 포함된다고 볼 수 있음

<br>

### Enum
- 관련이 있는 상수들의 집합
- 자바에서는 final 키워드로 기본 자료형의 값을 고정가능하며 이렇게 고정된 값을 상수라고 함
- 파일을 Class로 선언하지 않고 Enum 타입으로 선언하여도 됨

<br>

### Annotation
- 사전적인 의미로는 '주석'이라는 의미
- 자바에서 어노테이션은 코드 사이에 주석처럼 쓰이며 특별한 의미, 기능을 수행하도록 하는 기술로 프로그램에게 추가적인 정보를 제공해주는 메타데이터라고 볼수 있음
- 어노테이션 사용순서는 다음과 같음
    1. 어노테이션 정의
    2. 클래스에 어노테이션을 배치
    3. 코드가 실행되는 중에 Reflection을 이용하여 추가 정보를 획득하여 기능을 실시

<br>

### Reflection
- 

<br>

### 스프링 동작 과정

<br>

### IOC, DI

<br>

### 엔티티 vs dto, 구분하는 이유

<br>

### 싱글톤이란? 장단점

<br>

### 싱글톤 vs 프로토타입

<br>

### 스프링 빈이 무엇이고 그것의 라이프사이클 

<br>

### @requiredArgsConstructor 사용이유 

<br>

### 스프링에서 생성자 주입을 권장하는 이유 

<br>

### projection 사용해서 성능 향상한 방법 

<br>

### jdbc vs jpa

<br>

### ORM이란

<br>

### @table 이랑 @entity 사용 이유 

<br>

### @Transactional 이란

<br>

### jpa로 바꿔도 네이티브 쿼리 많이 쓴다면 jpa를 쓰는 의미가 있는지

<br>

### functional interface가 무엇인지 및 예시함수

<br><br>

---

<br><br>

## OS

<br><br>

### 프로세스와 스레드의 차이
### 동기화
### 동기화 락
### 메시지큐
### 레비넴큐
### 카프카
### java로 어플리케이션 단에서 동시성 제어하는 방법
### Index
### oauth 로그인 과정 


<br><br>

---

<br><br>

## DB

<br><br>

### fetchjoin 이란? 
### fetchjoin말고 n+1 문제를 해결하는 방법 
### isolation 무슨 레벨
### 트랜잭션에 대해

### msa vs 모노리틱 장단점 
### 스트림과 그 관련 메소드 아는거 설명해주세요 

### 디비 인덱싱이 뭔지, 컬럼 선정 기준 

### 순환참조
### 멀티 인덱싱하려면 인덱스 컬럼 기준은?


<br><br>

---

<br><br>

## Server

<br><br>

### CICD 
### EC2, RDS
### RD

<br><br>

---

<br><br>

## Network

<br><br>

### HTTP 버전

<br><br>

---

<br><br>

## ETC

<br><br>

### DDD, TDD
### 협업 방식 
### 코드리뷰 방식


### https://daiso.saramin.co.kr/_service/daiso/apply_site/apply/recruit_default.asp
### https://velog.io/@tololong001/JAVA### 기술### 면접### 질문
### https://blog.naver.com/businessinsight/222931817164