# HTTP Method

### HTTP API 만들기 전에
- URI 에서 리소스란 특정 자원을 의미함
- 회원 조회시에 URI를 설계할 때 /search-members/{id} 가 아니라 리소스 위주의 /members/{id} 가 되어야 함 ( URI 는 리소스만 식별 )
- 위의 URI는 역할에 따라 구분하는 방법으로는 행위, HTTP Method 를 따로 사용함 ( 리소스와 해당 리스소를 대상으로 하는 행위를 분리 )
- HTTP Method 종류
    - GET : 리소스 조회
    - POST : 요청 데이터 처리, 주로 등록에 사용
    - PUT : 리소스를 대체, 해당 리소스가 없으면 생성
    - PATCH : 리소스 부분 변경
    - DELETE : 리소스 삭제
- HTTP 기타 메서드
    - HEAD : GET과 동일하지만 메시지 부분을 제외하고 상태줄과 헤더만 반환
    - OPTIONS : 대상 리소스에 대한 통신 가능 옵션(메서드)를 설명 (주로 CORS)
    - CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
    - TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

### HTTP Method

#### 1. GET
- 리소스 조회
- 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리스트링)를 통해서 전달
- 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아 권장하지 않음
```http
GET /members/100 HTTP/1.1
Host: localhost:8080
```

#### 2. POST
- 요청 데이터 처리
    - POST 메서드는 대상 리소스가 리소스의 고유한 의미 체계에 따라 요청에 포함된 표현을 처리하도록 요청
    - 이 리소스 URI에 POST요청이 오면 요청 데이터를 어떻게 처리할지 리소스마다 따로 정해야 함 -> 정해진 것이 없음
- 메시지 바디를 통해 서버로 요청 데이터 전달
- 서버는 요청 데이터를 처리
    - 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행
- 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용

```http
POST /members HTTP/1.1
Content-Type:application/json

{
    "username":"young",
    "age":20
}
```

#### 3. PUT
- 리소스를 대체, 리소스가 없으면 생성 -> 리소스를 덮어버림
- 클라이언트가 리소스를 식별 -> 클라이언트가 리소스 위치를 알고 URI 지정, POST와 차이점

#### 4. PATCH
- 리소스 부분 변경

#### 5. DELETE
- 리소스 제거

<br>

### HTTP 메서드 속성
#### 1. 안전 (Safe)
- 호출해도 리소스를 변경하지 않는다
- 안전은 해당 리소스만 고려하여 다른 부분은 고려하지 않음

#### 2. 멱등 (Idempotent)
- f(f(x)) = f(x)
- 한번 호출하던 두번 호출하던 100번 호출하던 결과가 똑같음
- 멱등은 외부 요인으로 중간에 리소스가 변경되는 것 까지는 고려하지 않음
- 멱등메서드 ( POST는 멱등메서드가 아님 )
    - GET
    - PUT
    - DELETE

#### 3. 캐시가능 (Cacheable)
- 응답 결과 리소스를 캐시해서 사용해도 되는가?
- GET, HEAD, POST, PATCH 캐시 가능
- 실제로는 GET, HEAD 정도만 캐시로 사용 -> POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데 구현이 어려움

<br>

## HTTP 메서드 활용

### 클라이언트에서 서버로 데이터 전송
- #### 쿼리 파라미터를 통한 데이터 전송
    - GET
    - 정렬 필터 (검색어)
- #### 메시지 바디를 통한 데이터 전송
    - POST, PUT, PATCH
    - 회원가입, 상품주문, 리소스 등록, 리소스 변경

<br>

#### 정적 데이터 조회
- 쿼리 파라미터 미사용
```http
GET /static/star.jpg HTTP/1.1
Host: localhost:8080
```

#### 동적 데이터 조회
- 쿼리 파라미터 사용
- 주로 검색, 게시판 목록에서 정렬 필터 (검색어)
- 조회는 GET 사용
- GET은 쿼리 파라미터 사용해서 데이터를 전달
```http
GET /seacrh?=hello&hl=ko HTTP/1.1
Host: www.google.com
```

#### HTML Form 데이터 전송
- POST 전송
- HTML Form submit시 POST 전송
- Content-Type: application/x-www-form-urlencoded 사용
    - form 의 내용을 메시지 바디를 통해서 전송 (key=value, 쿼리 파라미터 형식)
    - 전송 데이터를 url encoding 처리
- HTML Form은 GET 전송도 가능
- Content-Type : mulitpart/form-data
    - 파일 업로드 같은 바이너리 데이터 전송시 사용
    - 다른 종류의 여러 파일과 폼의 내용 함께 전송 가능
* HTML Form 전송은 GET, POST 만 지원함

```http
POST /save HTTP/1.1
Host: localhost:8080
Content-Type: application/x-www-form-urlencoded

username=kim&age=20
```

#### HTTP API 데이터 전송
- 서버 to 서버
- 앱 클라이언트
    - 아이폰, 안드로이드
- 웹 클라이언트
    - HTML 에서 Form 전송 대신 자바 스크립트를 통한 통신에 사용 (AJAX)
    - React, VueJs 같은 웹 클라이언트와 API 통신
- POST, PUT, PATCH : 메시지 바디를 통해 데이터 전송
- GET : 조회, 쿼리 파라미터로 데이터 전달
- Content-Type: application/json 을 주로 사용 (사실상 표준)
    - TEXT, XML, JSON 등등

```http
POST /members HTTP/1.1
Content-Type:application/json

{
    "username":"young",
    "age":20
}
```

## Ssafy Wizards CS Study

<br>

### 1. HTTP Method의 멱등성
- 멱등성(Idempotence)은 같은 요청을 여러 번 수행하더라도 서버의 상태가 동일하게 유지되는 특성을 의미
- 클라이언트가 동일한 요청을 여러 번 보내더라도 서버의 상태가 처음 요청을 보냈을 때와 동일하게 유지된다면 해당 HTTP 메서드는 멱등성을 가지는 것
    - PUT 요청은 멱등성을 가지는데 동일한 PUT 요청을 여러 번 보내더라도, 서버에 저장된 리소스는 동일한 상태로 유지됨

| HTTP 메서드 | 멱등성 | 설명                             |
|-------------|--------|----------------------------------|
| GET         | Yes    | 리소스 조회                      |
| PUT         | Yes    | 리소스 생성 또는 업데이트        |
| DELETE      | Yes    | 리소스 삭제                      |
| POST        | No     | 리소스 생성 또는 데이터 추가     |
| PATCH       | No     | 리소스 일부 업데이트             |

<br>

### 2. GET과 POST의 차이
- GET 메서드는 주로 리소스를 조회하는데 사용되며 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리스트링)를 통해서 전달함
- POST 메서드는 주로 리소스 생성 및 데이터 요청 처리에 사용되며 메시지 바디를 통해 서버로 요청 데이터 전달함

| 구분      | GET                                  | POST                                   |
|-----------|--------------------------------------|----------------------------------------|
| 목적      | 리소스 조회                          | 리소스 생성 또는 데이터 전송            |
| 데이터 전송 | URL 쿼리 스트링에 포함 (길이 제한 있음) | 요청 본문에 포함 (길이 제한 없음)      |
| 멱등성    | Yes                                  | No                                     |
| 캐싱      | 가능                                 | 일반적으로 불가                        |
| 보안      | URL에 데이터가 노출됨                | 요청 본문에 포함되어 상대적으로 안전    |

<br>

### 3. POST와 PUT, PATCH의 차이
- POST는 위와 같이 리소스에 대해 생성하거나 데이터를 처리를 위한 전송에 사용됨
- PUT의 경우 요청 변경사항을 통해 리소스를 생성하거나 전체 업데이트 됨
- PATCH의 경우 요청 변경사항에서 변경된 사항만 (리소스의 일부만) 업데이트가 진행되어 특정 필드만 업데이트 됨

| 구분       | POST                                 | PUT                                      | PATCH                                   |
|------------|--------------------------------------|------------------------------------------|-----------------------------------------|
| 목적       | 리소스 생성 또는 데이터 전송          | 지정된 리소스를 생성 또는 전체 업데이트 | 리소스의 일부를 업데이트               |
| 멱등성     | No                                   | Yes                                      | No                                      |
| 동작 방식  | 서버에서 새로운 리소스 생성            | 서버에 리소스를 생성하거나 전체를 덮어씀 | 리소스의 특정 필드만 변경              |
| 데이터 전송 | 요청 본문에 포함                      | 요청 본문에 포함                         | 요청 본문에 포함                       |
| 사용 예시  | 새 사용자 생성                        | 사용자 전체 정보 업데이트                | 사용자 정보의 일부 필드 업데이트       |


<br>

### 4. HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었음에도 왜 아직도 이런 방식을 지양하는가
- GET 에서 Body에 데이터를 포함하는 것에 대해 명확한 표준이 존재하지 않음
- 기존 웹 서버, 프록시 서버, 캐시 서버에서는 GET 요청의 본문에 대해 처리하지 않을 수 있어 호환성 문제가 발생할 수 있음
- GET 요청을 일반적으로 멱등성을 가지므로 캐싱이 가능한데 캐싱 메커니즘에 혼란을 주거나 멱등성 보장에도 문제가 생길 수 있음
    - 캐싱은 주로 URL 만을 기준으로 관리