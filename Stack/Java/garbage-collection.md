# Garbage Collection

### GC
- Java 기반 언어에서 사용되어 메모리 관리를 자동으로 수행
- GC는 프로그램이 동적으로 할당한 메모리 중 더 이상 사용되지 않는 객체를 자동으로 식별하고 해제하는 프로세스
- 메모리 누수를 방지하고 사용 가능한 메모리를 확보하여 프로그램이 원활하게 실행될 수 있도록 함

<br>

### GC 주요 역할
- 메모리 해제 : 더 이상 참조되지 않는 객체를 찾아 메모리에서 해제
- 메모리 누수 방지 : 사용되지 않는 메모리가 지속적으로 쌓여 메모리 부족 발생 방지
- 프로그램 안전성 향상 : 자동 메모리 관리를 통해 개발자가 메모리 해제 작업을 수동으로 하지 않아도 되므로 메모리 관리와 관련된 버그를 줄임

<br>

### 주요 사용 알고리즘
- Mark and Sweep
    - Mark 단계: GC는 프로그램의 루트에서 시작하여 모든 접근 가능한 객체를 탐색하고 마크
    - Sweep 단계: 마크되지 않은 객체를 메모리에서 해제
    - Generational Garbage Collection: 객체를 세대별로 나누어 관리
- Young Generation: 새로 생성된 객체들이 위치하며, 이 중 대부분은 수명이 짧아 Young Generation에서 주로 발생하는 GC를 Minor GC라고 함
    - Old Generation: Young Generation을 지나 장기간 참조되는 객체들이 위치하고 Old Generation에서 발생하는 GC를 Major GC 또는 Full GC라고 함
    - Permanent Generation (Metaspace): 클래스 메타데이터와 같은 JVM의 구조적 데이터를 저장

<br>

## 질문

### 1. finalize()를 수동으로 호출하는 것은 왜 문제가 될 수 있는지?
- Java에서 GC는 자동으로 관리되지만, 수동으로 호출이 가능한데 수동으로 호출하는 메서드 중 finalize()도 존재
-  이 메서드는 객체가 GC되기 전에 정리 작업을 수행하기 위해 호출되므로 문제 야기
    - 예측 불가능한 실행 순서 : JVM에 의해 호출되는 시점이 예측 불가능하여 프로그램 예측할 수 없게 됨
    - 메모리 누수 : 객체가 여전히 참조되고 있어 GC 되지 않을 수 있음
    - 오버헤드 증가 : 해당 메서드는 GC의 성능을 저하시킬 수 있는 오버헤드를 추가하여 불필요한 오버헤드 발생 가능
    - 자원 해제 실패 : finalize()에서 예외 발생시 이를 잡을 방법이 없어 자원해제 실패 가능
    - Deprecated  : 해당 메서드는 Java9 이후로 권장되지 않아 다른 자원 해제 매커니즘을 사용하는 것이 좋음

<br>

### 2. 어떤 변수의 값이 null이 되었을 때 이 값이 GC가 될 수 있는지?
- Java에서 어떤 변수의 값이 null로 설정되면 그 변수는 더 이상 객체를 참조하지 않게 되어 사용되지 않으므로 GC의 대상이 될 수 있음
- 조건은 다음과 같음
    - 다른 참조가 없는 경우 : 객체를 참조하는 다른 변수가 없을 때 객체는 GC의 대상이 됨. 모든 참조가 끊어졌을 때만 해당 객체는 메모리에서 해제될 수 있음
    - 스코프 : 변수가 null로 설정되더라도 변수의 스코프 내에서는 여전히 참조가 유지됨. 메서드가 끝나거나 변수가 더 사용되지 않는 경우에 스코프에서 벗어나 GC가 적용될 수 있음
- GC 주의 사항
    - 즉시 해제되지 않음 : 객체가 null로 설정되었다고 해서 즉시 메모리에서 해제되는 것은 아니며 JVM에 의해 관리됨
    - 메모리 관리 : 명시적으로 null을 설정하여 객체를 해제하는 것은 유효할 수 있으나 일반적으로 자동 메모리 관리를 신뢰하는 것이 좋음