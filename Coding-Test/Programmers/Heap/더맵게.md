### 더 맵게

### 문제 설명
- 매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.
```
 섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2) 
 ```
- Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.
- Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.

<br>

### 제한 사항
- scoville의 길이는 2 이상 1,000,000 이하입니다.
- K는 0 이상 1,000,000,000 이하입니다.
- scoville의 원소는 각각 0 이상 1,000,000 이하입니다.
- 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.

<br>

### 입출력 예
|scoville|K|return|
|:---:|:---:|:---:|
|\[1, 2, 3, 9, 10, 12\]|7|2|

<br>

## 풀이
### 첫 번째 풀이
- 그냥 큐에 넣어두고 큐에서 꺼냈을때 K보다 클때까지 반복하고 횟수를 리턴하면 되는거 아닌가?
- 실행결과도 조금 틀리고 효율성도 박살났음..

```java
import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

class Solution {
    public int solution(int[] scoville, int K) {
        int answer = 0;
        Queue<Integer> heap = new LinkedList<>();

        Arrays.sort(scoville);
        
        for (int scov : scoville) {
            heap.offer(scov);
        }

        while (heap.peek() <= K) {
            if (heap.size() == 1) {
                return -1;
            }
            int a = heap.poll();
            int b = heap.poll();



            heap.offer(a + (b * 2));
            answer ++;
        }

        return answer;
    }
}
```

<br>

### 두 번째 풀이
- 우선순위 큐를 사용해보자
- 겸사겸사 굳이 peek을 할 필요가 없는걸 깨달아버려서 먼저 꺼낸걸 저장해두고 다음 꺼낸 값과 비교하기로 하였다

```java
import java.util.Arrays;
import java.util.PriorityQueue;

class Solution {
    public int solution(int[] scoville, int K) {
        int answer = 0;
        PriorityQueue<Integer> scovBox = new PriorityQueue();

        Arrays.sort(scoville);

        for (int scov : scoville) {
            scovBox.offer(scov);
        }

        while (!scovBox.isEmpty()) {
            int worstScov = scovBox.poll();

            if(worstScov >= K) {
                break;
            }

            if (scovBox.size() == 0) {
                return -1;
            }

            int worstScov2 = scovBox.poll();
            int result = worstScov + (worstScov2 * 2);
            scovBox.offer(result);
            answer ++;
        }

        return answer;
    }
}
```

<br>

### 문제 링크
- https://school.programmers.co.kr/learn/courses/30/lessons/42626

<br>

## Reference
- https://yubh1017.tistory.com/23