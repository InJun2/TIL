# Scheduling

### 스케줄링
- 컴퓨터의 자원을 보다 효율적으로 이용하기 위해 작업순서와 시간을 할당하는 것 -> 컴퓨터 자원을 어떤 작업에 할당할지 결정하는 것
- 프로세스들이 자원을 사용하는 순서를 결정하는 일
- 프로세스가 자원을 할당 받는 것은 스케줄러부터 CPU를 할당 받아야 함
- CPU를 강제로 빼앗을 수 있는지에 따라 선점형(preemptive), 비선점형(non-preemptive) 스케줄링으로 나눌 수 있음

#### 스케줄링의 목적
- 공정한 스케줄링 : 모든 프로세스에게 공정하게 할당해야 함
- 응답시간 최소화 : 대화식 사용자에게는 최대한 응답시간을 빠르게함
- 반환시간 최소화 : 프로세스를 제출한 시간부터 완료시까지 걸리는 반환시간을 최소화 함
- 대기시간 최소화 : 프로세스 준비상태 큐에서 대기하는 시간을 최소화 해야함. 앞에서 처리가 늦어지면 뒤에서 부하가 생김
- 우선 순위 제도 : 먼저 처리해야 하는 것에 우선순위를 부여해서 먼저 처리 함
- 처리량 극대화 : 단위시간당 할 수 있는 처리량을 최대화 함
- 무한 연기 회피 : 자원을 사용하기 위해 무한정 연기하는 경우를 회피

<br>

### 선점형 스케줄링 (Preemptive Scheduling)
- CPU를 강제로 점유할 수 있음
- 빠른 응답을 요구하는 대화식 시분할 시스템에 적합
- context switching에 대한 overhead가 많이 발생 -> 경쟁 상태를 발생할 수 있음
- 응답이 빠르므로 실시간 응답을 요구하는 시스템에 적합
- 라운드 로빈 방식, SRT, 선점 우선 순위 알고리즘이 있음

<br>

### 비선점형 스케줄링 (Non-preemptive Scheduling)
- 작업이 완료될 때까지 다른 작업이 CPU를 점유할 수 없음 (독점)
- 일괄 처리 시스템에 적합
- 순서대로 처리 보장
- 응답 시간 예측이 가능
- 선점형 방식에 비해 context switching 으로 인한 overhaed가 적음
- 작업이 끝날 때 까지 다른 프로세스들은 대기해야 하므로 처리율이 떨어질 수 있음 
- FCFS, SJF, 우선순위, HRN 등이 있음 -> 높은 우선순위가 먼저 실행되고 낮은 작업이 기다리게 됨

<br>

![Scheduling Flow](./img/Scheculing_Flow.png)

### 스케줄링 알고리즘
- 스케줄링 알고리즘은 다음과 같은 기준을 통해 평가 할 수 있음
    - CPU 사용률(CPU Utilization) : 전체 시스템 시간 중 CPU가 작업을 처리하는 시간의 비율
    - 처리량(Throughput) : CPU가 단위 시간당 처리하는 프로세스의 개수
    - 응답 시간(Response Time) : 대화식 시스템에서 요청 후 응답이 오기 시작할 때까지의 시간
    - 대기 시간(Waiting Time) : 프로세스가 준비 큐 내에서 대기하는 시간의 총합
    - 반환 시간(Turnaround Time) : 프로세스가 시작해서 끝날 때까지 걸리는 시간 (대기 + 실행시간)

<br>

### 선점형 스케줄링 알고리즘 종류
- #### SRT 스케줄링 (Shortest Remaining Time)
    - 짧은 시간 순서대로 프로세스를 수행하는 방식
    - 남은 처리 시간이 더 짧은 프로세스가 Ready Queue에 들어오면 그 프로세스가 바로 선점됨
- #### 라운드 로빈 스케줄링 (Round Robin Scheduling)
    - 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간 단위(time slice, quantum)로 CPU를 할당하는 방식. 대표적인 선점형 방식
    - 라운드 로빈 방식은 타임 슬라이스(선점형 스케줄링에서 cpu를 점유하도록 허용된 시간)를 적당한 크기로 설정하는 것이 중요
    - 타임 슬라이스가 너무 클 경우 : 응답 시간이 느려짐
    - 타임 슬라이스가 너무 작을 경우 : context switching으로 인한 overhead가 커짐
    - 타임 슬라이스만큼 순차적으로 할당하기 때문에 기아 현상이 발생하지 않으나 context switching으로 인한 overhead가 발생
    - 우선순위가 따로 없기 때문에 중요도에 따라 우선순위를 다르게 두고 CPU를 할당하고 싶을 경우 우선순위 스케줄링 방식과 함께 사용해야 함
- #### 다단계 큐 스케줄링 (Multilevel Queue Scheduling)
    - 우선순위에 따라 준비 큐를 여러 개 사용하는 방식 (단순히 큐를 여러개 사용하는 멀티큐가 아니라 우선순위가 부여된 멀티 레벨 큐)
    - 각각의 큐에 서로 다른 방식의 스케줄링 알고리즘을 적용시킬 수 있음
    - 우선 순위에 따라 순서제어가 가능하고 우선순위에 따라 타임 슬라이스를 조절하여 작업 효율을 높일 수 있음
    - 우선 순위가 높은 프로세스에 의해 우선순위가 낮은 프로세스의 작업이 연기될 수 있음
    - 프로세스가 하나의 큐에 영구적으로 할당되는 방식이기 때문에 상황에 맞게 큐를 갈아탈 수 없음
- #### 다단계 피드백 큐 스케줄링 (Multilevel Feedback Queue Scheduling)
    - 우선순위를 변경할 수 없는 MQ에서 한단계 발전한 알고리즘으로 프로세스의 우선순위의 변경이 가능한 방식
    - CPU를 사용하고 난 프로세스는 한단계 낮은 큐로 다시 삽입됨 -> 우선순위가 낮아져도 커널 프로세스가 일반 프로세스 큐에 삽입되지 않음
    - MLFQ는 우선순위에 따라 타입 타입 슬라이스 크기가 다름 (우선순위가 낮을수록 타임 슬라이스 크기가 증가)
    - 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스보다 CPU를 얻을 기회가 더 적기 때문에 타임 슬라이스를 크게 설정하여 더 오랫동안 CPU를 점유할 수 있도록 함
    - 오늘날의 운영체제가 CPU 스케줄링을 위해 일반적으로 사용되는 방식이나 구현이 어려움
    - 우선순위가 변동되기 때문에 기아현상으로 인한 문제를 해소할 수 있음

<br>

### 비선점형 스케줄링 알고리즘 종류
- #### 우선순위 스케줄링 (Priority Scheduling)
    - 프로세스에게 우선순위를 정적 혹은 동적으로 부여하며 우선순위가 높은 순서대로 처리함
    - 준비 큐에 프로세스가 도착하면 도착한 프로세스의 우선순위와 현재 실행 중인 프로세스의 우선순위를 비교하여 우선순위가 가장 높은 프로세스에 프로세서를 할당하는 방식
    - 우선순위가 동일한 프로세스가 준비 큐로 들어오면 FIFO의 순서대로 스케줄링을 하게 됨
    - 우선순위가 높은 작업이 계속해서 들어오면 우선순위가 낮아 실행하지 못하는 기아 상태가 유발될 수 있음
- #### FCFS 스케줄링 (First Come First Served Scheduling)
    - 먼저 들어온 작업을 먼저 처리하는 방식
    - 비선점형 방식으로 선입 선출(FIFO, First In First Out)이라고도 함
    - 알고리즘이 단순하고 구현이 간단 (큐로 구현 가능)
    - CPU를 점유할 때까지 다른 프로세스들은 대기 해야 함 -> convoy effect 발생 가능 (convoy effect : 처리 시간이 긴 CPU를 점유하여 다른 프로세스들의 대기 시간이 길어져 시스템 효율이 떨어지는 것을 말함)
- #### SJF 스케줄링 (Shortest Job First Scheduling)
    - 실행 시간이 짧은 작업부터 먼저 처리하는 방식. 실행시간이 스케줄링 판단 구조
    - 최단 작업 우선 스케줄링이라고도 함
    - 선점형, 비선점형 모두 적용될 수 있으나, 선점형에 적용되는 SJF 스케줄링을 특별히 SRTF 스케줄링이라고 함
    - 평균 대기 시간을 최소화 할 수 있음
    - 프로세스 작업 길이를 추정하는 것이 힘들고, 특정 프로세스가 기아 상태에 빠질 수 있어 현실적으로 사용되기 어려움
- #### HRRN 스케줄링 (Highest Response Ratio Next Scheduling)
    - 준비 큐에 있는 프로세스들 중에서 응답률이 가장 높은 프로세스에게 높은 우선순위를 주는 방식
    - 응답률(우선순위) = (대기시간 + CPU 사용시간) / CPU 사용 시간
    - SJF의 문제점인 기아 현상을 보완하기 위해 개발된 방식. HRRN은 에이징(aging)을 통해 기아 현상을 해결 (대기 시간에 따라 우선순위를 증가시켜주는 방법. 오래 기다린만큼 우선순위를 높여주어 결국 실행될 수 있도록 하는 것)
    - 실행시간이 짧은 프로세스를 우선순위를 높게 설정하면서도 대기 시간을 고려하여 기아 현상을 완화시키나 여전히 공평성은 떨어짐

<br>

<div style="text-align: right">22-08-03</div>

-------

## Reference
- https://gamedevlog.tistory.com/78
- https://www.uname.in/252