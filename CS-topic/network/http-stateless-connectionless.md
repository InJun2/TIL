# HTTP Stateless, Connectionless

### HTTP (Hyper Text Transfer Protocol)
- HTTP는 문서를 전송하기 위한 규약. 
- HTTP의 구조는 클라이언트-서버 구조로 어떻게 메시지를 교환할지 정해 놓은 규칙.
- 클라이언트가 서버에 request 요청을 보내고, 서버는 클아이언트에게 Response 응답을 보냄
- HTTP는 요청을 받을 때에만 연결을 유지하고 응답 이후에는 TCP/IP 연결을 끊어 연결을 유지 하지 않음. HTTP는 비연결성을 가짐. 이를 통해 최소한의 자원으로 서버 유지를 가능케 함
- 그러나 HTML 뿐만아니라 JS, CSS 혹은 이미지 등 여러 미디어데이터를 응답하는 경우 트래픽이 많아 큰 규모의 서비스 운영시 비연결성은 한계를 보임
    - 현재는 HTTP 지속 연결(Persistent Connections)로 문제 해결
- HTTP 지속 연결에서는 TCP/IP 연결과 종료 과정 사이에 HTML 요청 및 응답, JS 요청 및 응답, 이미지 요청 및 응답을 모두 수행한 후 연결을 종료하여 데이터 전송에서 기존 방식보다 더 짧은 시간이 소요
- 서버가 클라이언트의 상태를 보존하지 않는 무상태(Stateless) 프로토콜. 상태를 보존하지 않는다는 의미는 클아이언트가 반복적인 요청을 보낼때에도 이미 보낸 요청을 반복해서 보내야 한다는 것
    - 무상태성은 서버가 상태를 보존하지 않아 서버를 확장하기 용이. 그러나 클라이언트가 이미 전송한 요청을 반복적으로 추가적인 데이터를 전송해야 함

<br>

## Ssafy Wizards CS Study

### 1. HTTP Stateless 구조를 채택 이유
- 서버는 각 요청이 독립적이며 이전 요청의 상태를 기억할 필요가 없어 클라이언트의 상태를 관리할 필요가 없어 여러 클라이언트의 상태를 추적하는 데 따른 서버의 부하가 감소
    - 각 요청 처리 후 상태 정보를 저장하거나 불러오는 데 필요한 추가 리소스를 절약
- Stateless 구조에서는 특정 서버가 클라이언트의 상태를 유지할 필요가 없기 때문에 로드 밸런서를 사용하여 클라이언트 요청을 여러 서버에 자유롭게 분산이 가능
- 클라이언트는 각 요청에서 필요한 모든 정보를 서버에 전송할 수 있으며 서버는 그 요청만을 처리하면 되므로 유연
- 웹은 문서 기반의 리소스를 제공하는 데 중점을 두며 각 리소스 요청은 독립적으로 처리될 수 있는데 해당 동작 원리와 잘 맞음
- Stateless 구조에서는 동일한 요청에 대해 언제나 동일한 응답이 반환되므로 클라이언트나 중간 서버가 요청 결과를 쉽게 캐싱이 가능

<br>

### 2. Connectionless의 성능 해결 방법
- HTTP/1.0과 같은 초기 버전에서는 클라이언트가 서버에 요청을 보내고 응답을 받은 후 연결이 바로 종료되었으나 그러나 웹 애플리케이션의 복잡성과 효율성 요구가 증가되어 몇몇 성능 해결 방법이 제시됨
- HTTP/1.1의 지속 연결 (Persistent Connections)을 통해 한 번 연결을 설정하면 여러 HTTP 요청/응답을 같은 연결을 통해 처리할 수 있게함
    - 클라이언트와 서버가 Connection: keep-alive 헤더를 사용하여 연결을 유지 (연결을 유지하려면 메시지 전송마다 해당 헤더를 계속 유지해야함)
- HTTP/1.1의 파이프라이닝 (Pipelining)을 통해 클라이언트가 여러 요청을 한 번에 보낼 수 있어 서버는 이 요청들을 순서대로 처리하여 응답함
    -  클라이언트가 각 요청에 대한 응답을 기다리지 않고 다음 요청을 보낼 수 있어 대기 시간을 줄일 수 있음
- HTTP/2의 다중화 (Multiplexing)를 통해 여러 요청과 응답을 동시에 처리 가능. 각 요청/응답이 독립적인 스트림으로 처리하여 한 요청이 지연되도 다른 요청이 지연되지 않음
- 브라우저에서의 커넥션 풀링 (Connection Pooling)을 통해 같은 서버에 대한 여러 요청을 하나의 TCP 연결을 재사용하여 처리
    - HTTP/1.1의 keep-alive 기능과 유사하게 동작
- HTTP/2의 서버 푸시 (Server Push)
    - HTTP/2는 서버가 클라이언트가 요청하지 않은 리소스를 미리 전송할 수 있는 서버 푸시 기능을 제공
    - 클라이언트가 HTML 페이지를 요청할 때 서버는 그 페이지에 포함된 CSS나 JS 파일을 미리 푸시 가능

<br>

### 3. TCP의 keep-alive와 HTTP의 keep-alive의 차이
- TCP의 keep-alive는 오래된 비활성 연결을 확인하고 유지하기 위한 메커니즘
    - 연결이 유효한지 확인하고 끊어진 연결을 감지하여 자원을 회수하기 위한 방법으로 주로 네트워크 상태를 확인하는 데 사용
- HTTP의 keep-alive는 다수의 HTTP 요청/응답을 하나의 TCP 연결에서 처리하여 연결 설정과 해제에 따른 오버헤드를 줄이기 위한 메커니즘
    - 다수의 HTTP 요청/응답을 같은 TCP 연결에서 처리하여 연결 설정/해제의 오버헤드를 줄이기 위함