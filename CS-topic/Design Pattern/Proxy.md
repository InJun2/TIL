# 프록시 패턴(Proxy Pattern)

### 프록시 패턴
- 프록시(Proxy)를 번역하면 대리자, 대변인의 의미
- 어떤 객체를 사용하고자 할때, 객체를 직접적으로 참조하는 것이 아닌 해당 객체를 대항하는 객체를 통해 대상 객체에 접근하는 방식을 사용하여 대신해서 그 역할을 수행하는 패턴
- 해당 객체가 메모리에 존재하지 않아도 기본적인 정보를 참조하거나 설정할 수 있고, 실제 객체의 기능이 필요한 시점까지 객체의 생성을 미룰 수 있음
- 예를 들면 용량이 큰 이미지와 글이 같이 있는 문서를 화면에 띄운다고 가정했을때 로딩이 먼저 끝난 텍스트를 먼저 나오게 하는 것이 좋고 이와 같은 방식을 가지기 위해 텍스트 처리용 프로세스, 이미지 처리용 프로세스를 별도로 운영하면 됨
    - 프록시 패턴을 이용하여 기존 객체에 직접 접근하지 않고 대신 일을 수행가능

<br>

### 프록시 패턴의 장점과 단점
#### 장점
- 사이즈가 큰 객체가 로딩되기 전에도 프록시를 통해 참조를 할 수 있음
- 실제 객체의 public, protected 메소드를 숨기고 인터페이스를 통해 노출시킬 수 있음
- 로컬에 있지 않고 떨어져있는 객체를 사용할 수 있음
- 원래 객체에 접근에 대해 사전처리를 할 수 있음

<br>

#### 단점
- 객체를 생성할 때 한 단계를 거치게 되므로, 빈번한 객체 생성이 필요한 경우 성능이 저하될 수 있음
- 프록시 내부에서 객체 생성을 위해 스레드가 생성, 동기화가 구현되어야 하는 경우 성능이 저하 될 수 있음
- 로직이 난해해져 가독성이 떨어질 수 있음

<br>

### 프록시 패턴의 종류
#### 가상 프록시(Virtual Proxy)
- 꼭 필요로 하는 시점까지 객체의 생성을 연기하고 해당 객체가 생성된 것 처럼 동작하도록 만들고 싶을 때 사용하는 패턴
- 프록시 클래스에서 작은 단위의 작업을 처리하고 리소스가 많이 요구되는 작업들이 필요할 경우만 주체 클래스를 사용하도록 구현

<br>

#### 원격 프록시(Remote Proxy)
- 원격 객체에 대한 접근을 제어 로컬 환경에 존재하며 원격 객체에 대한 대변자 역할을 하는 패턴
- 서로 다른 주소 공간에 있는 객체에 대해 마치 같은 주소 공간에 있는 것 처럼 동작
- 원격 프록시는 다음 질문과 같이 클라이언트와 원본의 위치에 따라 세부적으로 나뉘어질 수 있음
    - 클라이언트와 원본이 같은 머신에서 실행되는가?
    - 클라이언트와 원본이 다른 프로세스에서 실행되는가?

<br>

#### 보호 프록시(Protection Proxy)
- 주체 클래스에 대한 접근을 제어하기 위한 경우에 객체에 대한 접근 권한을 제어하거나 객체마다 접근 권한을 달리하고 싶은 경우 사용하는 패턴
- 프록시 클래스에서 클라이언트가 주체 클래스에 대한 접근을 허용할지말지 결정하도록 할 수 있음

<br>

#### 캐시 프록시(Cache Proxy)
- 다수의 로컬 클라이언트들이 원격 컴포넌트로부터 얻어낸 결과를 공유할 수 있는 패턴
- 캐시 프록시는 캐시를 보관하는 프록시이므로, 캐시 프록시를 구현할 때에는 다음 사항에 대해서도 고민해야함
    - 캐시를 어떻게 저장할 것인가?
    - 캐시를 어떻게 갱신할 것인가?
    - 캐시 유효성을 어떻게 검사할 것인가?

<div style="text-align: right">22-10-04</div>

-------

## Reference
- https://velog.io/@newtownboy/디자인패턴-프록시패턴Proxy-Pattern
- https://johngrib.github.io/wiki/pattern/proxy/