# SOLID
>- SOLID는 객체지향 5대 원칙
>- 객체지향은 캡슐화, 상속, 추상화, 다형성의 특성을 가지고 설계 원칙에 따라서 설계를 진행하여야 하는데 이를 올바르게 설계할 수 있도록 도와주는 원칙들임
>1) SRP ( Single Responsibility Principle : 단일책임의 원칙 )
>2) OCP ( Open Close Principle : 개방폐쇄의 원칙 )
>3) LSP ( The Liskov Substitution Principle : 리스코브 치환의 원칙 )
>4) ISP ( Interface Segregation Principle : 인터페이스 분리의 원칙 )
>5) DIP ( Dependency Inversion Principle : 의존성 역전의 원칙 )

<br>

### SRP 단일 책임 원칙 
>- 한 클래스는 하나의 책임만 가져야 한다.
>- 하나의 책임이라는 것은 모호한 개념. 클수도 있고 작을수도 있으며 문맥과 상황에 따라 다름
>- 중요한 기준은 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙에 잘 따른 것.
>- ‘어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다’

<br>

### OCP 개방 폐쇄 원칙
>- 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다.
>- 주로 확장에는 다형성을 활용하여 기존코드는 건드리지 않고 확장.
>- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
>- ‘소프트웨어 엔티티는 확장에 대해서는 열려 있어야하지만 변경에 대해서는 닫혀 있어야 한다’

<br>

### LSP 리스코프 치환 원칙
>- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다 ( 규약이 있을 경우 기능적으로 해당 규약을 지켜줘야 함 )
>- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야하며, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체는 믿고 사용하려면 해당 원칙이 필요
>- 단순히 컴파일에 성공하는 것을 넘어서는 내용
>- ‘서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다’ 

<br>

### ISP 인터페이스 분리 원칙
>- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 좋음
>- 기능에 맞게, 적당한 크기로 쪼개는 것이 좋음
>- 기능에 따라 접근하는 클라이언트 인터페이스를 분리하여 하나의 인터페이스가 변해도 다른 인터페이스에는 영향을 주지 않음.
>- 인터페이스가 명확해지고 대체 가능성이 높아진다.
>- ‘ 결론적으로 단일책임원칙과 인터페이스 분리 원칙은 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다. 하지만 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책이라고 할 수 있다.’

<br>

### DIP 의존관계 역전 원칙
>- 프로그래머는 구체화보다 추상화에 의존한다. 의존성 주입은 이 원칙을 따르는 방법 중 하나
>- 구현 클래스에 의존하지 않고 추상클래스(인터페이스)에 의존
>- 상위 클래스, 인터페이스 일수록 변하지 않을 가능성이 높음.
>- 역할에 의존해야한다는 것과 같음. 인터페이스에 의존하여 유연하게 구현체를 변경하는데 유용. 구현체에 의존할 경우 변경이 아주 어려워짐.
>- 역할과 구현이 철저하게 구분이 되어있어야 함.
>- ‘고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야한다. 추상화된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다. 자주 변경되는 구체 클래스에 의존하지 마라’

<br>

<div style="text-align: right">22-06-20</div>

-------

## Reference
- https://www.nextree.co.kr/p6960/ 
- https://velog.io/@shienka07/SOLID-란